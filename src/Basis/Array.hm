open import Rudiments

let List = List0

let T = {|
    type t 'a ^t: ^&t a = ^t&array a
    type elm 'a: elm a = a

    let Builder = {|
        # `array_builder` is built into the compiler similarly to `array`, but it is only exposed
        # when compiling Basis code, as controlled by a compiler flag.
        type t 'a: &t a = &array_builder a

        external alloc_lput 'a: uns -> a -> &t a = "hm_basis_array_builder_alloc_lput"
        external alloc_rput 'a: uns -> a -> &t a = "hm_basis_array_builder_alloc_rput"
        external lput 'a: a -> !&t a -> unit = "hm_basis_array_builder_lput"
        external rput 'a: a -> !&t a -> unit = "hm_basis_array_builder_rput"
        external build 'a ^t: !&t a -> ^&t a = "hm_basis_array_builder_build"
      |}

    external empty 'a ^t: ^&t a = "hm_basis_array_empty"

    external get 'a: uns -> _&t a -> a = "hm_basis_array_get"

    external length 'a: _&t a -> uns = "hm_basis_array_length"

    let Cursor = {|
        let T = {|
            type container 'a ^container: ^&container a = ^container&t a
            type t 'a ^container: t a container =
                array: ^&container a
                index: uns

            (* val cmp 'a ^container: t a container -> t a container -> Cmp.t *)
            let cmp t0 t1 =
                Uns.cmp t0.index t1.index

            (* val hd 'a ^container: ^&container a -> t a container *)
            let hd array =
                {array; index=0}

            (* val tl 'a ^container: ^&container a -> t a container *)
            let tl array =
                {array; index=length array}

            (* val seek 'a ^container: sint -> t a container -> t a container *)
            let seek i t =
                match Sint.(i < 0i) with
                | true ->
                    match Uns.((of_sint Sint.(neg i)) > t.index) with
                    | true -> halt "Cannot seek before beginning of array"
                    | false -> {t with index=Uns.(t.index - of_sint (Sint.neg i))}
                | false ->
                    match Uns.((t.index + (of_sint i)) > (length t.array)) with
                    | true -> halt "Cannot seek past end of array"
                    | false -> {t with index=t.index + (Uns.of_sint i)}

            (* val succ 'a ^container: t a container -> t a container *)
            let succ t =
                seek 1i t

            (* val pred 'a ^container: t a container -> t a container *)
            let pred t =
                seek (-1i) t

            (* val lget 'a: t a _ -> a *)
            let lget t =
                get (pred t.index) t.array

            (* val rget 'a: t a _ -> a *)
            let rget t =
                get t.index t.array

            (* val container 'a ^container: t a container -> ^&container a *)
            let container t =
                t.array

            (* val index: t _ _ -> uns *)
            let index t =
                t.index
          |}
        include T
        include Cmpable.makePoly(T)
      |}

    let cmp cmp_elm t0 t1 =
        let rec fn cursor0 cursor1 =
            match Cursor.(cursor0 = (tl t0)), Cursor.(cursor1 = (tl t1)) with
            | true, true -> Cmp.Eq
            | true, false -> Cmp.Lt
            | false, true -> Cmp.Gt
            | false, false ->
                match cmp_elm (Cursor.rget cursor0) (Cursor.rget cursor1) with
                | Cmp.Lt -> Cmp.Lt
                | Cmp.Eq -> fn (Cursor.succ cursor0) (Cursor.succ cursor1)
                | Cmp.Gt -> Cmp.Gt
        fn (Cursor.hd t0) (Cursor.hd t1)
  |}
include T
include ContainerCommon.makePolyFold(T)

let hash_fold hash_fold_a t state =
    fold t ~init:state ~f:(fn state elm -> state |> hash_fold_a elm)

let Seq = {|
    type outer 'a ^outer: ^&outer a = ^outer&t a
    type SMono: SMono =
        type t ^t: ^&t
        type elm ^elm: ^&elm
        val to_array ^t ^elm ^outer: ^&t -> ^&elm ^&outer
    type SPoly: SPoly =
        type t 'a ^t: ^&t a
        type elm 'a: elm a
        val to_array 'a ^t ^outer: ^&t a -> ^&outer elm a

    let makeMono (T : SeqIntf.IMonoDef) : SMono
      with type t ^t: ^&t := T.^&t
      with type elm ^elm: ^&elm := T.^&elm
      = {|
        let to_array t =
            match T.length t with
            | 0 -> [||]
            | l ->
                let rec fn t i builder =
                    match i = l with
                    | true -> Builder.build builder
                    | false ->
                        let elm, t' = T.next t
                        Builder.lput elm builder
                        fn t' (succ i) builder
                let elm, t' = T.next t
                fn t' 1 (Builder.alloc_lput l elm)
      |}

    let makeMonoRev (T : SeqIntf.IMonoDef) : SMono
      with type t ^t: ^&t := T.^&t
      with type elm ^elm: ^&elm := T.^&elm
      = {|
        let to_array t =
            match T.length t with
            | 0 -> [||]
            | l ->
                let rec fn t i builder =
                    match i = 0 with
                    | true -> Builder.build builder
                    | false ->
                        let elm, t' = T.next t
                        Builder.rput elm builder
                        fn t' (pred i) builder
                let elm, t' = T.next t
                fn t' (pred l) (Builder.alloc_rput l elm)
      |}

    let makePoly (T : SeqIntf.IPolyDef) : SPoly
      with type t 'a ^t: ^&t a := T.^&t a
      with type elm 'a: elm a := T.elm a
      = {|
        let to_array t =
            match T.length t with
            | 0 -> [||]
            | l ->
                let rec fn t i builder =
                    match i = l with
                    | true -> Builder.build builder
                    | false ->
                        let elm, t' = T.next t
                        Builder.lput elm builder
                        fn t' (succ i) builder
                let elm, t' = T.next t
                fn t' 1 (Builder.alloc_lput l)
      |}

    let makePolyRev (T : SeqIntf.IPolyDef) : SPoly
      with type t 'a ^t: ^&t a := T.^&t a
      with type elm 'a: elm a := T.elm a
      = {|
        let to_array t =
            match T.length t with
            | 0 -> [||]
            | l ->
                let rec fn t i builder =
                    match i = 0 with
                    | true -> Builder.build builder
                    | false ->
                        let elm, t' = T.next t
                        Builder.rput elm builder
                        fn t' (pred i) builder
                let elm, t' = T.next t
                fn t' (pred l) (Builder.alloc_rput l elm)
      |}

    (* Special-purpose, for fold[i]_map . *)
    let makePoly2 (T :
        type t 'a ^arr >e: t a arr e
        type accum: accum
        type b: b
        val length 'a ^arr: t a arr _ -> uns
        val next 'a ^arr >e: t a arr e -> accum >e-> (b, t a arr e, accum)
      ) :
        type t 'a ^arr >e: t a arr e
        type accum: accum
        type b: b
        val to_accum_array 'a ^arr ^outer >e: t a arr e -> init:accum >e-> (accum, ^&outer b)
      with type t 'a ^arr >e: t a arr e := T.t a arr e
      with type accum: accum := T.accum
      with type b: b := T.b
      = {|
        # Alternatively, `include T`, omit redundant type definitions and use `{length,next}`
        # instead of `T.{length,next}`. The type ascription prevents exposing `{length,next}`
        # outside `makePoly2(T)`, so this approach would produce outwardly identical results.
        type t 'a ^arr >e: t a arr e = T.t a arr e
        type accum: accum = T.accum
        type b: b = T.b
        let to_accum_array t ~init =
            match T.length t with
            | 0 -> init, [||]
            | l ->
                let rec fn t i accum builder =
                    match i = l with
                    | true -> accum, (Builder.build builder)
                    | false ->
                        let elm, t', accum' = T.next t accum
                        Builder.lput elm builder
                        fn t' (succ i) accum' builder
                let elm, t', accum = T.next t init
                fn t' 1 accum (Builder.alloc_lput l elm)
      |}

    (* Special-purpose, for fold[i]2_map . *)
    let makePoly3 (T :
        type 'a 'b ^m ^n >e: t a b m n e
        type accum: accum
        type c: c
        val length 'a 'b ^m ^n: t a b m n _ -> uns
        val next 'a 'b ^m ^n >e: t a b m n e -> accum >e-> (c, t a b m n e, accum)
      ) :
        type 'a 'b ^m ^n >e: t a b m n e := T.t a b m n e
        type accum: accum
        type c: c
        val to_accum_array 'a 'b ^m ^n ^outer >e: t a b m n e -> init:accum >e->
          (accum, ^&outer c)
      with type t 'a 'b ^m ^n >e: t a b m n e := T.t a b m n e
      with type accum: accum := T.accum
      with type b: b := T.b
      = {|
        type 'a 'b ^m ^n >e: t a b m n e = T.t a b m n e
        type accum: accum = T.acum
        type c: c = T.c
        let to_accum_array t ~init =
            match T.length t with
            | 0 -> init, [||]
            | l ->
                let rec fn t i accum builder =
                    match i = l with
                    | true -> accum, (Builder.build builder)
                    | false ->
                        let elm, t', accum' = T.next t accum
                        Builder.lput elm builder
                        fn t' (succ i) accum' builder
                let elm, t' accum = T.next t init
                fn t' 1 accum (Builder.alloc_lput l elm)
      |}
  |}

let ArrayInit = {|
    let T = {|
        type t >e: t e =
            f a >e: uns >e-> a
            index : uns
            length: uns
        type elm 'a: elm a = a

        (* val init 'a >e: uns -> f:(uns >e-> a) >e-> t e *)
        let init base length ~f =
            {f; index=base; length}

        (* val length: t _ -> uns *)
        let length t =
            t.length

        (* val next 'a >e: t e >e-> (a, t e) *)
        let next t =
            let elm = t.f t.index
            let t' = {t with index=(succ t.index)}
            elm, t'
      |}
    include T
    include Seq.makePoly(T)
    (* val to_array 'a ^outer >e: t e >e-> ^&outer a *)
  |}

let init range ~f =
    ArrayInit.(to_array (init (Range.base range) (Range.length range) ~f))

let ArrayOfListCommon = {|
    type t 'a: t a =
        list: list a
        length: uns
    type elm 'a: elm a = a

    let init length list =
        {list; length}

    let length t =
        t.length

    let next t =
        match t.list with
        | [] -> not_reached ()
        | elm :: list' ->
            let t' = {t with list=list'}
            elm, t'
  |}

let ArrayOfList = {|
    include ArrayOfListCommon
    include Seq.makePoly(ArrayOfListCommon)
  |}

let ArrayOfListRev = {|
    include ArrayOfListCommon
    include Seq.makePolyRev(ArrayOfListCommon)
  |}

let of_list ?length list =
    let length = match length with
        | None -> List.length list
        | Some length -> length
    ArrayOfList.to_array (ArrayOfList.init length list)

let of_list_rev ?length list =
    let length = match length with
        | None -> List.length list
        | Some length -> length
    ArrayOfListRev.to_array (ArrayOfListRev.init length list)

let is_empty t =
    (length t) = 0

external set_inplace 'a: uns -> a -> !&t a -> unit = "hm_basis_array_set_inplace"

let copy t =
    init (0 .. (length t)) ~f:(fn i -> get i t)

let pare range t =
    init range ~f:(fn i -> get i t)

let set i elm t =
    let t' = copy t
    set_inplace i elm t'
    t'

let ArrayJoin = {|
    let T = {|
        type outer 'a ^outer: ^&outer a = ^outer&t a
        type t 'a ^sep ^arrays: t a sep arrays =
            sep: ^sep&outer a
            arrays: list ^arrays&outer a
            length: uns
            in_sep: bool
            index: uns
        type elm 'a: elm a = a

        (* val init 'a ^sep ^arrays: uns -> ^sep&outer a -> list ^arrays&outer a -> t a sep arrays *)
        let init length sep arrays =
            {sep; arrays; length; in_sep=false; index=0}

        (* val next 'a ^sep ^arrays: t a sep arrays -> (a, t a sep arrays) *)
        let next t =
            let rec fn t =
                match t.in_sep with
                | false ->
                    let array = List.hd t.arrays
                    match t.index < length array with
                    | true ->
                        let elm = get t.index array
                        let t' = {t with index=succ t.index}
                        elm, t'
                    | false -> fn {t with
                        arrays=List.tl t.arrays
                        in_sep=true
                        index=0
                      }
                | true ->
                    match t.index < length t.sep with
                    | true ->
                        let elm = get t.index t.sep
                        let t' = {t with index=succ t.index}
                        elm, t'
                    | false -> fn {t with in_sep=false; index=0}
            fn t

        let length t =
            t.length
      |}
    include T
    include Seq.makePoly(T)
    (* val to_array 'a ^sep ^arrays ^outer: t a sep arrays -> ^&outer a *)
  |}

let join ?sep tlist =
    let sep, sep_len = match sep with
        | None -> [||], 0
        | Some sep -> sep, length sep
    let _, tlist_length = List.fold tlist ~init:(0, 0)
      ~f:(fn (i, accum) list ->
        let i' = succ i
        let sep_len' = match i with
            | 0 -> 0
            | _ -> sep_len
        let accum' = accum + sep_len' + (length list)
        i', accum'
      )
    ArrayJoin.(to_array (init tlist_length sep tlist))

let concat t0 t1 =
    let length_t0 = length t0
    let length_t1 = length t1
    let length = length_t0 + length_t1
    init (0 .. length) ~f:(fn i ->
        if i < length_t0 then get i t0
        else get (i - length_t0) t1
      )

let append elm t =
    let tlen = length t
    init (0 .. (succ tlen)) ~f:(fn i ->
        if i < tlen then get i t
        else elm
      )

let prepend elm t =
    init (0 .. (succ (length t))) ~f:(fn i ->
        if i = 0 then elm
        else get (pred i) t
      )

let insert i elm t =
    if i = 0 then
        prepend elm t
    else
        let len = length t
        if i < len then
            init (0 .. (succ len)) ~f:(fn index ->
                match Uns.cmp index i with
                | Lt -> get index t
                | Eq -> elm
                | Gt -> get (pred index) t
              )
        else
            append elm t

let remove i t =
    let len = length t
    assert (len > 0)
    match len with
    | 1 ->
        assert (i = 0)
        [||]
    | _ ->
        if i = 0 then
            pare (1 .. len) t
        else if i < len then
            init (0 .. (pred len)) ~f:(fn index ->
                if index < i then get index t
                else get (succ index) t
              )
        else
            pare (0 .. (pred len)) t

let reduce ~f t =
    let rec fn i accum =
        match (i = (length t)) with
        | true -> accum
        | false -> fn (succ i) (f accum (get i t))
    match t with
    | [||] -> None
    | _ -> Some (fn 1 (get 0 t))

let reduce_hlt ~f t =
    match reduce ~f t with
    | None -> halt "Empty array"
    | Some x -> x

let swap_inplace i0 i1 t =
    let elm0 = get i0 t
    let elm1 = get i1 t
    set_inplace i0 elm1 t
    set_inplace i1 elm0 t

let swap i0 i1 t =
    let t' = copy t
    swap_inplace i0 i1 t'
    t'

let rev_inplace t =
    let rec fn i0 i1 =
        match (i0 >= i1) with
        | true -> ()
        | false ->
            swap_inplace i0 i1 t
            fn (succ i0) (pred i1)
    let len = length t
    match len with
    | 0 -> ()
    | _ -> fn 0 (pred len)

let rev t =
    let l = length t
    init (0 .. l) ~f:(fn i -> get (l - i - 1) t)

(* Used directly for non-overlapping blits. *)
let blit_ascending len i0 t0 i1 t1 =
    for i = 0 to pred len do
        set_inplace (i1 + i) (get (i0 + i) t0) t1
let blit_descending len i0 t0 i1 t1 =
    for i = pred len downto 0 do
        set_inplace (i1 + i) (get (i0 + i) t0) t1

let blit len i0 t0 i1 t1 =
    assert (Range.length r0 = Range.length r1)
    (* Choose direction such that overlapping ranges don't corrupt the source. *)
    match Range.(base r0 < base r1) with
    | true -> blit_descending len (Range.base r0) t0 (Range.base r1) t1
    | false -> blit_ascending len (Range.base r0) t0 (Range.base r1) t1

let is_sorted ?(strict=false) ~cmp t =
    let len = length t
    let rec fn elm i =
        match i = len with
        | true -> true
        | false ->
            let elm' = get i t
            match (cmp elm elm'), strict with
            | Cmp.Lt, _
            | Cmp.Eq, false -> fn elm' (succ i)
            | Cmp.Eq, true
            | Cmp.Gt, _ -> false
    match len with
    | 0 -> true
    | _ -> fn (get 0 t) 1

type order =
    | Increasing
    | Decreasing
    | Either
type run =
    base: uns
    past: uns
let sort_impl ?(stable=false) ~cmp ~inplace t =
    (* Merge a pair of adjacent runs. Input runs may be in increasing or decreasing order; the
     * output is always in increasing order. *)
    let merge_pair ~cmp src run0 order0 run1 order1 dst =
        assert (run0.past = run1.base)
        let rblit len i0 t0 i1 t1 =
            for i = 0 to pred len do
                set_inplace (i1 + i) (get (i0 + len - (i + 1)) t0) t1
        let merge_pair_oo ~cmp src run0 order0 run1 order1 dst =
            let rec fn ~cmp src run0 order0 run1 order1 dst run =
                match (run0.base = run0.past), (run1.base = run1.past) with
                | false, false ->
                    let elm0 = match order0 with
                        | Increasing -> get run0.base src
                        | Decreasing -> get (pred run0.past) src
                        | Either -> not_reached ()
                    let elm1 = match order1 with
                        | Increasing -> get run1.base src
                        | Decreasing -> get (pred run1.past) src
                        | Either -> not_reached ()
                    match cmp elm0 elm1 with
                    | Cmp.Lt
                    | Cmp.Eq ->
                        match order0 with
                        | Increasing ->
                            set_inplace run.past elm0 dst
                            let run0' = {run0 with base=succ run0.base}
                            let run' = {run with past=succ run.past}
                            fn ~cmp src run0' order0 run1 order1 dst run'
                        | Decreasing ->
                            set_inplace run.past elm0 dst
                            let run0' = {run0 with past=pred run0.past}
                            let run' = {run with past=succ run.past}
                            fn ~cmp src run0' order0 run1 order1 dst run'
                        | Either -> not_reached ()
                    | Cmp.Gt ->
                        match order1 with
                        | Increasing ->
                            set_inplace run.past elm1 dst
                            let run1' = {run1 with base=succ run1.base}
                            let run' = {run with past=succ run.past}
                            fn ~cmp src run0 order0 run1' order1 dst run'
                        | Decreasing ->
                            set_inplace run.past elm1 dst
                            let run1' = {run1 with past=pred run1.past}
                            let run' = {run with past=succ run.past}
                            fn ~cmp src run0 order0 run1' order1 dst run'
                        | Either -> not_reached ()
                | true, false ->
                    let len = run1.past - run1.base
                    let () = match order1 with
                        | Increasing -> blit_ascending len run1.base src run.past dst
                        | Decreasing -> rblit len run1.base src run.past dst
                        | Either -> not_reached ()
                    {run with past=run.past + len}
                | false, true ->
                    let len = run0.past - run0.base
                    let () = match order0 with
                        | Increasing -> blit_ascending len run0.base src run.past dst
                        | Decreasing -> rblit len run0.base src run.past dst
                        | Either -> not_reached ()
                    {run with past=run.past + len}
                | true, true -> not_reached ()
            fn ~cmp src run0 order0 run1 order1 dst {base=run0.base;
              past=run0.base}
        let order0', order1' = match order0, order1 with
            | Increasing, Increasing
            | Increasing, Either
            | Either, Increasing
            | Either, Either -> Increasing, Increasing
            | Increasing, Decreasing -> Increasing, Decreasing
            | Decreasing, Increasing -> Decreasing, Increasing
            | Decreasing, Decreasing
            | Decreasing, Either
            | Either, Decreasing -> Decreasing, Decreasing
        merge_pair_oo ~cmp src run0 order0' run1 order1' dst
    (* Select monotonic runs and merge run pairs. *)
    let rec select ~stable ~cmp elm base i order run0_opt order0 src dst runs =
        match i = (length src) with
        | true ->
            let run0, order0, run1, order1 = match run0_opt with
                | None ->
                    (* Copy odd run. *)
                    let run0 = {base; past=i}
                    let run1 = {base=i; past=i}
                    run0, order, run1, Increasing
                | Some run0 -> run0, order0, {base; past=i}, order
            let run = merge_pair ~cmp src run0 order0 run1 order1 dst
            run :: runs
        | false ->
            let elm' = get i src
            let i' = succ i
            match cmp elm elm', order, stable with
            | Cmp.Lt, Either, _ -> select ~stable ~cmp elm' base i' Increasing
              run0_opt order0 src dst runs
            | Cmp.Gt, Either, _ -> select ~stable ~cmp elm' base i' Decreasing
              run0_opt order0 src dst runs
            | Cmp.Lt, Increasing, _
            | Cmp.Eq, Increasing, true
            | Cmp.Eq, Either, true -> select ~stable ~cmp elm' base i'
              Increasing run0_opt order0 src dst runs
            | Cmp.Eq, _, false
            | Cmp.Gt, Decreasing, _ -> select ~stable ~cmp elm' base i' order
              run0_opt order0 src dst runs
            | Cmp.Lt, Decreasing, _
            | Cmp.Eq, Decreasing, true
            | Cmp.Gt, Increasing, _ ->
                let run0_opt', order0', runs' = match run0_opt with
                    | None -> Some {base; past=i}, order, runs
                    | Some run0 ->
                        let run1 = {base; past=i}
                        let run = merge_pair ~cmp src run0 order0 run1 order dst
                        None, Either, (run :: runs)
                select ~stable ~cmp elm' i i' Either run0_opt' order0' src dst runs'
    let aux = copy t
    let runs = match t with
        | [||] -> [{base=0; past=0}]
        | _ -> select ~stable ~cmp (get 0 t) 0 1 Either None Either t aux []

    (* Repeatedly sweep through runs and merge pairs until only one run remains. Take care to
     * read/write linearly up/down based on the sweep direction, in order to improve cache locality.
     *)
    let rec merge ~cmp ~inplace src to_merge up dst merged =
        match to_merge, up, merged with
        | run0 :: run1 :: to_merge', true, _
        | run1 :: run0 :: to_merge', false, _ ->
            let run = merge_pair ~cmp src run0 Increasing run1 Increasing dst
            merge ~cmp ~inplace src to_merge' up dst (run :: merged)
        | [], _, _ :: _ :: _ ->
            (* Start another sweep. *)
            merge ~cmp ~inplace dst merged (not up) src []
        | run :: [], false, _ ->
            (* Copy odd run to dst, then start another sweep. *)
            blit_descending (run.past - run.base) run.base src run.base dst
            merge ~cmp ~inplace dst (run :: merged) (not up) src []
        | run :: [], true, _ :: _ ->
            (* Copy odd run to dst, then start another sweep. *)
            blit_ascending (run.past - run.base) run.base src run.base dst
            merge ~cmp ~inplace dst (run :: merged) (not up) src []
        | [], true, _ :: []
        | _ :: [], true, [] ->
            match inplace with
            | true ->
                (* Odd number of sweeps performed; copy result back into t. *)
                blit_ascending (length dst) 0 dst 0 src
                src
            | false -> dst
        | [], false, _ :: [] -> dst
        | [], _, [] -> not_reached ()
    merge ~cmp ~inplace aux runs false t []

let sort_inplace ?stable ~cmp t =
    let _ = sort_impl ?stable ~cmp ~inplace:true t
    ()

let sort ?stable ~cmp t =
    sort_impl ?stable ~cmp ~inplace:false (copy t)

let search_impl ?range key ~cmp mode t =
    let base, past = match range with
      | None -> 0L, length t
      | Some range -> Range.base range, Range.past range
    in
    assert (base <= past)
    assert (past <= length t)
    let rec fn ~base ~past =
        assert (base <= past)
        match (base = past) with
        | true ->
            (* Empty range. *)
            match mode with
            | Cmp.Lt ->
                match (base = 0), (base = (length t)) with
                | true, true -> None # Empty; key < elms.
                | _, false -> # At beginning, or interior.
                    match cmp key (get base t) with
                    | Cmp.Lt -> (* At successor. *)
                        match base = 0 with
                        | true -> Some (Cmp.Lt, 0) # At beginning; key < elms.
                        | false -> Some (Cmp.Gt, pred base # In interior; key > predecessor.
                    | Cmp.Eq -> Some (Cmp.Eq, base) # base at leftmost match.
                    | Cmp.Gt -> not_reached ()
                | false, true -> Some (Cmp.Gt, pred base) # Past end; key > elms.
            | Cmp.Eq -> None # No match.
            | Cmp.Gt ->
                match (base = 0), (base = (length t)) with
                | true, true -> None # Empty; key > elms.
                | true, false ->
                    Some (Cmp.Lt, 0) # At beginning; key < elms.
                | false, _ -> # In interior, or past end.
                    let probe = pred base
                    match cmp key (get probe t) with
                    | Cmp.Lt -> not_reached ()
                    | Cmp.Eq -> Some (Cmp.Eq, probe) # probe at rightmost match.
                    | Cmp.Gt ->
                        match (base = (length t)) with
                        | false -> Some (Cmp.Lt, base) # In interior; key < * successor.
                        | true -> Some (Cmp.Gt, probe) # Past end; key > elms.
        | false ->
            let mid = (base + past) / 2
            match (cmp key (get mid t)), mode with
            | Cmp.Lt, _
            | Cmp.Eq, Cmp.Lt -> fn ~base ~past:mid
            | Cmp.Eq, Cmp.Eq -> Some (Cmp.Eq, mid)
            | Cmp.Eq, Cmp.Gt
            | Cmp.Gt, _ -> fn ~base:(succ mid) ~past
    fn ~base ~past

let psearch ?range key ~cmp t =
    search_impl ?range key ~cmp Cmp.Lt t

let search ?range key ~cmp t =
    match search_impl ?range key ~cmp Cmp.Eq t with
    | Some (_, i) -> Some i
    | _ -> None

let nsearch ?range key ~cmp t =
    search_impl ?range key ~cmp Cmp.Gt t

let map ~f t =
    init (0 .. (length t)) ~f:(fn i -> f (get i t))

let mapi ~f t =
    init (0 .. (length t)) ~f:(fn i -> f i (get i t))

let ArrayFoldiMap = {|
    let T = {|
        type outer 'a ^outer: ^&outer a = ^outer&t a
        type t 'a ^arr >e: t a arr e =
            arr: outer a arr
            f 'accum 'b: uns -> accum a >e-> (accum, b)
            index: uns
            length: uns
        (* val init 'a 'accum 'b ^arr >e: ^arr&outer a -> f:(uns -> accum -> a >e-> (accum, b)) ->
         *   uns -> t a arr e *)
        let init arr ~f length =
            {arr; f; length; index=0}

        (* val length 'a ^arr: t a arr _ -> uns *)
        let length t =
            t.length

        (* val next 'a 'accum 'b ^arr >e: t a arr e -> accum >e-> (b, t a arr e, accum) *)
        let next t accum =
            let accum', elm' = t.f t.index accum (get t.index t.arr)
            let t' = {t with index=succ t.index}
            elm', t', accum'
      |}
    include T
    include Seq.makePoly2(T)
    (* val to_accum_array 'a 'accum 'b ^arr ^outer >e: t a arr e >e-> (accum, ^&outer b) *)
  |}

let fold_map t ~init ~f =
    ArrayFoldiMap.to_accum_array (ArrayFoldiMap.init t
      ~f:(fn _ accum elm -> f accum elm) (length t)) ~init

let foldi_map t ~init ~f =
    ArrayFoldiMap.to_accum_array (ArrayFoldiMap.init t ~f (length t)) ~init

let filter ~f t =
    let _, t' = ArrayFoldiMap.to_accum_array
      (ArrayFoldiMap.init t ~f:(fn _ i _ ->
        let rec fn i elm =
            let i' = succ i
            match f elm with
            | true -> i', elm
            | false -> fn i' (get i' t)
        fn i (get i t)
      ) (count ~f t)) ~init:0
    t'

let filteri ~f t =
    let n = foldi t ~init:0 ~f:(fn i accum elm ->
        match f i elm with
        | false -> accum
        | true -> succ accum
      )
    let _, t' = ArrayFoldiMap.to_accum_array
      ArrayFoldiMap.init t ~f:(fn _ i _ ->
        let rec fn i elm =
            let i' = succ i
            match f i elm with
            | true -> i', elm
            | false -> fn i' (get i' t)
        fn i (get i t)
      ) n
      ~init:0
    t'

let foldi2_until ~init ~f t0 t1 =
    assert ((length t0) = (length t1))
    let len = length t0
    let rec fn i accum =
        match i = len with
        | true -> accum
        | false ->
            let accum', until = f i accum (get i t0) (get i t1)
            match until with
            | true -> accum'
            | false -> fn (succ i) accum'
    fn 0 init

let fold2_until ~init ~f t0 t1 =
    foldi2_until ~init ~f:(fn _ accum a b -> f accum a b) t0 t1

let fold2 ~init ~f t0 t1 =
    fold2_until ~init ~f:(fn accum a b -> (f accum a b), false) t0 t1

let foldi2 ~init ~f t0 t1 =
    foldi2_until ~init ~f:(fn i accum a b -> (f i accum a b), false) t0 t1

let iter2 ~f t0 t1 =
    assert ((length t0) = (length t1))
    for i = 0 to pred (length t0) do
        f (get i t0) (get i t1)

let iteri2 ~f t0 t1 =
    assert ((length t0) = (length t1))
    for i = 0 to pred (length t0) do
        f i (get i t0) (get i t1)

let map2 ~f t0 t1 =
    assert ((length t0) = (length t1))
    init (0 .. (length t0)) ~f:(fn i -> f (get i t0) (get i t1))

let mapi2 ~f t0 t1 =
    assert ((length t0) = (length t1))
    init (0 .. (length t0)) ~f:(fn i -> f i (get i t0) (get i t1))

let ArrayFoldi2Map = {|
    let T = {|
        type outer 'a ^outer: ^&outer a = ^outer&t a
        type t 'a 'b ^m ^n >e: t a b m n e =
            arr0: ^m&outer a
            arr1: ^n&outer b
            f 'accum 'c: uns -> accum -> a -> b >e-> (accum, c)
            index: uns

        (* val init 'a 'b ^m ^n >e: ^m&outer a -> ^n&outer b
         *   -> f:(uns -> accum -> a -> b >e-> (accum, c)) -> t a b m n e *)
        let init arr0 arr1 ~f =
            {arr0; arr1; f; index=0}

        (* val length 'a 'b ^m ^n: t a b m n _ -> uns *)
        let length t =
            length t.arr0

        (* val next 'a 'b 'accum 'c ^m ^n >e: t a b m n e -> accum >e-> (c, t a b m n e, accum) *)
        let next t accum =
            let accum', elm' = t.f t.index accum (get t.index t.arr0)
              (get t.index t.arr1)
            let t' = {t with index=Uns.succ t.index}
            elm', t', accum'
      |}
    include T
    include Seq.makePoly3(T)
    (* val to_accum_array 'a 'b 'c ^m ^n ^outer >e: t a b m n e >e-> (accum, ^&outer c) *)
  |}

let fold2_map ~init ~f t0 t1 =
    ArrayFoldi2Map.to_accum_array (ArrayFoldi2Map.init t0 t1 ~f:(fn _ accum elm
      -> f accum elm)) ~init

let foldi2_map ~init ~f t0 t1 =
    ArrayFoldi2Map.to_accum_array (ArrayFoldi2Map.init t0 t1 ~f) ~init

let zip t0 t1 =
    map2 ~f:(fn a b -> a, b) t0 t1

let unzip t =
    let t0 = map ~f:(fn (a, _) -> a) t
    let t1 = map ~f:(fn (_, b) -> b) t
    t0, t1

let fmt ('a:type) (>e:effect) ?(alt=Fmt.alt_default) ?(width=Fmt.width_default)
  (fmt_a:(a -> Fmt.Formatter e -> Fmt.Formatter e)) t (Formatter:Fmt.Formatter e)
  : (Fmt.Formatter e) =
    foldi ~init:
      (Formatter |> Fmt.fmt "[|")
      ~f:fn i Formatter elm ->
        Formatter
          |> (fn Formatter ->
            match alt with
            | false ->
                match i with
                | 0 -> Formatter
                | _ -> Formatter |> Fmt.fmt "; "
            | true -> Formatter |> Fmt.fmt "\n%*(^width + 4^)s(^""^)"
          )
          |> fmt_a elm
      |> (fn Formatter ->
        match alt with
        | false -> Formatter
        | true -> Formatter |> Fmt.fmt "\n%*(^width + 2^)s(^""^)"
      )
      |> Fmt.fmt "|]"

let pp pp_elm ppf t =
    let open Format
    fprintf ppf "@[<h>[|";
    iteri t ~f:(fn i elm ->
        if i > 0 then fprintf ppf ";@ "
        fprintf ppf "%a" pp_elm elm
      )
    fprintf ppf "|]@]"

(***************************************************************************************************
 * Begin tests.
 *)

let%expect_test "cursor" =
    let rec fn arr hd cursor tl =
        let index = Cursor.index cursor
        let hd_cursor = Cursor.cmp hd cursor
        let cursor_tl = Cursor.cmp cursor tl
        File.Fmt.Stdout
          |> Fmt.fmt
          "index=%u(^
            index
          ^), container %f(^
            Cmp.fmt (cmp Uns.cmp (Cursor.container cursor))
          ^) arr, hd %f(^\
            Cmp.fmt hd_cursor
          ^) cursor, cursor %f(^
            Cmp.fmt cursor_tl
          ^) tl, lget=%s(^
            match hd_cursor with
            | Lt -> "%u(^Cursor.lget cursor^)"
            | Eq -> "_"
            | Gt -> not_reached ()
          ^), rget=%s(^
            match cursor_tl with
            | Lt -> "%u(^Cursor.rget cursor^)"
            | Eq -> "_"
            | Gt -> not_reached ()
          ^)\n"
          |> ignore
        let length = length arr
        assert (Cursor.(=) (Cursor.seek (Uns.to_sint index) hd) cursor)
        assert (Cursor.(=) hd (Cursor.seek (-(Uns.to_sint index)) cursor))
        assert (Cursor.(=) (Cursor.seek (Uns.to_sint (length - index)) cursor) tl)
        assert (Cursor.(=) cursor (Cursor.seek (-(Uns.to_sint (length - index))) tl))

        match cursor_tl with
        | Lt ->
            let cursor' = Cursor.succ cursor
            assert Cursor.(cursor = (pred cursor'))
            fn arr hd cursor' tl
        | Eq | Gt -> ()
    let arrs = [
        [||]
        [|0|]
        [|0; 1|]
        [|0; 1; 2|]
      ]
    List.iter arrs ~f:(fn arr ->
        File.Fmt.Stdout |> Fmt.fmt "--- %f(^fmt Uns.fmt arr^) ---" |> ignore
        let hd = Cursor.hd arr
        fn arr hd hd (Cursor.tl arr)
      )
    let _ = File.Fmt.(flush Stdout)

    [%expect``
--- [||] ---
index=0, container Eq arr, hd Eq cursor, cursor Eq tl, lget=_, rget=_
--- [|0|] ---
index=0, container Eq arr, hd Eq cursor, cursor Lt tl, lget=_, rget=0
index=1, container Eq arr, hd Lt cursor, cursor Eq tl, lget=0, rget=_
--- [|0; 1|] ---
index=0, container Eq arr, hd Eq cursor, cursor Lt tl, lget=_, rget=0
index=1, container Eq arr, hd Lt cursor, cursor Lt tl, lget=0, rget=1
index=2, container Eq arr, hd Lt cursor, cursor Eq tl, lget=1, rget=_
--- [|0; 1; 2|] ---
index=0, container Eq arr, hd Eq cursor, cursor Lt tl, lget=_, rget=0
index=1, container Eq arr, hd Lt cursor, cursor Lt tl, lget=0, rget=1
index=2, container Eq arr, hd Lt cursor, cursor Lt tl, lget=1, rget=2
index=3, container Eq arr, hd Lt cursor, cursor Eq tl, lget=2, rget=_
``]

let%expect_test "hash_fold" =
    let open Format
    printf "@[<h>"
    let rec fn arrs =
        match arrs with
        | [] -> ()
        | arr :: arrs' ->
            printf "hash_fold %a -> %a\n" (pp Uns.pp) arr Hash.pp
              (Hash.t_of_state (hash_fold Uns.hash_fold arr Hash.State.empty))
            fn arrs'
    let arrs = [
        [||]
        [|0|]
        [|0; 0|]
        [|0; 1|]
      ]
    fn arrs
    printf "@]"

    [%expect`|hash_fold [||] -> 0x0000000000000000
             |hash_fold [|0|] -> 0x0000000007be548a
             |hash_fold [|0; 0|] -> 0x0000000012cbe18f
             |hash_fold [|0; 1|] -> 0x0000000005e8da31
            `]

let%expect_test "cmp" =
    let open Format
    let arrs = [
        [||]
        [|0|]
        [|0; 0|]
        [|0; 1|]
        [|0; 0|]
        [|0|]
        [||]
      ]
    let rec fn arr arrs =
        match arrs with
        | [] -> ()
        | hd :: tl ->
            let () = List.iter arrs ~f:(fn arr2 ->
                printf "cmp %a %a -> %a\n" (pp Uns.pp) arr (pp Uns.pp) arr2
                  Cmp.pp (cmp Uns.cmp arr arr2)
              )
            fn hd tl
    let hd, tl = match arrs with
        | hd :: tl -> hd, tl
        | [] -> not_reached ()
    printf "@[<h>"
    fn hd tl
    printf "@]"

    [%expect`|cmp [||] [|0|] -> Lt
             |cmp [||] [|0; 0|] -> Lt
             |cmp [||] [|0; 1|] -> Lt
             |cmp [||] [|0; 0|] -> Lt
             |cmp [||] [|0|] -> Lt
             |cmp [||] [||] -> Eq
             |cmp [|0|] [|0; 0|] -> Lt
             |cmp [|0|] [|0; 1|] -> Lt
             |cmp [|0|] [|0; 0|] -> Lt
             |cmp [|0|] [|0|] -> Eq
             |cmp [|0|] [||] -> Gt
             |cmp [|0; 0|] [|0; 1|] -> Lt
             |cmp [|0; 0|] [|0; 0|] -> Eq
             |cmp [|0; 0|] [|0|] -> Gt
             |cmp [|0; 0|] [||] -> Gt
             |cmp [|0; 1|] [|0; 0|] -> Gt
             |cmp [|0; 1|] [|0|] -> Gt
             |cmp [|0; 1|] [||] -> Gt
             |cmp [|0; 0|] [|0|] -> Gt
             |cmp [|0; 0|] [||] -> Gt
             |cmp [|0|] [||] -> Gt
            `]

let%expect_test "get,length,is_empty" =
    let open Format
    let test_length arr =
        printf "%a: length=%a, is_empty=%B\n" (pp Uns.pp) arr Uns.pp (length arr) (is_empty arr)
    printf "@[<h>"
    test_length [||]
    test_length [|0|]
    test_length [|0; 1|]
    test_length [|0; 1; 2|]
    printf "@]"

    [%expect`|[||]: length=0, is_empty=true
             |[|0|]: length=1, is_empty=false
             |[|0; 1|]: length=2, is_empty=false
             |[|0; 1; 2|]: length=3, is_empty=false
            `]

let%expect_test "set,set_inplace" =
    let open Format
    let test_set len =
        for i = 0 to pred len do
            let arr = init (0 .. len) ~f:(fn _ -> 0)
            let arr' = set i 1 arr
            printf "set %a: %a -> %a" Uns.pp i \
                                      (pp Uns.pp) arr \
                                      (pp Uns.pp) arr'
            set_inplace i 1 arr
            printf " -> set_inplace: %a" (pp Uns.pp) arr
            let arr'' = copy arr
            printf " -> copy,set_inplace: %a" (pp Uns.pp) arr''
            set_inplace i 2 arr''
            printf " -> %a\n" (pp Uns.pp) arr''
    printf "@[<h>"
    test_set 1
    test_set 2
    test_set 3
    printf "@]"

    [%expect{``
set 0: [|0|] -> [|1|] -> set_inplace: [|1|] -> copy,set_inplace: [|1|] -> [|2|]
set 0: [|0; 0|] -> [|1; 0|] -> set_inplace: [|1; 0|] -> copy,set_inplace: [|1; 0|] -> [|2; 0|]
set 1: [|0; 0|] -> [|0; 1|] -> set_inplace: [|0; 1|] -> copy,set_inplace: [|0; 1|] -> [|0; 2|]
set 0: [|0; 0; 0|] -> [|1; 0; 0|] -> set_inplace: [|1; 0; 0|] -> copy,set_inplace: [|1; 0; 0|] -> [|2; 0; 0|]
set 1: [|0; 0; 0|] -> [|0; 1; 0|] -> set_inplace: [|0; 1; 0|] -> copy,set_inplace: [|0; 1; 0|] -> [|0; 2; 0|]
set 2: [|0; 0; 0|] -> [|0; 0; 1|] -> set_inplace: [|0; 0; 1|] -> copy,set_inplace: [|0; 0; 1|] -> [|0; 0; 2|]
``]

let%expect_test "pare" =
    let open Format
    let test arr =
        printf "pare %a ->" (pp Uns.pp) arr
        for i = 0 to length arr do
            for j = i to length arr do
                let arr' = pare arr (i .. j)
                printf " [%a,%a)=%a" Uns.pp i Uns.pp j (pp Uns.pp) arr'
        printf "\n"
    printf "@[<h>"
    test [||]
    test [|0|]
    test [|0; 1|]
    test [|0; 1; 2|]
    printf "@]"

    [%expect`|pare [||] -> [0,0)=[||]
             |pare [|0|] -> [0,0)=[||] [0,1)=[|0|] [1,1)=[||]
             |pare [|0; 1|] -> [0,0)=[||] [0,1)=[|0|] [0,2)=[|0; 1|] [1,1)=[||] [1,2)=[|1|] [2,2)=[||]
             |pare [|0; 1; 2|] -> [0,0)=[||] [0,1)=[|0|] [0,2)=[|0; 1|] [0,3)=[|0; 1; 2|] [1,1)=[||] [1,2)=[|1|] [1,3)=[|1; 2|] [2,2)=[||] [2,3)=[|2|] [3,3)=[||]
            `]

let%expect_test "join" =
    let open Format
    let test ?sep arrs =
        printf "join"
        let () = match sep with
            | None -> ()
            | Some sep -> printf " ~sep:%a" (pp Uns.pp) sep
        printf " %a -> %a\n" (List.pp (pp Uns.pp)) arrs (pp Uns.pp) (join ?sep arrs)
    printf "@[<h>"
    test []
    test [[||]]
    test [[||]; [||]]
    test [[||]; [||]; [||]]

    test [[|0|]]

    test [[|0|]; [||]]
    test [[||]; [|0|]]
    test [[|0|]; [|1|]]

    test [[|0|]; [||]; [||]]
    test [[||]; [|0|]; [||]]
    test [[||]; [||]; [|0|]]
    test [[|0|]; [|1|]; [||]]
    test [[|0|]; [||]; [|1|]]
    test [[|0|]; [|1|]; [|2|]]

    test ~sep:[|3|] []
    test ~sep:[|3|] [[||]]
    test ~sep:[|3|] [[||]; [||]]
    test ~sep:[|3|] [[||]; [||]; [||]]

    test ~sep:[|3|] [[|0|]]

    test ~sep:[|3|] [[|0|]; [||]]
    test ~sep:[|3|] [[||]; [|0|]]
    test ~sep:[|3|] [[|0|]; [|1|]]

    test ~sep:[|3|] [[|0|]; [||]; [||]]
    test ~sep:[|3|] [[||]; [|0|]; [||]]
    test ~sep:[|3|] [[||]; [||]; [|0|]]
    test ~sep:[|3|] [[|0|]; [|1|]; [||]]
    test ~sep:[|3|] [[|0|]; [||]; [|1|]]
    test ~sep:[|3|] [[|0|]; [|1|]; [|2|]]
    printf "@]";

    [%expect`|join [] -> [||]
             |join [[||]] -> [||]
             |join [[||]; [||]] -> [||]
             |join [[||]; [||]; [||]] -> [||]
             |join [[|0|]] -> [|0|]
             |join [[|0|]; [||]] -> [|0|]
             |join [[||]; [|0|]] -> [|0|]
             |join [[|0|]; [|1|]] -> [|0; 1|]
             |join [[|0|]; [||]; [||]] -> [|0|]
             |join [[||]; [|0|]; [||]] -> [|0|]
             |join [[||]; [||]; [|0|]] -> [|0|]
             |join [[|0|]; [|1|]; [||]] -> [|0; 1|]
             |join [[|0|]; [||]; [|1|]] -> [|0; 1|]
             |join [[|0|]; [|1|]; [|2|]] -> [|0; 1; 2|]
             |join ~sep:[|3|] [] -> [||]
             |join ~sep:[|3|] [[||]] -> [||]
             |join ~sep:[|3|] [[||]; [||]] -> [|3|]
             |join ~sep:[|3|] [[||]; [||]; [||]] -> [|3; 3|]
             |join ~sep:[|3|] [[|0|]] -> [|0|]
             |join ~sep:[|3|] [[|0|]; [||]] -> [|0; 3|]
             |join ~sep:[|3|] [[||]; [|0|]] -> [|3; 0|]
             |join ~sep:[|3|] [[|0|]; [|1|]] -> [|0; 3; 1|]
             |join ~sep:[|3|] [[|0|]; [||]; [||]] -> [|0; 3; 3|]
             |join ~sep:[|3|] [[||]; [|0|]; [||]] -> [|3; 0; 3|]
             |join ~sep:[|3|] [[||]; [||]; [|0|]] -> [|3; 3; 0|]
             |join ~sep:[|3|] [[|0|]; [|1|]; [||]] -> [|0; 3; 1; 3|]
             |join ~sep:[|3|] [[|0|]; [||]; [|1|]] -> [|0; 3; 3; 1|]
             |join ~sep:[|3|] [[|0|]; [|1|]; [|2|]] -> [|0; 3; 1; 3; 2|]
            `]

let%expect_test "concat" =
    let open Format
    let test arr0 arr1 =
        printf "concat %a %a -> %a\n" (pp Uns.pp) arr0 (pp Uns.pp) arr1 (pp
          Uns.pp) (concat arr0 arr1)
    printf "@[<h>"
    test [||] [||]
    test [|0|] [||]
    test [||] [|0|]
    test [|0|] [|1|]
    test [|0; 1|] [|2|]
    test [|0|] [|1; 2|]
    test [|0; 1|] [|2; 3|]
    printf "@]"

    [%expect`|concat [||] [||] -> [||]
             |concat [|0|] [||] -> [|0|]
             |concat [||] [|0|] -> [|0|]
             |concat [|0|] [|1|] -> [|0; 1|]
             |concat [|0; 1|] [|2|] -> [|0; 1; 2|]
             |concat [|0|] [|1; 2|] -> [|0; 1; 2|]
             |concat [|0; 1|] [|2; 3|] -> [|0; 1; 2; 3|]
            `]

let%expect_test "append,prepend" =
    let open Format
    let test arr x =
        let arr_x = append x arr
        let x_arr = prepend x arr
        printf "%a %a: append -> %a, prepend -> %a\n" (pp Uns.pp) arr Uns.pp x
          (pp Uns.pp) arr_x (pp Uns.pp) x_arr
    printf "@[<h>"
    test [||] 0
    test [|0|] 1
    test [|0; 1|] 2
    test [|0; 1; 2|] 3
    printf "@]"

    [%expect`|[||] 0: append -> [|0|], prepend -> [|0|]
             |[|0|] 1: append -> [|0; 1|], prepend -> [|1; 0|]
             |[|0; 1|] 2: append -> [|0; 1; 2|], prepend -> [|2; 0; 1|]
             |[|0; 1; 2|] 3: append -> [|0; 1; 2; 3|], prepend -> [|3; 0; 1; 2|]
            `]

let%expect_test "insert" =
    let open Format
    let test arr x =
        printf "insert %a %a ->" (pp Uns.pp) arr Uns.pp x
        for i = 0 to length arr do
            let arr' = insert i x arr
            printf " %a" (pp Uns.pp) arr'
        printf "\n"
    printf "@[<h>"
    test [||] 0
    test [|0|] 1
    test [|0; 1|] 2
    test [|0; 1; 2|] 3
    printf "@]"

    [%expect`|insert [||] 0 -> [|0|]
             |insert [|0|] 1 -> [|1; 0|] [|0; 1|]
             |insert [|0; 1|] 2 -> [|2; 0; 1|] [|0; 2; 1|] [|0; 1; 2|]
             |insert [|0; 1; 2|] 3 -> [|3; 0; 1; 2|] [|0; 3; 1; 2|] [|0; 1; 3; 2|] [|0; 1; 2; 3|]
            `]

let%expect_test "remove" =
    let open Format
    let test arr =
        printf "remove %a ->" (pp Uns.pp) arr
        for i = 0 to pred (length arr) do
            let arr' = remove i arr
            printf " %a" (pp Uns.pp) arr'
        printf "\n"
    printf "@[<h>"
    test [|0|]
    test [|0; 1|]
    test [|0; 1; 2|]
    printf "@]"

    [%expect`|remove [|0|] -> [||]
             |remove [|0; 1|] -> [|1|] [|0|]
             |remove [|0; 1; 2|] -> [|1; 2|] [|0; 2|] [|0; 1|]
            `]

let%expect_test "reduce" =
    let open Format
    let test_reduce arr ~f =
        printf "reduce %a" (pp Uns.pp) arr
        match reduce arr ~f with
        | None -> printf " -> None\n"
        | Some x -> printf " -> %a\n" Uns.pp x
    let f a b = (a + b)
    printf "@[<h>"
    test_reduce [||] ~f
    test_reduce [|0; 1; 2; 3; 4|] ~f
    printf "@]"

    [%expect`|reduce [||] -> None
             |reduce [|0; 1; 2; 3; 4|] -> 10
            `]

let%expect_test "swap,swap_inplace" =
    let open Format
    let test_swap arr =
        for i = 0 to pred (length arr) do
            for j = i to pred (length arr) do
                let arr' = copy arr
                printf "%a %a: swap %a -> %a -> swap_inplace %a -> " Uns.pp i Uns.pp j
                  (pp Uns.pp) arr' (pp Uns.pp) (swap i j arr') (pp Uns.pp) arr'
                swap_inplace i j arr';
                printf "%a\n" (pp Uns.pp) arr'
    printf "@[<h>"
    test_swap [|0|]
    test_swap [|0; 1|]
    test_swap [|0; 1; 2|]
    test_swap [|0; 1; 2; 3|]
    printf "@]"

    [%expect``
0 0: swap [|0|] -> [|0|] -> swap_inplace [|0|] -> [|0|]
0 0: swap [|0; 1|] -> [|0; 1|] -> swap_inplace [|0; 1|] -> [|0; 1|]
0 1: swap [|0; 1|] -> [|1; 0|] -> swap_inplace [|0; 1|] -> [|1; 0|]
1 1: swap [|0; 1|] -> [|0; 1|] -> swap_inplace [|0; 1|] -> [|0; 1|]
0 0: swap [|0; 1; 2|] -> [|0; 1; 2|] -> swap_inplace [|0; 1; 2|] -> [|0; 1; 2|]
0 1: swap [|0; 1; 2|] -> [|1; 0; 2|] -> swap_inplace [|0; 1; 2|] -> [|1; 0; 2|]
0 2: swap [|0; 1; 2|] -> [|2; 1; 0|] -> swap_inplace [|0; 1; 2|] -> [|2; 1; 0|]
1 1: swap [|0; 1; 2|] -> [|0; 1; 2|] -> swap_inplace [|0; 1; 2|] -> [|0; 1; 2|]
1 2: swap [|0; 1; 2|] -> [|0; 2; 1|] -> swap_inplace [|0; 1; 2|] -> [|0; 2; 1|]
2 2: swap [|0; 1; 2|] -> [|0; 1; 2|] -> swap_inplace [|0; 1; 2|] -> [|0; 1; 2|]
0 0: swap [|0; 1; 2; 3|] -> [|0; 1; 2; 3|] -> swap_inplace [|0; 1; 2; 3|] -> [|0; 1; 2; 3|]
0 1: swap [|0; 1; 2; 3|] -> [|1; 0; 2; 3|] -> swap_inplace [|0; 1; 2; 3|] -> [|1; 0; 2; 3|]
0 2: swap [|0; 1; 2; 3|] -> [|2; 1; 0; 3|] -> swap_inplace [|0; 1; 2; 3|] -> [|2; 1; 0; 3|]
0 3: swap [|0; 1; 2; 3|] -> [|3; 1; 2; 0|] -> swap_inplace [|0; 1; 2; 3|] -> [|3; 1; 2; 0|]
1 1: swap [|0; 1; 2; 3|] -> [|0; 1; 2; 3|] -> swap_inplace [|0; 1; 2; 3|] -> [|0; 1; 2; 3|]
1 2: swap [|0; 1; 2; 3|] -> [|0; 2; 1; 3|] -> swap_inplace [|0; 1; 2; 3|] -> [|0; 2; 1; 3|]
1 3: swap [|0; 1; 2; 3|] -> [|0; 3; 2; 1|] -> swap_inplace [|0; 1; 2; 3|] -> [|0; 3; 2; 1|]
2 2: swap [|0; 1; 2; 3|] -> [|0; 1; 2; 3|] -> swap_inplace [|0; 1; 2; 3|] -> [|0; 1; 2; 3|]
2 3: swap [|0; 1; 2; 3|] -> [|0; 1; 3; 2|] -> swap_inplace [|0; 1; 2; 3|] -> [|0; 1; 3; 2|]
3 3: swap [|0; 1; 2; 3|] -> [|0; 1; 2; 3|] -> swap_inplace [|0; 1; 2; 3|] -> [|0; 1; 2; 3|]
``]

let%expect_test "rev,rev_inplace" =
    let open Format
    let test_rev arr =
        printf "rev %a -> %a -> rev_inplace %a -> " (pp Uns.pp) arr (pp Uns.pp)
          (rev arr) (pp Uns.pp) arr
        rev_inplace arr
        printf "%a\n" (pp Uns.pp) arr
    printf "@[<h>"
    test_rev [|0|]
    test_rev [|0; 1|]
    test_rev [|0; 1; 2|]
    test_rev [|0; 1; 2; 3|]
    printf "@]"

    [%expect`|rev [|0|] -> [|0|] -> rev_inplace [|0|] -> [|0|]
             |rev [|0; 1|] -> [|1; 0|] -> rev_inplace [|0; 1|] -> [|1; 0|]
             |rev [|0; 1; 2|] -> [|2; 1; 0|] -> rev_inplace [|0; 1; 2|] -> [|2; 1; 0|]
             |rev [|0; 1; 2; 3|] -> [|3; 2; 1; 0|] -> rev_inplace [|0; 1; 2; 3|] -> [|3; 2; 1; 0|]
            `]

let%expect_test "blit" =
    let open Format
    let range_pp ppf r =
        Format.fprintf ppf "(%u .. %u)" (Range.base r) (Range.past r)


    let test_blit r0 arr0 r1 arr1 =
        printf "blit %a %a %a %a -> " range_pp r0 (pp Uns.pp) arr0
          range_pp r1 (pp Uns.pp) arr1
        blit r0 arr0 r1 arr1
        printf "%a\n" (pp Uns.pp) arr1
    printf "@[<h>"
    test_blit (0 .. 0) [||] (0 .. 0) [||]
    test_blit (0 .. 1) [|0|] (0 .. 1) [|1|]
    test_blit (1 .. 2) [|0; 1|] (0 .. 1) [|2|]
    test_blit (0 .. 1) [|0|] (1 .. 2) [|1; 2|]
    test_blit (0 .. 2) [|0; 1|] (0 .. 2) [|2; 3|]
    test_blit (1 .. 3) [|0; 1; 2|] (0 .. 2) [|3; 4; 5|]
    test_blit (0 .. 3) [|0; 1; 2|] (0 .. 3) [|3; 4; 5|]
    printf "@]"

    [%expect`|blit (0 .. 0) [||] (0 .. 0) [||] -> [||]
             |blit (0 .. 1) [|0|] (0 .. 1) [|1|] -> [|0|]
             |blit (1 .. 2) [|0; 1|] (0 .. 1) [|2|] -> [|1|]
             |blit (0 .. 1) [|0|] (1 .. 2) [|1; 2|] -> [|1; 0|]
             |blit (0 .. 2) [|0; 1|] (0 .. 2) [|2; 3|] -> [|0; 1|]
             |blit (1 .. 3) [|0; 1; 2|] (0 .. 2) [|3; 4; 5|] -> [|1; 2; 5|]
             |blit (0 .. 3) [|0; 1; 2|] (0 .. 3) [|3; 4; 5|] -> [|0; 1; 2|]
            `]

let%expect_test "is_sorted" =
    let open Format
    let test_is_sorted arr =
        printf "is_sorted %a: not strict -> %B, strict -> %B\n" (pp Uns.pp) arr
          (is_sorted arr ~cmp:Uns.cmp) (is_sorted ~strict:true arr ~cmp:Uns.cmp)
    printf "@[<h>"
    test_is_sorted [||]
    test_is_sorted [|0|]
    test_is_sorted [|0; 0|]
    test_is_sorted [|0; 1|]
    test_is_sorted [|1; 0|]
    test_is_sorted [|0; 1; 1|]
    test_is_sorted [|0; 1; 2|]
    test_is_sorted [|0; 2; 1|]
    printf "@]"

    [%expect`|is_sorted [||]: not strict -> true, strict -> true
             |is_sorted [|0|]: not strict -> true, strict -> true
             |is_sorted [|0; 0|]: not strict -> true, strict -> false
             |is_sorted [|0; 1|]: not strict -> true, strict -> true
             |is_sorted [|1; 0|]: not strict -> false, strict -> false
             |is_sorted [|0; 1; 1|]: not strict -> true, strict -> false
             |is_sorted [|0; 1; 2|]: not strict -> true, strict -> true
             |is_sorted [|0; 2; 1|]: not strict -> false, strict -> false
            `]

type sort_elm =
    key: uns (* Random, possibly non-unique. *)
    sn: uns (* Sequential in initial array. *)
let%expect_test "sort" =
    let gen_array len =
        let key_limit =
            if len > 0 then len
            else 1
        init (0 .. len) ~f:(fn i -> {key=Random.int key_limit; sn=i})
    let cmp elm0 elm1 =
        Uns.cmp elm0.key elm1.key
    let test_sort arr =
        let arr' = sort arr ~cmp
        assert (is_sorted arr' ~cmp)

        let arr' = sort ~stable:true arr ~cmp
        assert (is_sorted ~strict:true arr' ~cmp:(fn elm0 elm1 ->
            match cmp elm0 elm1 with
            | Cmp.Lt -> Cmp.Lt
            | Cmp.Eq -> Uns.cmp elm0.sn elm1.sn
            | Cmp.Gt -> Cmp.Gt
          ))
    Random.init 0;
    for len = 0 to 257 do
        for _ = 1 to 10 do
            test_sort (gen_array len)

    [%expect""]

let%expect_test "search" =
    let open Format
    let test_search arr key_max =
        printf "%a\n" (pp Uns.pp) arr
        for probe = 0 to key_max do
            printf "    %a -> %s, %s, %s\n" Uns.pp probe
              (match psearch probe ~cmp:Uns.cmp arr with
                | None -> "<"
                | Some (Cmp.Lt, i) -> asprintf "<[%a]=%a"
                  Uns.pp i Uns.pp (get i arr)
                | Some (Cmp.Eq, i) -> asprintf "=[%a]=%a"
                  Uns.pp i Uns.pp (get i arr)
                | Some (Cmp.Gt, i) -> asprintf ">[%a]=%a"
                  Uns.pp i Uns.pp (get i arr)
              ) (match search probe ~cmp:Uns.cmp arr with
                | None -> "<>"
                | Some i -> asprintf "=%a" Uns.pp (get i arr)
              ) (match nsearch probe ~cmp:Uns.cmp arr with
                | Some (Cmp.Lt, i) -> asprintf "<[%a]=%a"
                  Uns.pp i Uns.pp (get i arr)
                | Some (Cmp.Eq, i) -> asprintf "=[%a]=%a"
                  Uns.pp i Uns.pp (get i arr)
                | Some (Cmp.Gt, i) -> asprintf ">[%a]=%a"
                  Uns.pp i Uns.pp (get i arr)
                | None -> ">"
              )
    printf "@[<h>"
    for len = 0 to 3 do
        let arr = init (0 .. len) ~f:(fn i -> i * 2 + 1)
        let key_max = len * 2
        test_search arr key_max
    for hlen = 1 to 3 do
        let len = hlen * 2
        let arr = init (0 .. len) ~f:(fn i -> i + ((i + 1) % 2))
        let key_max = len
        test_search arr key_max
    printf "@]"

    [%expect`|[||]
             |    0 -> <, <>, >
             |[|1|]
             |    0 -> <[0]=1, <>, <[0]=1
             |    1 -> =[0]=1, =1, =[0]=1
             |    2 -> >[0]=1, <>, >[0]=1
             |[|1; 3|]
             |    0 -> <[0]=1, <>, <[0]=1
             |    1 -> =[0]=1, =1, =[0]=1
             |    2 -> >[0]=1, <>, <[1]=3
             |    3 -> =[1]=3, =3, =[1]=3
             |    4 -> >[1]=3, <>, >[1]=3
             |[|1; 3; 5|]
             |    0 -> <[0]=1, <>, <[0]=1
             |    1 -> =[0]=1, =1, =[0]=1
             |    2 -> >[0]=1, <>, <[1]=3
             |    3 -> =[1]=3, =3, =[1]=3
             |    4 -> >[1]=3, <>, <[2]=5
             |    5 -> =[2]=5, =5, =[2]=5
             |    6 -> >[2]=5, <>, >[2]=5
             |[|1; 1|]
             |    0 -> <[0]=1, <>, <[0]=1
             |    1 -> =[0]=1, =1, =[1]=1
             |    2 -> >[1]=1, <>, >[1]=1
             |[|1; 1; 3; 3|]
             |    0 -> <[0]=1, <>, <[0]=1
             |    1 -> =[0]=1, =1, =[1]=1
             |    2 -> >[1]=1, <>, <[2]=3
             |    3 -> =[2]=3, =3, =[3]=3
             |    4 -> >[3]=3, <>, >[3]=3
             |[|1; 1; 3; 3; 5; 5|]
             |    0 -> <[0]=1, <>, <[0]=1
             |    1 -> =[0]=1, =1, =[1]=1
             |    2 -> >[1]=1, <>, <[2]=3
             |    3 -> =[2]=3, =3, =[3]=3
             |    4 -> >[3]=3, <>, <[4]=5
             |    5 -> =[4]=5, =5, =[5]=5
             |    6 -> >[5]=5, <>, >[5]=5
            `]

let%expect_test "map,mapi" =
    let open Format
    let pp_str ppf t = Format.fprintf ppf "%S" t
    let test_map uarr =
        printf "%a -> map " (pp Uns.pp) uarr
        let sarr = map uarr ~f:(fn elm -> asprintf "%a" Uns.pp elm)
        printf "%a" (pp pp_str) sarr
        printf " -> mapi "
        let sarr = mapi uarr ~f:(fn i elm ->
            asprintf "[%a]=%a" Uns.pp i Uns.pp elm
          )
        printf "%a\n" (pp pp_str) sarr
    printf "@[<h>"
    test_map [||]
    test_map [|0|]
    test_map [|1; 0|]
    test_map [|2; 1; 0|]
    printf "@]"

    [%expect`|[||] -> map [||] -> mapi [||]
             |[|0|] -> map [|"0"|] -> mapi [|"[0]=0"|]
             |[|1; 0|] -> map [|"1"; "0"|] -> mapi [|"[0]=1"; "[1]=0"|]
             |[|2; 1; 0|] -> map [|"2"; "1"; "0"|] -> mapi [|"[0]=2"; "[1]=1"; "[2]=0"|]
            `]

let%expect_test "fold_map,foldi_map" =
    let open Format
    let pp_str ppf t = Format.fprintf ppf "%S" t
    let test_fold_map uarr =
        let accum, sarr = fold_map uarr ~init:0 ~f:(fn accum elm ->
            (accum + elm), (asprintf "%a" Uns.pp elm)
          )
        let accum2, sarr2 = foldi_map uarr ~init:0 ~f:(fn i accum elm ->
            (accum + i + elm),
            (asprintf "[%a]=%a" Uns.pp i Uns.pp elm)
          )
        printf "%a -> fold_map %a %a -> foldi_map %a %a\n"
          (pp Uns.pp) uarr
          Uns.pp accum
          (pp pp_str) sarr
          Uns.pp accum2
          (pp pp_str) sarr2
    printf "@[<h>"
    test_fold_map [||]
    test_fold_map [|0|]
    test_fold_map [|1; 0|]
    test_fold_map [|2; 1; 0|]
    printf "@]"

    [%expect`|[||] -> fold_map 0 [||] -> foldi_map 0 [||]
             |[|0|] -> fold_map 0 [|"0"|] -> foldi_map 0 [|"[0]=0"|]
             |[|1; 0|] -> fold_map 1 [|"1"; "0"|] -> foldi_map 2 [|"[0]=1"; "[1]=0"|]
             |[|2; 1; 0|] -> fold_map 3 [|"2"; "1"; "0"|] -> foldi_map 6 [|"[0]=2"; "[1]=1"; "[2]=0"|]
            `]

let%expect_test "filter,filteri" =
    let open Format
    let test_filter arr =
        let farr = filter arr ~f:(fn elm -> elm % 2 = 0)
        let farr2 = filteri arr ~f:(fn _ elm -> elm % 2 = 0)
        let farr3 = filteri arr ~f:(fn i _ -> i % 2 = 0)
        printf "%a -> filter %a -> filteri %a %a\n"
          (pp Uns.pp) arr
          (pp Uns.pp) farr
          (pp Uns.pp) farr2
          (pp Uns.pp) farr3
    printf "@[<h>"
    test_filter [||]
    test_filter [|0|]
    test_filter [|1; 0|]
    test_filter [|2; 1; 0|]
    test_filter [|3; 2; 1; 0|]
    printf "@]"

    [%expect`|[||] -> filter [||] -> filteri [||] [||]
             |[|0|] -> filter [|0|] -> filteri [|0|] [|0|]
             |[|1; 0|] -> filter [|0|] -> filteri [|0|] [|1|]
             |[|2; 1; 0|] -> filter [|2; 0|] -> filteri [|2; 0|] [|2; 0|]
             |[|3; 2; 1; 0|] -> filter [|2; 0|] -> filteri [|2; 0|] [|3; 1|]
            `]

let%expect_test "fold2_until,foldi2_until" =
    let open Format
    let test_fold2_until uarr0 uarr1 =
        printf "%a %a"
          (pp Uns.pp) uarr0
          (pp Uns.pp) uarr1
        let accum = fold2_until uarr0 uarr1 ~init:0
          ~f:(fn accum elm0 elm1 ->
            (accum + elm0 + elm1), (accum > 10)
          )
        printf " -> fold2_until %a" Uns.pp accum
        let accum = foldi2_until uarr0 uarr1 ~init:0
          ~f:(fn i accum elm0 elm1 ->
            (accum + i + elm0 + elm1), ((i + 2) >= (length uarr0))
          )
        printf " -> foldi2_until %a\n" Uns.pp accum
    printf "@[<h>"
    test_fold2_until [||] [||]
    test_fold2_until [|1|] [|0|]
    test_fold2_until [|3; 2|] [|1; 0|]
    test_fold2_until [|5; 4; 3|] [|2; 1; 0|]
    printf "@]"

    [%expect`|[||] [||] -> fold2_until 0 -> foldi2_until 0
             |[|1|] [|0|] -> fold2_until 1 -> foldi2_until 1
             |[|3; 2|] [|1; 0|] -> fold2_until 6 -> foldi2_until 4
             |[|5; 4; 3|] [|2; 1; 0|] -> fold2_until 15 -> foldi2_until 13
            `]

let%expect_test "fold2,foldi2" =
    let open Format
    let test_fold2 uarr0 uarr1 =
        printf "%a %a"
          (pp Uns.pp) uarr0
          (pp Uns.pp) uarr1
        let accum = fold2 uarr0 uarr1 ~init:0 ~f:(fn accum elm0 elm1 ->
            accum + elm0 + elm1
          )
        printf " -> fold2 %a" Uns.pp accum
        let accum = foldi2 uarr0 uarr1 ~init:0
          ~f:(fn i accum elm0 elm1 -> accum + i + elm0 + elm1)
        printf " -> foldi2 %a\n" Uns.pp accum
    printf "@[<h>"
    test_fold2 [||] [||]
    test_fold2 [|1|] [|0|]
    test_fold2 [|3; 2|] [|1; 0|]
    test_fold2 [|5; 4; 3|] [|2; 1; 0|]
    printf "@]"

    [%expect`|[||] [||] -> fold2 0 -> foldi2 0
             |[|1|] [|0|] -> fold2 1 -> foldi2 1
             |[|3; 2|] [|1; 0|] -> fold2 6 -> foldi2 7
             |[|5; 4; 3|] [|2; 1; 0|] -> fold2 15 -> foldi2 18
            `]

let%expect_test "iteri2" =
    let open Format
    let print_uns_arrays arr0 arr1 =
        printf "[|"
        iteri2 arr0 arr1 ~f:(fn i elm0 elm1 ->
            if i > 0 then printf "; "
            printf "(%a, %a)" Uns.pp elm0 Uns.pp elm1
          )
        printf "|]"
    let test_iter2 arr0 arr1 =
        print_uns_arrays arr0 arr1
        printf "\n"
    test_iter2 [||] [||]
    test_iter2 [|0|] [|1|]
    test_iter2 [|0; 1|] [|2; 3|]
    test_iter2 [|0; 1; 2|] [|3; 4; 5|]

    [%expect`|[||]
             |[|(0, 1)|]
             |[|(0, 2); (1, 3)|]
             |[|(0, 3); (1, 4); (2, 5)|]
            `]

let%expect_test "map2,mapi2" =
    let open Format
    let pp_str ppf t = Format.fprintf ppf "%S" t
    let test_map2 uarr0 uarr1 =
        let sarr = map2 uarr0 uarr1 ~f:(fn elm0 elm1 ->
            asprintf "(%a,%a)" Uns.pp elm0 Uns.pp elm1
          )
        let sarr2 = mapi2 uarr0 uarr1 ~f:(fn i elm0 elm1 ->
            asprintf "[%a]=(%a,%a)" Uns.pp i Uns.pp elm0 Uns.pp elm1
          )
        printf "%a %a -> map2 %a -> mapi2 %a\n"
          (pp Uns.pp) uarr0
          (pp Uns.pp) uarr1
          (pp pp_str) sarr
          (pp pp_str) sarr2
    printf "@[<h>"
    test_map2 [||] [||]
    test_map2 [|1|] [|0|]
    test_map2 [|3; 2|] [|1; 0|]
    test_map2 [|5; 4; 3|] [|2; 1; 0|]
    printf "@]"

    [%expect`|[||] [||] -> map2 [||] -> mapi2 [||]
             |[|1|] [|0|] -> map2 [|"(1,0)"|] -> mapi2 [|"[0]=(1,0)"|]
             |[|3; 2|] [|1; 0|] -> map2 [|"(3,1)"; "(2,0)"|] -> mapi2 [|"[0]=(3,1)"; "[1]=(2,0)"|]
             |[|5; 4; 3|] [|2; 1; 0|] -> map2 [|"(5,2)"; "(4,1)"; "(3,0)"|] -> mapi2 [|"[0]=(5,2)"; "[1]=(4,1)"; "[2]=(3,0)"|]
            `]

let%expect_test "fold2_map,foldi2_map" =
    let open Format
    let pp_str ppf t = Format.fprintf ppf "%S" t
    let test_fold2_map uarr0 uarr1 =
        let accum, sarr = fold2_map uarr0 uarr1 ~init:0
          ~f:(fn accum elm0 elm1 ->
            (accum + elm0 + elm1),
            (asprintf "(%a,%a)" Uns.pp elm0 Uns.pp elm1)
          )
        let accum2, sarr2 = foldi2_map uarr0 uarr1 ~init:0
          ~f:(fn i accum elm0 elm1 ->
            (accum + i + elm0 + elm1),
            (asprintf "[%a]=(%a,%a)" Uns.pp i Uns.pp elm0 Uns.pp elm1)
          )
        printf "%a %a -> fold2_map %a %a -> foldi2_map %a %a\n"
          (pp Uns.pp) uarr0
          (pp Uns.pp) uarr1
          Uns.pp accum
          (pp pp_str) sarr
          Uns.pp accum2
          (pp pp_str) sarr2
    printf "@[<h>"
    test_fold2_map [||] [||]
    test_fold2_map [|1|] [|0|]
    test_fold2_map [|3; 2|] [|1; 0|]
    test_fold2_map [|5; 4; 3|] [|2; 1; 0|]
    printf "@]"

    [%expect
      `|[||] [||] -> fold2_map 0 [||] -> foldi2_map 0 [||]
       |[|1|] [|0|] -> fold2_map 1 [|"(1,0)"|] -> foldi2_map 1 [|"[0]=(1,0)"|]
       |[|3; 2|] [|1; 0|] -> fold2_map 6 [|"(3,1)"; "(2,0)"|] -> foldi2_map 7 [|"[0]=(3,1)"; "[1]=(2,0)"|]
       |[|5; 4; 3|] [|2; 1; 0|] -> fold2_map 15 [|"(5,2)"; "(4,1)"; "(3,0)"|] -> foldi2_map 18 [|"[0]=(5,2)"; "[1]=(4,1)"; "[2]=(3,0)"|]
      `]

let%expect_test "zip,unzip" =
    let open Format
    let test_zip arr0 arr1 =
        let arr0', arr1' = unzip (zip arr0 arr1)
        printf "%a %a\n"
          (pp Uns.pp) arr0'
          (pp Uns.pp) arr1'
    printf "@[<h>"
    test_zip [||] [||]
    test_zip [|0|] [|1|]
    test_zip [|0; 1|] [|2; 3|]
    test_zip [|0; 1; 2|] [|3; 4; 5|]
    printf "@]"

    [%expect`|[||] [||]
             |[|0|] [|1|]
             |[|0; 1|] [|2; 3|]
             |[|0; 1; 2|] [|3; 4; 5|]
            `]

open! Basis.Rudiments
open! Basis
open! Hmc

let scan_str s =
  let rec fn t toks = begin
    let t', tok = Scan.next t in
    match tok with
    | Tok_end_of_input _ -> List.rev toks
    | _ -> fn t' (tok :: toks)
  end in
  let t = Scan.init (Text.of_string_slice (String.C.Slice.of_string s)) in
  fn t []

let contextualize source first last =
  let toks = scan_str source in
  let first_tok = List.nth first toks in
  let last_tok = List.nth last toks in
  let lookahead_tok_opt = (
    let rec f last lookahead tail =
      match tail with
      | [] -> lookahead
      | tok :: tail' -> begin
          let last_line = Text.Pos.line (Source.Cursor.pos (Source.Cursor.unbias (Source.Slice.past
              (Scan.Token.source last)))) in
          let tok_line = Text.Pos.line (Source.Cursor.pos (Source.Cursor.unbias
              (Source.Slice.base (Scan.Token.source tok)))) in
          match last_line < tok_line with
          | true -> Some tok
          | false -> f last (Some tok) tail'
        end
    in
    let tail = List.drop (succ last) toks in
    f last_tok None tail
  ) in
  let lookahead = match lookahead_tok_opt with
    | None -> None
    | Some tok -> Some (Source.Slice.past (Scan.Token.source tok))
  in
  let source_slice = Source.Slice.of_cursors
      ~base:(Source.Slice.base (Scan.Token.source first_tok))
      ~past:(Source.Slice.past (Scan.Token.source last_tok)) in
  let context_lookahead = Source.Slice.line_context ?lookahead source_slice in
  let context_no_lookahead = Source.Slice.line_context source_slice in
  let pp_i_tok (i, tok) formatter = begin
    formatter
    |> Fmt.fmt "("
    |> Uns.pp i
    |> Fmt.fmt ", "
    |> Scan.Token.pp tok
    |> Fmt.fmt ")"
  end in
  File.Fmt.stdout
  |> Fmt.fmt "---\nsource=" |> String.fmt ~alt:true ~pretty:true source
  |> Fmt.fmt "\nfirst=" |> Scan.Token.pp (List.nth first toks)
  |> Fmt.fmt "\nlast=" |> Scan.Token.pp (List.nth last toks)
  |> Fmt.fmt "\nlookahead=" |> (Option.pp Source.Cursor.pp) lookahead
  |> Fmt.fmt "\ntoks="
  |> (List.fmt ~alt:true pp_i_tok) (List.mapi toks ~f:(fun i tok -> (i, tok)))
  |> Fmt.fmt "\ncontext_lookahead="
  |> (List.fmt ~alt:true (fun slice formatter ->
    formatter
    |> Source.Slice.pp slice
    |> Fmt.fmt ": "
    |> String.pp (Source.Slice.to_string slice)
  )) context_lookahead
  |> Fmt.fmt "\ncontext_no_lookahead="
  |> (List.fmt ~alt:true (fun slice formatter ->
    formatter
    |> Source.Slice.pp slice
    |> Fmt.fmt ": "
    |> String.pp (Source.Slice.to_string slice)
  )) context_no_lookahead
  |> Fmt.fmt "\n"
  |> ignore

let test () =
  contextualize {|x = 42|} 0L 0L;
  contextualize {|x = 42|} 1L 1L;
  contextualize {|x = 42|} 1L 2L;
  contextualize {|x = 42|} 4L 4L;
  contextualize {|[:"Foo.hm"]x = 42|} 1L 1L;
  contextualize {|[:"Foo.hm"]
x =
    42|} 3L 3L;
  contextualize {|[:"Foo.hm"]
x =
    42|} 3L 6L;
  contextualize {|[:"Foo.hm"]
x =[:"Bar.hm"]
    42 + 13|} 3L 10L;

  contextualize {|# This file was generated by `hocc`; edit "Example.hmhi" rather than "Example.hmi".
[:"Example.hmhi":1]open import Basis

include [:]{
    # Example grammar module signature.
    Spec = {
        # [...]
      }
    Token = {
        # [...]
      }
    # Etc.
  }[:"Example.hmhi":3:0+12]

calculate: string -> zint|} 55L 56L;
  contextualize {|[:"Tesseract.hmp":1]open Basis

square [@inline] = (fn x =
    x * x
  )

tesseract x =
    ([:"Tesseract.hmp":3:0+19](fn x =
    x * x
  )[:"Tesseract.hmp":8:4+7] ([:"Tesseract.hmp":3:0+19](fn x =
    x * x
  )[:"Tesseract.hmp":8:4+15] x))|} 10L 11L

let _ = test ()

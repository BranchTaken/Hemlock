# This file was generated by `hocc` based on "Example_c.hmh"
[:"./Example_c.hmh":1]open import Basis

Parser = {
    # Better written as `Parser = hocc`, but this is an indentation test.
    include [:]{
        Spec = {
            Algorithm = {
                T = {
                    type t: t =
                      | Lr1
                      | Ielr1
                      | Pgm1
                      | Lalr1

                    index t = match t with
                      | Lr1 -> 0
                      | Ielr1 -> 1
                      | Pgm1 -> 2
                      | Lalr1 -> 3

                    hash_fold t state =
                        state |> Uns.hash_fold (index t)

                    cmp t0 t1 =
                        Uns.cmp (index t0) (index t1)

                    to_string t = match t with
                      | Lr1 -> "Lr1"
                      | Ielr1 -> "Ielr1"
                      | Pgm1 -> "Pgm1"
                      | Lalr1 -> "Lalr1"

                    pp t formatter =
                        formatter |> Fmt.fmt (to_string t)
                  }
                include T
                include Identifiable.Make(T)
              }

            algorithm = Algorithm.Lr1

            Assoc = {
                T = {
                    type t: t =
                      | Left
                      | Right
                      | Nonassoc

                    index t = match t with
                      | Left -> 0
                      | Right -> 1
                      | Nonassoc -> 2

                    hash_fold t state =
                        state |> Uns.hash_fold (index t)

                    cmp t0 t1 =
                        Uns.cmp (index t0) (index t1)

                    to_string t = match t with
                      | Left -> "Left"
                      | Right -> "Right"
                      | Nonassoc -> "Nonassoc"

                    pp t formatter =
                        formatter |> Fmt.fmt (to_string t)
                  }
                include T
                include Identifiable.Make(T)
              }

            PrecSet = {
                T = {
                    type t: t = {
                        index: uns
                        names: array string
                        assoc: option Assoc.t
                        doms: Bitset.t
                      }

                    index {index; _} =
                        index

                    hash_fold t state =
                        state |> Uns.hash_fold (index t)

                    cmp t0 t1 =
                        Uns.cmp (index t0) (index t1)

                    pp {index; names; assoc; doms} formatter =
                        formatter
                          |> Fmt.fmt
                          "{%u=(^index
                          ^); %f(^Array.pp String.pp^)=(^names
                          ^); %f(^Option.pp Assoc.pp^)=(^assoc
                          ^); %f(^Bitset.pp^)=(^doms
                          ^)}"
                  }
                include T
                include Identifiable.Make(T)

                init ~index ~names ~assoc ~doms =
                    {index; names; assoc; doms}
              }

            prec_sets = [|
                PrecSet.init ~index:0 ~names:[|"mul"|] ~assoc:(Some Left) ~doms:(Bitset.empty)
                PrecSet.init ~index:1 ~names:[|"add"|] ~assoc:(Some Left) ~doms:(Bitset.singleton 0)
              |]

            Prec = {
                T = {
                    type t: t = {
                        name_index: uns
                        prec_set_index: uns
                      }

                    index {prec_set_index; _} =
                        prec_set_index

                    hash_fold t state =
                        state |> Uns.hash_fold (index t)

                    cmp t0 t1 =
                        Uns.cmp (index t0) (index t1)

                    pp {name_index; prec_set_index} =
                        formatter
                          |> Fmt.fmt
                          "{%u=(^name_index
                          ^); %u=(^prec_set_index
                          ^)}"
                  }
                include T
                include Identifiable.Make(T)

                init ~name_index ~prec_set_index =
                    {name_index; prec_set_index}
              }

            Prod = {
                T = {
                    type t: t = {
                        index: uns
                        lhs_index: uns
                        rhs_indexes: array uns
                        prec: option Prec.t
                        callback: uns
                      }

                    hash_fold {index; _} state =
                        Uns.hash_fold index state

                    cmp {index=i0; _} {index=i1; _} =
                        Uns.cmp i0 i1

                    pp {index; lhs_index; rhs_indexes; prec; callback} formatter =
                        formatter
                          |> Fmt.fmt
                          "{%u=(^index
                          ^); %u=(^lhs_index
                          ^); %f(^Array.pp Uns.pp^)=(^rhs_indexes
                          ^); %f(^Option.pp Prec.pp^)=(^prec
                          ^); %u=(^callback
                          ^)}"
                  }
                include T
                include Identifiable.Make(T)

                init ~index ~lhs_index ~rhs_indexes ~prec ~callback =
                    {index; lhs_index; rhs_indexes; prec; callback}
              }

            prods = [|
                Prod.init ~index:0 ~lhs_index:8 ~rhs_indexes:[|2|]
                  ~prec:None ~callback:0
                Prod.init ~index:1 ~lhs_index:8 ~rhs_indexes:[|3|]
                  ~prec:None ~callback:1
                Prod.init ~index:2 ~lhs_index:9 ~rhs_indexes:[|4|]
                  ~prec:None ~callback:2
                Prod.init ~index:3 ~lhs_index:9 ~rhs_indexes:[|5|]
                  ~prec:None ~callback:3
                Prod.init ~index:4 ~lhs_index:10 ~rhs_indexes:[|10; 8; 10|]
                  ~prec:(Some (Prec.init ~name_index:0 ~prec_set_index:0)) ~callback:4
                Prod.init ~index:5 ~lhs_index:10 ~rhs_indexes:[|10; 9; 10|]
                  ~prec:(Some (Prec.init ~name_index:0 ~prec_set_index:1)) ~callback:5
                Prod.init ~index:6 ~lhs_index:10 ~rhs_indexes:[|6|]
                  ~prec:None ~callback:6
                Prod.init ~index:7 ~lhs_index:11 ~rhs_indexes:[|10; 7|]
                  ~prec:None ~callback:7
                Prod.init ~index:8 ~lhs_index:12 ~rhs_indexes:[|11; 1|]
                  ~prec:None ~callback:8
              |]

            Symbol = {
                T = {
                    type t: t = {
                        index: uns
                        name: string
                        prec: option Prec.t
                        alias: option string
                        start: bool
                        prods: Ordset.t Prod.t Prod.cmper_witness
                        first: Bitset.t
                        follow: Bitset.t
                      }

                    hash_fold {index; _} state =
                        Uns.hash_fold index state

                    cmp {index=i0; _} {index=i1; _} =
                        Uns.cmp i0 i1

                    pp {index; name; prec; alias; start; prods; first; follow} formatter =
                        formatter
                          |> Fmt.fmt
                          "{%u=(^index
                          ^); %s=(^name
                          ^); %f(^Option.pp Prec.pp^)=(^prec
                          ^); %f(^Option.pp String.pp^)=(^alias
                          ^); %b=(^start
                          ^); %f(^Ordset.pp^)=(^prods
                          ^); %f(^Bitset.pp^)=(^first
                          ^); %f(^Bitset.pp^)=(^follow
                          ^)}"
                  }
                include T
                include Identifiable.Make(T)

                init ~index ~name ~prec ~alias ~start ~prods ~first ~follow =
                    {index; name; prec; alias; start; prods; first; follow}

                let is_nonterm {prods; _} =
                    not (Ordset.is_empty prods)
              }

            symbols = [|
                Symbol.init ~index:0 ~name:"EPSILON"
                  ~prec:None ~alias:(Some "ε") ~start:false
                  ~prods:(Ordset.empty Prod)
                  ~first:(Bitset.singleton 0)
                  ~follow:Bitset.empty
                Symbol.init ~index:1 ~name:"PSEUDO_END"
                  ~prec:None ~alias:(Some "⊥") ~start:false
                  ~prods:(Ordset.empty Prod)
                  ~first:(Bitset.singleton 1)
                  ~follow:(Bitset.singleton 0)
                Symbol.init ~index:2 ~name:"STAR"
                  ~prec:(Some (Prec.init ~name_index:0 ~prec_set_index:0))
                  ~alias:(Some "*") ~start:false
                  ~prods:(Ordset.empty Prod)
                  ~first:(Bitset.singleton 2)
                  ~follow:(Bitset.singleton 6)
                Symbol.init ~index:3 ~name:"SLASH"
                  ~prec:(Some (Prec.init ~name_index:0 ~prec_set_index:0))
                  ~alias:(Some "/") ~start:false
                  ~prods:(Ordset.empty Prod)
                  ~first:(Bitset.singleton 3)
                  ~follow:(Bitset.singleton 6)
                Symbol.init ~index:4 ~name:"PLUS"
                  ~prec:(Some (Prec.init ~name_index:0 ~prec_set_index:1))
                  ~alias:(Some "+") ~start:false
                  ~prods:(Ordset.empty Prod)
                  ~first:(Bitset.singleton 4)
                  ~follow:(Bitset.singleton 6)
                Symbol.init ~index:5 ~name:"MINUS"
                  ~prec:(Some (Prec.init ~name_index:0 ~prec_set_index:1))
                  ~alias:(Some "-") ~start:false
                  ~prods:(Ordset.empty Prod)
                  ~first:(Bitset.singleton 5)
                  ~follow:(Bitset.singleton 6)
                Symbol.init ~index:6 ~name:"INT"
                  ~prec:None ~alias:None ~start:false
                  ~prods:(Ordset.empty Prod)
                  ~first:(Bitset.singleton 6)
                  ~follow:(Bitset.of_nat 0xbcn)
                Symbol.init ~index:7 ~name:"EOI"
                  ~prec:None ~alias:None ~start:false
                  ~prods:(Ordset.empty Prod)
                  ~first:(Bitset.singleton 7)
                  ~follow:(Bitset.singleton 1)
                Symbol.init ~index:8 ~name:"MulOp"
                  ~prec:None ~alias:None ~start:false
                  ~prods:(Ordset.of_list Prod [
                    Array.get 0 prods
                    Array.get 1 prods
                  ])
                  ~first:(Bitset.of_nat 0xcn)
                  ~follow:(Bitset.singleton 6)
                Symbol.init ~index:9 ~name:"AddOp"
                  ~prec:None ~alias:None ~start:false
                  ~prods:(Ordset.of_list Prod [
                    Array.get 2 prods
                    Array.get 3 prods
                  ])
                  ~first:(Bitset.of_nat 0x30n)
                  ~follow:(Bitset.singleton 6)
                Symbol.init ~index:10 ~name:"Expr"
                  ~prec:None ~alias:None ~start:false
                  ~prods:(Ordset.of_list Prod [
                    Array.get 4 prods
                    Array.get 5 prods
                    Array.get 6 prods
                  ])
                  ~first:(Bitset.singleton 6)
                  ~follow:(Bitset.of_nat 0xbcn)
                Symbol.init ~index:11 ~name:"Answer"
                  ~prec:None ~alias:None ~start:true
                  ~prods:(Ordset.singleton Prod (Array.get 7 prods))
                  ~first:(Bitset.singleton 6)
                  ~follow:(Bitset.singleton 1)
                Symbol.init ~index:12 ~name:"Answer'"
                  ~prec:None ~alias:None ~start:true
                  ~prods:(Ordset.singleton Prod (Array.get 8 prods))
                  ~first:(Bitset.singleton 6)
                  ~follow:(Bitset.singleton 0)
              |]

            Lr0Item = {
                T = {
                    type t: t = {
                        prod: Prod.t
                        dot: uns
                      }

                    hash_fold {prod; dot} state =
                        state
                          |> Prod.hash_fold prod
                          |> Uns.hash_fold dot

                    cmp {prod=p0; dot=d0} {prod=p1; dot=d1} =
                        let open Cmp
                        match Prod.cmp p0 p1 with
                          | Lt -> Lt
                          | Eq -> Uns.cmp d0 d1
                          | Gt -> Gt

                    pp {prod; dot} formatter =
                        formatter |> Fmt.fmt "{%f(^Prod.pp^)=(^prod^); %u=(^dot^)}"
                  }
                include T
                include Identifiable.Make(T)

                init ~prod ~dot =
                    {prod; dot}
              }

            Lr1Item = {
                T = {
                    type t: t = {
                        lr0item: Lr0Item.t
                        follow: Bitset.t
                      }

                    hash_fold {lr0item; follow} state =
                        state
                          |> Lr0Item.hash_fold lr0item
                          |> Bitset.hash_fold follow

                    cmp {lr0item=l0; follow=f0} {lr0item=l1; follow=f1} =
                        let open Cmp
                        match Lr0Item.cmp l0 l1 with
                          | Lt -> Lt
                          | Eq -> Bitset.cmp f0 f1
                          | Gt -> Gt

                    pp {lr0item; follow} formatter =
                        formatter
                          |> Fmt.fmt "{%f(^Lr0Item.pp^)=(^lr0item^); %f(^Bitset.pp^)=(^follow^)}"
                  }
                include T
                include Identifiable.Make(T)

                init ~lr0item ~follow =
                    {lr0item; follow}

                (* The concatenation of the RHS symbols to the right of the dot and the follow set
                 * comprise an ordered sequence of symbols to be expected. Merge-fold the symbols' first
                 * sets (excluding "ε"), until a preceding symbol's first set does not contain "ε".
                 * Similarly, if all symbols contain "ε", merge the follow set (excluding "ε"). Merge
                 * "ε" if all symbols' first sets and the follow set contain "ε". *)
                let first symbols {lr0item; follow} =
                    let epsilon = Array.get 0L symbols
                    assert String.(Symbol.(epsilon.name) = "EPSILON")
                    let append_symbol_set first merge_epsilon symbol_set =
                        let symbol_set_sans_epsilon = Bitset.remove epsilon.index symbol_set
                        let first' = Bitset.union symbol_set_sans_epsilon first
                        let contains_epsilon = Bitset.mem epsilon.index symbol_set
                        let merge_epsilon' = match contains_epsilon with
                          | false -> false
                          | true -> merge_epsilon
                        first', merge_epsilon'
                    let rhs_indexes = lr0item.prod.rhs_indexes
                    let rhs_slice = Array.Slice.init ~range:(lr0item.dot =:< Array.length rhs_indexes)
                      rhs_indexes
                    (* Merge-fold RHS symbols' first sets. *)
                    let first, merge_epsilon = Array.Slice.fold_until
                      ~init:(Bitset.empty, true)
                      ~f:(fn (first, merge_epsilon) symbol_index ->
                        let symbol = Array.get symbol_index symbols
                        let first', merge_epsilon' = append_symbol_set first merge_epsilon symbol.first
                        (first', merge_epsilon'), not merge_epsilon'
                      ) rhs_slice
                    (* Append the follow set only if all RHS symbols to the right of the dot contain
                     * "ε". *)
                    match merge_epsilon with
                      | false -> first
                      | true ->
                        let first', merge_epsilon' = append_symbol_set first merge_epsilon follow
                        match merge_epsilon' with
                          | false -> first'
                          | true -> Bitset.insert epsilon.index first'
              }

            Lr1Itemset = {
                T = {
                    type t: t = Ordmap.t Lr0Item.t Lr1Item.t Lr0Item.cmper_witness

                    hash_fold = Ordmap.hash_fold Lr1Item.hash_fold
                    cmp = Ordmap.cmp Lr1Item.cmp
                    pp = Ordmap.pp Lr1Item.pp
                  }
                include T
                include Identifiable.Make(T)

                empty = Ordmap.empty Lr0Item

                init = Ordmap.of_alist Lr0Item

                let mem Lr1Item.{lr0item; follow} t =
                    match Ordmap.get lr0item t with
                      | None -> false
                      | Some Lr1Item.{follow=t_follow; _} -> Bitset.subset t_follow follow

                let insert (Lr1Item.{lr0item; follow} as lr1item) t =
                    Ordmap.amend lr0item ~f:(fn lr1item_opt ->
                        match lr1item_opt with
                          | None -> Some lr1item
                          | Some Lr1Item.{follow=t_follow; _} ->
                            let follow = Bitset.union follow t_follow
                            Some (Lr1Item.init ~lr0item ~follow)
                      ) t
              }

            Lr1ItemsetClosure = {
                T = {
                    type t: t = {
                        index: uns
                        kernel: Lr1Itemset.t
                        added: lazy_t Lr1Itemset.t
                      }

                    hash_fold {index; _} state =
                        state |> Uns.hash_fold index

                    cmp {index=i0; _} {index=i1; _} =
                        Uns.cmp i0 i1

                    pp {index; kernel} formatter =
                        formatter
                          |> Fmt.fmt
                          "{%u=(^index
                          ^); %f(^Lr1Itemset.pp^)=(^kernel
                          ^)}"
                  }
                include T
                include Identifiable.Make(T)

                added_impl symbols kernel =
                    let rec f symbols lr1itemset added =
                        match Ordmap.choose lr1itemset with
                          | None -> added
                          | Some (_lr0item, Lr1Item.{lr0item={prod={rhs_indexes; _} as prod; dot}
                          as lr0item; follow}) ->
                            let lr1itemset' = Ordmap.remove lr0item lr1itemset
                            match Uns.(dot < Array.length rhs_indexes) with
                              | false ->
                                (* X ::= a· *)
                                f symbols lr1itemset' added
                              | true ->
                                let rhs_symbol_index = Array.get dot rhs_indexes
                                let rhs_symbol = Array.get rhs_symbol_index symbols
                                match Symbol.is_nonterm rhs_symbol with
                                  | false ->
                                    (* X ::= a·b *)
                                    f symbols lr1itemset' added
                                  | true ->
                                    (* X ::= a·Ab *)
                                    let lhs = rhs_symbol
                                    let follow' = Lr1Item.first symbols
                                      (Lr1Item.init ~lr0item:(Lr0Item.init ~prod ~dot:(succ dot))
                                      ~follow)
                                    let lr1itemset', added' = Ordset.fold ~init:(lr1itemset', added)
                                      ~f:(fn (lr1itemset, added) prod ->
                                        let lr0item = Lr0Item.init ~prod ~dot:0
                                        let lr1item = Lr1Item.init ~lr0item ~follow:follow'
                                        match Lr1Itemset.mem lr1item added with
                                          | true -> lr1itemset, added
                                          | false ->
                                            let lr1itemset' = Lr1Itemset.insert lr1item lr1itemset
                                            let added' = Lr1Itemset.insert lr1item added
                                            lr1itemset', added'
                                      ) lhs.prods
                                    f symbols lr1itemset' added'
                    f symbols kernel Lr1Itemset.empty

                let added {added; _} =
                    Lazy.force added

                init ~index ~kernel =
                    {index; kernel; added=lazy (added_impl symbols kernel)}
              }

            Action = {
                T = {
                    type t: t =
                      | ShiftPrefix of uns
                      | ShiftAccept of uns
                      | Reduce of uns

                    constructor_index t = match t with
                      | ShiftPrefix _ -> 0
                      | ShiftAccept _ -> 1
                      | Reduce _ -> 2

                    arg_index t = match t with
                      | ShiftPrefix arg_index
                      | ShiftAccept arg_index
                      | Reduce arg_index -> arg_index

                    hash_fold t state =
                        state
                          |> Uns.hash_fold (constructor_index t)
                          |> Uns.hash_fold (arg_index t)

                    cmp t0 t1 =
                        let open Cmp
                        match Uns.cmp (constructor_index t0) (constructor_index t1) with
                          | Lt -> Lt
                          | Eq -> Uns.cmp (arg_index t0) (arg_index t1)
                          | Gt -> Gt

                    to_string t = match t with
                      | ShiftPrefix state_index -> "ShiftPrefix %u(^state_index^)"
                      | ShiftAccept state_index -> "ShiftAccept %u(^state_index^)"
                      | Reduce prod_index -> "Reduce %u(^prod_index^)"

                    pp t formatter =
                        formatter |> Fmt.fmt (to_string t)
                  }
                include T
                include Identifiable.Make(T)
              }

            State = {
                T = {
                    type t: t = {
                        lr1ItemsetClosure: Lr1ItemsetClosure.t
                        actions: Map.t uns Action.t Uns.cmper_witness
                        gotos: Map.t uns uns Uns.cmper_witness
                      }

                    hash_fold {lr1ItemsetClosure; _} state =
                        state |> Lr1ItemsetClosure.hash_fold lr1ItemsetClosure

                    cmp {lr1ItemsetClosure=c0; _} {lr1ItemsetClosure=c1; _} =
                        Lr1ItemsetClosure.cmp c0 c1

                    pp {lr1ItemsetClosure; actions; gotos} formatter =
                        formatter
                          |> Fmt.fmt
                          "{%f(^Lr1ItemsetClosure.pp^)=(^lr1ItemsetClosure
                          ^); %f(^Map.pp Action.pp^)=(^actions
                          ^); %f(^Map.pp Uns.pp^)=(^gotos
                          ^)}"
                  }
                include T
                include Identifiable.Make(T)

                init ~lr1ItemsetClosure ~actions ~gotos =
                    {lr1ItemsetClosure; actions; gotos}
              }

            states = [|
                (* 0 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:0
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 8 prods) ~dot:0
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 0
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        6, Action.ShiftPrefix 1
                      ]
                  ~gotos:
                    Map.of_alist Uns [
                        10, 2
                        11, 3
                      ]
                (* 1 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:1
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 6 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        2, Action.Reduce 6
                        3, Action.Reduce 6
                        4, Action.Reduce 6
                        5, Action.Reduce 6
                        7, Action.Reduce 6
                      ]
                  ~gotos:
                    Map.empty Uns
                (* 2 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:2
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 7 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 1
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        2, Action.ShiftPrefix 4
                        3, Action.ShiftPrefix 5
                        4, Action.ShiftPrefix 6
                        5, Action.ShiftPrefix 7
                        7, Action.ShiftAccept 8
                      ]
                  ~gotos:
                    Map.of_alist Uns [
                        8, 9
                        9, 10
                      ]
                (* 3 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:3
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 8 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 0
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        1, Action.ShiftPrefix 11
                      ]
                  ~gotos:
                    Map.empty Uns
                (* 4 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:4
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 0 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 6
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        6, Action.Reduce 0
                      ]
                  ~gotos:
                    Map.empty Uns
                (* 5 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:5
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 1 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 6
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        6, Action.Reduce 1
                      ]
                  ~gotos:
                    Map.empty Uns
                (* 6 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:6
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 2 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 6
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        6, Action.Reduce 2
                      ]
                  ~gotos:
                    Map.empty Uns
                (* 7 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:7
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 3 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 6
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        6, Action.Reduce 3
                      ]
                  ~gotos:
                    Map.empty Uns
                (* 8 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:8
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 7 prods) ~dot:2
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 1
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        1, Action.Reduce 7
                      ]
                  ~gotos:
                    Map.empty Uns
                (* 9 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:9
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:2
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        6, Action.ShiftPrefix 1
                      ]
                  ~gotos:
                    Map.of_alist Uns [
                        10, 12
                      ]
                (* 10 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:10
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:2
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        6, Action.ShiftPrefix 1
                      ]
                  ~gotos:
                    Map.of_alist Uns [
                        10, 13
                      ]
                (* 11 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:11
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 8 prods) ~dot:2
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.singleton 0
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        0, Action.Reduce 8
                      ]
                  ~gotos:
                    Map.empty Uns
                (* 12 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:12
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:3
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        2, Action.Reduce 4
                        3, Action.Reduce 4
                        4, Action.Reduce 4
                        5, Action.Reduce 4
                        7, Action.Reduce 4
                      ]
                  ~gotos:
                    Map.of_alist Uns [
                        8, 9
                        9, 10
                      ]
                (* 13 *) State.init
                  ~lr1ItemsetClosure:
                    Lr1ItemsetClosure.init
                      ~index:13
                      ~kernel:
                        Lr1Itemset.init [
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:1
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                            (
                                let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:3
                                let lr1item = Lr1Item.init ~lr0item ~follow:
                                    Bitset.of_nat 0xbcn
                                lr0item, lr1item
                              )
                          ]
                  ~actions:
                    Map.of_alist Uns [
                        2, Action.ShiftPrefix 4
                        3, Action.ShiftPrefix 5
                        4, Action.Reduce 5
                        5, Action.Reduce 5
                        7, Action.Reduce 5
                      ]
                  ~gotos:
                    Map.of_alist Uns [
                        8, 9
                        9, 10
                      ]
              |]
          }

        Token = {
            T = {
                type t: t =
                  | EPSILON # "ε"
                  | PSEUDO_END # "⊥"
                  | STAR # "*"
                  | SLASH # "/"
                  | PLUS # "+"
                  | MINUS # "-"
                  | INT of Zint.t
                  | EOI

                index t = match t with
                  | EPSILON -> 0
                  | PSEUDO_END -> 1
                  | STAR -> 2
                  | SLASH -> 3
                  | PLUS -> 4
                  | MINUS -> 5
                  | INT _ -> 6
                  | EOI -> 7

                hash_fold t state =
                    state |> Uns.hash_fold (index t)

                cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                spec t =
                    Array.get (index t) Spec.symbols

                pp t formatter =
                    formatter
                      |> Spec.Symbol.pp (spec t)
              }
            include T
            include Identifiable.Make(T)
          }

        Nonterm = {
            T = {
                type t: t =
                  | MulOp of Token.t
                  | AddOp of Token.t
                  | Expr of Zint.t
                  | Answer of Zint.t
                  | Answer' of Zint.t

                index t = match t with
                  | MulOp _ -> 8
                  | AddOp _ -> 9
                  | Expr _ -> 10
                  | Answer _ -> 11
                  | Answer' _ -> 12

                hash_fold t state =
                    state |> Uns.hash_fold (index t)

                cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                spec t =
                    Array.get (index t) Spec.symbols

                pp t formatter =
                    formatter
                      |> Spec.Symbol.pp (spec t)
              }
            include T
            include Identifiable.Make(T)
          }

        Symbol = {
            T = {
                type t: t =
                  | Token of Token.t
                  | Nonterm of Nonterm.t

                index t = match t with
                  | Token token -> Token.index token
                  | Nonterm nonterm -> Nonterm.index nonterm

                hash_fold t state =
                    state |> Uns.hash_fold (index t)

                cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                spec t = match t with
                  | Token token -> Token.spec token
                  | Nonterm nonterm -> Nonterm.spec nonterm

                pp t formatter =
                    formatter
                      |> Spec.Symbol.pp (spec t)
              }
            include T
            include Identifiable.Make(T)
          }

        State = {
            T = {
                type t: t = uns

                hash_fold t state =
                    state |> Uns.hash_fold t

                cmp t0 t1 =
                    Uns.cmp t0 t1

                spec t =
                    Array.get t Spec.states

                pp t formatter =
                    formatter |> Uns.pp t
              }
            include T
            include Identifiable.Make(T)

            init state_index =
                state_index
          }

        Stack = {
            Elm = {
                T = {
                    type t: t = {
                        symbol: Symbol.t;
                        state: State.t;
                      }

                    hash_fold {symbol; state} hash_state =
                        hash_state
                          |> Symbol.hash_fold symbol
                          |> State.hash_fold state

                    cmp {symbol=symbol0; state=state0} {symbol=symbol1; state=state1} =
                        let open Cmp
                        match State.cmp state0 state1 with
                          | Lt -> Lt
                          | Eq -> Symbol.cmp symbol0 symbol1
                          | Gt -> Gt

                    let pp {symbol; state} formatter =
                        formatter |> Fmt.fmt "{%f(^Symbol.pp^)=(^symbol^); %f(^State.pp^)=(^state^)}"
                  }
                include T
                include Identifiable.Make(T)

                init ~symbol ~state =
                    {symbol; state}
              }

            type t: t = list Elm.t

            fmt ?(alt=false) ?(width=0) t formatter =
                formatter |> List.fmt ~alt ~width Elm.pp t

            pp t formatter =
                formatter |> fmt t

            Reduction = {
                T = {
                    type stack: stack = t
                    type t: t = uns
                    type callback: callback = stack -> Symbol.t * stack

                    hash_fold t state =
                        state |> Uns.hash_fold t

                    cmp t0 t1 =
                        Uns.cmp t0 t1

                    pp t formatter =
                        formatter |> Uns.pp t
                  }
                include T
                include Identifiable.Make(T)

                callbacks = [|
                    (* 0 *) fn stk -> match stk with
                      | _
                      :: tl__hocc__ -> Symbol.Nonterm (MulOp (
                      # ____________________________________________________________________________
                      [:"./Example_c.hmh":10:8+11]STAR[:]
                      # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                      )), tl__hocc__
                      | _ -> not_reached ()
                    (* 1 *) fn stk -> match stk with
                      | _
                      :: tl__hocc__ -> Symbol.Nonterm (MulOp (
                      # ____________________________________________________________________________
                      [:"./Example_c.hmh":11:8+11]SLASH[:]
                      # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                      )), tl__hocc__
                      | _ -> not_reached ()
                    (* 2 *) fn stk -> match stk with
                      | _
                      :: tl__hocc__ -> Symbol.Nonterm (AddOp (
                      # ____________________________________________________________________________
                      [:"./Example_c.hmh":17:8+11]PLUS[:]
                      # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                      )), tl__hocc__
                      | _ -> not_reached ()
                    (* 3 *) fn stk -> match stk with
                      | _
                      :: tl__hocc__ -> Symbol.Nonterm (AddOp (
                      # ____________________________________________________________________________
                      [:"./Example_c.hmh":18:8+11]MINUS[:]
                      # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                      )), tl__hocc__
                      | _ -> not_reached ()
                    (* 4 *) fn stk -> match stk with
                      | {symbol=Symbol.Nonterm (Expr e1); _}
                      :: {symbol=Symbol.Nonterm (MulOp op); _}
                      :: {symbol=Symbol.Nonterm (Expr e0); _}
                      :: tl__hocc__ -> Symbol.Nonterm (Expr (
                      # ____________________________________________________________________________
                      [:"./Example_c.hmh":23:12+0]match op with
              | STAR -> Zint.(e0 * e1)
              | SLASH -> Zint.(e0 / e1)
              | _ -> not_reached ()[:]
                      # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                      )), tl__hocc__
                      | _ -> not_reached ()
                    (* 5 *) fn stk -> match stk with
                      | {symbol=Symbol.Nonterm (Expr e1); _}
                      :: {symbol=Symbol.Nonterm (AddOp op); _}
                      :: {symbol=Symbol.Nonterm (Expr e0); _}
                      :: tl__hocc__ -> Symbol.Nonterm (Expr (
                      # ____________________________________________________________________________
                      [:"./Example_c.hmh":28:12+0]match op with
              | PLUS -> Zint.(e0 + e1)
              | MINUS -> Zint.(e0 - e1)
              | _ -> not_reached ()[:]
                      # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                      )), tl__hocc__
                      | _ -> not_reached ()
                    (* 6 *) fn stk -> match stk with
                      | {symbol=Symbol.Token (INT x); _}
                      :: tl__hocc__ -> Symbol.Nonterm (Expr (
                      # ____________________________________________________________________________
                      [:"./Example_c.hmh":32:8+13]x[:]
                      # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                      )), tl__hocc__
                      | _ -> not_reached ()
                    (* 7 *) fn stk -> match stk with
                      | _
                      :: {symbol=Symbol.Nonterm (Expr e); _}
                      :: tl__hocc__ -> Symbol.Nonterm (Answer (
                      # ____________________________________________________________________________
                      [:"./Example_c.hmh":36:8+18]e[:]
                      # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                      )), tl__hocc__
                      | _ -> not_reached ()
                    (* 8 *) fn _stack -> not_reached ()
                  |]

                callback t =
                    Array.get t callbacks

                init callback_index =
                    callback_index
              }

            shift ~symbol ~state t =
                (Elm.init ~symbol ~state) :: t

            # goto: Symbol.t -> t -> t
            goto symbol t =
                match t with
                  | [] -> not_reached ()
                  | Elm.{state; _} :: _ ->
                    let symbol_index = Symbol.index symbol
                    let Spec.State.{gotos; _} = Array.get state Spec.states
                    let state' = Map.get_hlt symbol_index gotos |> State.init
                    shift ~symbol ~state:state' t

            reduce ~reduction t =
                let callback = Reduction.callback reduction
                let symbol, t' = callback t
                goto symbol t'
          }

        Status = {
            T = {
                type t: t =
                  | ShiftPrefix of Token.t * State.t
                  | ShiftAccept of Token.t * State.t
                  | Reduce of Token.t * Stack.Reduction.t
                  | Prefix
                  | Accept of Nonterm.t
                  | Reject of Token.t

                let constructor_index t = match t with
                  | ShiftPrefix _ -> 0
                  | ShiftAccept _ -> 1
                  | Reduce _ -> 2
                  | Prefix -> 3
                  | Accept _ -> 4
                  | Reject _ -> 5

                let hash_fold t state =
                    state
                      |> Uns.hash_fold (constructor_index t)
                      |> fn hash_state ->
                        match t with
                          | ShiftPrefix (token, state)
                          | ShiftAccept (token, state) ->
                            hash_state |> State.hash_fold state |> Token.hash_fold token
                          | Reduce (token, reduction) ->
                            hash_state |> Stack.Reduction.hash_fold reduction |> Token.hash_fold token
                          | Prefix -> hash_state
                          | Accept nonterm -> hash_state |> Nonterm.hash_fold nonterm
                          | Reject token -> hash_state |> Token.hash_fold token

                let cmp t0 t1 =
                    let open Cmp
                    match Uns.cmp (constructor_index t0) (constructor_index t1) with
                      | Lt -> Lt
                      | Eq ->
                        match t0, t1 with
                          | ShiftPrefix (token0, state0), ShiftPrefix (token1, state1)
                          | ShiftAccept (token0, state0), ShiftAccept (token1, state1) ->
                            match State.cmp state0 state1 with
                              | Lt -> Lt
                              | Eq -> Token.cmp token0 token1
                              | Gt -> Gt
                          | Reduce (token0, reduction0), Reduce (token1, reduction1) ->
                            match Stack.Reduction.cmp reduction0 reduction1 with
                              | Lt -> Lt
                              | Eq -> Token.cmp token0 token1
                              | Gt -> Gt
                          | Prefix, Prefix -> Eq
                          | Accept nonterm0, Accept nonterm1 -> Nonterm.cmp nonterm0 nonterm1
                          | Reject token0, Reject token1 -> Token.cmp token0 token1
                          | _, _ -> not_reached ()
                      | Gt -> Gt

                pp t formatter =
                    formatter
                      |> fn formatter ->
                        match t with
                          | ShiftPrefix (token, state) ->
                            formatter
                              |> Fmt.fmt "ShiftPrefix (%f(^Token.pp^)(^token^), %f(^State.pp^)(^state
                              ^))"
                          | ShiftAccept (token, state) ->
                            formatter
                              |> Fmt.fmt "ShiftAccept (%f(^Token.pp^)(^token^), %f(^State.pp^)(^state
                              ^))"
                          | Reduce reduction ->
                            formatter
                              |> Fmt.fmt "Reduce (%f(^Token.pp^)(^token^), %f(^Stack.Reduction.pp
                              ^)(^reduction^))"
                          | Prefix -> formatter |> Fmt.fmt "Prefix"
                          | Accept nonterm -> formatter |> Fmt.fmt "Accept %f(^Nonterm.pp^)(^nonterm^)"
                          | Reject token -> formatter |> Fmt.fmt "Reject %f(^Token.pp^)(^token^)"
              }
            include T
            include Identifiable.Make(T)
          }

        type t: t = {
            stack: Stack.t
            status: Status.t
          }

        Start = {
            Answer = {
                boi = {
                    stack=[{
                        symbol=Token Token.EPSILON
                        state=State.init 0
                      }]
                    status=Prefix
                  }
              }
          }

        feed token t = match t with
          | {stack={state; _} :: _; status=Prefix} as t ->
            let token_index = Token.index token
            let Spec.State.{actions; _} = Array.get state Spec.states
            let status = match Map.get token_index actions with
              | Some (Spec.Action.ShiftPrefix state') -> Status.ShiftPrefix (token, state')
              | Some (Spec.Action.ShiftAccept state') -> Status.ShiftAccept (token, state')
              | Some (Spec.Action.Reduce prod_index) ->
                let Spec.Prod.{callback=callback_index; _} = Array.get prod_index Spec.prods
                let reduction = Stack.Reduction.init callback_index
                Status.Reduce (token, reduction)
              | None -> Status.Reject token
            {t with status}
          | _ -> not_reached ()

        step {stack; status} =
            let open Status
            match status with
              | ShiftPrefix (token, state) -> {stack=shift token state stack; status=Prefix}
              | ShiftAccept (token, state) ->
                # Shift, perform the ⊥ reduction, and extract the accepted symbol from the stack.
                let stack = shift token state stack
                let pseudo_end_index = Token.index Token.PSEUDO_END
                let Spec.State.{actions; _} = Array.get state Spec.states
                match Map.get_hlt pseudo_end_index actions with
                  | Spec.Action.Reduce prod_index ->
                    let Spec.Prod.{callback=callback_index; _} = Array.get prod_index Spec.prods
                    let reduction = Stack.Reduction.init callback_index
                    let stack = Stack.reduce ~reduction stack
                    match stack with
                      | [] -> not_reached ()
                      | {symbol=Token _; _} :: _ -> not_reached ()
                      | {symbol=Nonterm nonterm; _} :: _ -> {stack=[]; status=Accept nonterm}
                  | _ -> not_reached ()
              | Reduce (token, reduction) ->
                feed token {stack=Stack.reduce ~reduction stack; status=Prefix}
              | _ -> not_reached ()

        # walk: t -> t
        rec walk ({status; _} as t) =
            let open Status
            match status with
              | ShiftPrefix _
              | ShiftAccept _
              | Reduce _ -> t |> step |> walk
              | Prefix
              | Accept _
              | Reject _ -> t

        next token ({status; _} as t) =
            match status with
              | Status.Prefix -> t |> feed token |> walk
              | _ -> not_reached ()
      }[:"./Example_c.hmh":36:4+23]
  }

# Tokenize `s`, e.g. "2 + 3 * 4", and append an `EOI` token.
tokenize s =
    s |> String.split_rev ~f:(fn cp -> Codepoint.(cp = ' '))
      |> List.rev_filter ~f:(fn s -> not (String.is_empty s))
      |> List.rev_map ~f:fn s ->
        let open Token
        match s with
          | "*" -> STAR
          | "/" -> SLASH
          | "+" -> PLUS
          | "-" -> MINUS
          | _ -> INT (Zint.of_string s)
      |> List.push Token.EOI
      |> List.rev

# Calculate the result of the arithmetic expression expressed in `s`, e.g. "2 + 3 * 4".
calculate s =
    let {status; _} = List.fold_until (tokenize s) ~init:Start.Answer.boi ~f:fn parser tok ->
        let {status; _} as parser' = Start.Answer.next tok parser
        let done = match status with
          | Prefix -> false
          | Accept _
          | Error _ -> true
          | _ -> not_reached ()
        parser', done
    match status with
      | Accept (Answer answer) -> answer
      | Prefix _ -> halt "Partial input"
      | Error _ -> halt "Parse error"
      | _ -> not_reached ()

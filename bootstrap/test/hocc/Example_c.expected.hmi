# This file was generated by `hocc` based on "Example_c.hmhi"
[:"./Example_c.hmhi":1]open import Basis

Parser = {
    # Better written as `Parser = hocc`, but this is an indentation test.
    include [:]{
        Spec = {
            Algorithm = {
                type t: t =
                  | Lr1 [@doc "LR(1) algorithm."]
                  | Ielr1 [@doc "IELR(1) algorithm."]
                  | Pgm1 [@doc "PGM(1) algorithm."]
                  | Lalr1 [@doc "LALR(1) algorithm."]

                include IdentifiableIntf.S with type t := t
              }

            algorithm: Algorithm.t
              [@@doc "Algorithm used to generate parser."]

            Assoc = {
                type t: t =
                  | Left
                  | Right

                include IdentifiableIntf.S with type t := t
              }

            PrecSet = {
                type t: t = {
                    index: uns # Index in `prec_sets` array.
                    names: array string
                    assoc: option Assoc.t
                    doms: Ordset.t uns Uns.cmper_witness (* Indices in `prec_sets` array of dominator
                                                          * precedence sets. *)
                  }

                include IdentifiableIntf.S with type t := t
              }

            prec_sets: array PrecSet.t
              [@@doc "Array of precedence sets, where each element's `index` field corresponds to the
              element's array index."]

            Prec = {
                type t: t = {
                    name_index: uns # Index of precedence name in precedence set.
                    prec_set_index: uns # Index of precedence set in `prec_sets`.
                  }

                include IdentifiableIntf.S with type t := t
              }

            Prod = {
                type t: t = {
                    index: uns # Index in `prods` array.
                    lhs_index: uns
                    rhs_indexes: array uns
                    prec: option Prec.t
                    callback: uns # Index of reduction callback in `Stack.Reduction.callbacks`.
                  }

                include IdentifiableIntf.S with type t := t
              }

            prods: array Prod.t
              [@@doc "Array of productions, where each element's `index` field corresponds to the
              element's array index."]

            Symbol = {
                type t: t = {
                    index: uns # Index in `symbols` array.
                    name: string
                    prec: option Prec.t
                    alias: option string
                    start: bool
                    prods: Ordset.t Prod.t Prod.cmper_witness # empty â‰¡ token
                    first: Ordset.t uns Uns.cmper_witness
                    follow: Ordset.t uns Uns.cmper_witness
                  }

                include IdentifiableIntf.S with type t := t
              }

            symbols: array Symbol.t
              [@@doc "Array of symbols, where each element's `index` field corresponds to the element's
              array index."]

            Lr0Item = {
                type t: t = {
                    prod: Prod.t
                    dot: uns
                  }

                include IdentifiableIntf.S with type t := t
              }

            Lr1Item = {
                type t: t = {
                    lr0item: Lr0Item.t
                    follow: Ordset.t uns Uns.cmper_witness
                  }

                include IdentifiableIntf.S with type t := t
              }

            Lr1Itemset = {
                type t: t = Ordmap.t Lr0Item.t Lr1Item.t Lr0Item.cmper_witness

                include IdentifiableIntf.S with type t := t
              }

            Lr1ItemsetClosure = {
                type t: t = {
                    index: uns # Index of corresponding `State.t` in `states` array.
                    kernel: Lr1Itemset.t
                    added: Lr1Itemset.t
                  }

                include IdentifiableIntf.S with type t := t
              }

            Action = {
                type t: t =
                  | ShiftPrefix of uns # `states` index.
                  | ShiftAccept of uns # `states` index.
                  | Reduce of uns # `prods` index.

                include IdentifiableIntf.S with type t := t
              }

            State = {
                type t: t = {
                    lr1ItemsetClosure: Lr1ItemsetClosure.t
                    actions: Map.t uns Action.t Uns.cmper_witness
                    gotos: Map.t uns uns Uns.cmper_witness
                  }

                include IdentifiableIntf.S with type t := t
              }

            states: array State.t
              [@@doc "Array of CFSM states, where each element's `lr1ItemsetClosure.index` field
              corresponds to the element's array index."]
          }

        Token = {
            type t: t =
              | EPSILON # "Îµ"
              | PSEUDO_END # "âŠ¥"
              | STAR # "*"
              | SLASH # "/"
              | PLUS # "+"
              | MINUS # "-"
              | INT of Zint.t
              | EOI

            include IdentifiableIntf.S with type t := t

            spec: t -> Spec.Symbol.t
          }

        Nonterm = {
            type t: t =
              | MulOp of Token.t
              | AddOp of Token.t
              | Expr of Zint.t
              | Answer of Zint.t
              | Answer' of Zint.t

            include IdentifiableIntf.S with type t := t

            spec: t -> Spec.Symbol.t
          }

        Symbol = {
            type t: t =
              | Token of Token.t
              | Nonterm of Nonterm.t

            include IdentifiableIntf.S with type t := t

            spec: t -> Spec.Symbol.t
          }

        State = {
            type t: t = uns

            include IdentifiableIntf.S with type t := t

            spec: t -> Spec.State.t
          }

        Stack = {
            module Elm : sig
                type t: t = {
                    symbol: Symbol.t;
                    state: State.t;
                  }

                include IdentifiableIntf.S with type t := t
              end

            type t: t = Elm.t list

            pp >e: t -> Fmt.Formatter e >e-> Fmt.Formatter e
            fmt >e: ?alt:bool -> ?width:uns -> t -> Fmt.Formatter e >e-> Fmt.Formatter e

            Reduction = {
                type stack: stack = t
                type t: t
                type callback: callback = stack -> Symbol.t * stack

                include IdentifiableIntf.S with type t := t

                callbacks: array callback
                  [@@doc "Array of reduction callback functions containing embedded parser code."]

                callback: t -> callback
              }

            shift: symbol:Symbol.t -> state:State.t -> t -> t
              [@@doc "Perform a shift."]

            reduce: reduction:Reduction.t -> t -> t
              [@@doc "Perform a reduction."]
          }

        Status = {
            type t: t =
              # `feed`/`step` may produce these variants; `next` fast-forwards over them.
              | ShiftPrefix of Token.t * State.t
              | ShiftAccept of Token.t * State.t
              | Reduce of Token.t * Stack.Reduction.t
              # Common variants.
              | Prefix # Valid parse prefix; more input needed.
              | Accept of Nonterm.t # Successful parse result.
              | Reject of Token.t # Syntax error due to unexpected token.

            include IdentifiableIntf.S with type t := t
          }

        type t: t = {
            stack: Stack.t
            status: Status.t
          }

        Start = {
            Answer = {
                boi: t
              }
          }

        feed: Token.t -> t -> t
          [@@doc "`feed token t` returns a result with status in {`ShiftPrefix`, `ShiftAccept`,
          `Reduce`, `Reject`}. `t.status` must be `Prefix`."]

        step: t -> t
          [@@doc "`step t` returns the result of applying one state transition to `t`. `t.status` must
          be in {`ShiftPrefix`, `ShiftAccept`, `Reduce`}."]

        next: Token.t -> t -> t
          [@@doc "`next token t` calls `feed token t` and fast-forwards via `step` calls to return a
          result with status in {`Prefix`, `Accept`, `Reject`}. `t.status` must be `Prefix`."]
      }[:"./Example_c.hmhi":5:4+12]
  }

calculate: string -> zint

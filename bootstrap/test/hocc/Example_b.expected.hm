# This file was generated by `hocc` based on "Example_b.hmh"
[:"./Example_b.hmh":1]open import Basis

# The `hocc` keyword is on a continued line. Indentation should remain a multiple of 4.
include
  [:]{
    Spec = {
        Algorithm = {
            T = {
                type t: t =
                  | Lr1
                  | Ielr1
                  | Pgm1
                  | Lalr1

                index = function
                  | Lr1 -> 0
                  | Ielr1 -> 1
                  | Pgm1 -> 2
                  | Lalr1 -> 3

                hash_fold t state =
                    state |> Uns.hash_fold (index t)

                cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                to_string = function
                  | Lr1 -> "Lr1"
                  | Ielr1 -> "Ielr1"
                  | Pgm1 -> "Pgm1"
                  | Lalr1 -> "Lalr1"

                pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              }
            include T
            include Identifiable.Make(T)
          }

        algorithm = Algorithm.Lr1

        Assoc = {
            T = {
                type t: t =
                  | Left
                  | Right

                index = function
                  | Left -> 0
                  | Right -> 1

                hash_fold t state =
                    state |> Uns.hash_fold (index t)

                cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                to_string = function
                  | Left -> "Left"
                  | Right -> "Right"

                pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              }
            include T
            include Identifiable.Make(T)
          }

        Prec = {
            T = {
                type t: t = {
                    index: uns
                    name: string
                    assoc: option Assoc.t
                    doms: Ordset.t uns Uns.cmper_witness
                  }

                index {index; _} =
                    index

                hash_fold t state =
                    state |> Uns.hash_fold (index t)

                cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                pp {index; name; assoc; doms} formatter =
                    formatter
                      |> Fmt.fmt
                      "{%u=(^index
                      ^); %s=(^name
                      ^); %f(^Option.pp Assoc.pp^)=(^assoc
                      ^); %f(^Ordset.pp^)=(^doms
                      ^)}"
              }
            include T
            include Identifiable.Make(T)

            init ~index ~name ~assoc ~doms =
                {index; name; assoc; doms}
          }

        precs = [|
            Prec.init ~index:0 ~name:"mul" ~assoc:(Some Left) ~doms:(Ordset.empty Uns)
            Prec.init ~index:1 ~name:"add" ~assoc:(Some Left) ~doms:(Ordset.singleton Uns 0)
          |]

        Prod = {
            T = {
                type t: t = {
                    index: uns
                    lhs_index: uns
                    rhs_indexes: array uns
                    prec: option Prec.t
                    callback: uns
                  }

                hash_fold {index; _} state =
                    Uns.hash_fold index state

                cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                pp {index; lhs_index; rhs_indexes; prec; callback} formatter =
                    formatter
                      |> Fmt.fmt
                      "{%u=(^index
                      ^); %u=(^lhs_index
                      ^); %f(^Array.pp Uns.pp^)=(^rhs_indexes
                      ^); %f(^Option.pp Prec.pp^)=(^prec
                      ^); %u=(^callback
                      ^)}"
              }
            include T
            include Identifiable.Make(T)

            init ~index ~lhs_index ~rhs_indexes ~prec ~callback =
                {index; lhs_index; rhs_indexes; prec; callback}
          }

        prods = [|
            Prod.init ~index:0 ~lhs_index:8 ~rhs_indexes:[|2|]
              ~prec:None ~callback:0
            Prod.init ~index:1 ~lhs_index:8 ~rhs_indexes:[|3|]
              ~prec:None ~callback:1
            Prod.init ~index:2 ~lhs_index:9 ~rhs_indexes:[|4|]
              ~prec:None ~callback:2
            Prod.init ~index:3 ~lhs_index:9 ~rhs_indexes:[|5|]
              ~prec:None ~callback:3
            Prod.init ~index:4 ~lhs_index:10 ~rhs_indexes:[|10; 8; 10|]
              ~prec:(Some (Array.get 0 precs)) ~callback:4
            Prod.init ~index:5 ~lhs_index:10 ~rhs_indexes:[|10; 9; 10|]
              ~prec:(Some (Array.get 1 precs)) ~callback:5
            Prod.init ~index:6 ~lhs_index:10 ~rhs_indexes:[|6|]
              ~prec:None ~callback:6
            Prod.init ~index:7 ~lhs_index:11 ~rhs_indexes:[|10; 7|]
              ~prec:None ~callback:7
            Prod.init ~index:8 ~lhs_index:12 ~rhs_indexes:[|11; 1|]
              ~prec:None ~callback:8
          |]

        Symbol = {
            T = {
                type t: t = {
                    index: uns
                    name: string
                    prec: option Prec.t
                    alias: option string
                    start: bool
                    prods: Ordset.t Prod.t Prod.cmper_witness
                    first: Ordset.t uns Uns.cmper_witness
                    follow: Ordset.t uns Uns.cmper_witness
                  }

                hash_fold {index; _} state =
                    Uns.hash_fold index state

                cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                pp {index; name; prec; alias; start; prods; first; follow} formatter =
                    formatter
                      |> Fmt.fmt
                      "{%u=(^index
                      ^); %s=(^name
                      ^); %f(^Option.pp Prec.pp^)=(^prec
                      ^); %f(^Option.pp String.pp^)=(^alias
                      ^); %b=(^start
                      ^); %f(^Ordset.pp^)=(^prods
                      ^); %f(^Ordset.pp^)=(^first
                      ^); %f(^Ordset.pp^)=(^follow
                      ^)}"
              }
            include T
            include Identifiable.Make(T)

            init ~index ~name ~prec ~alias ~start ~prods ~first ~follow =
                {index; name; prec; alias; start; prods; first; follow}
          }

        symbols = [|
            Symbol.init ~index:0 ~name:"EPSILON"
              ~prec:None ~alias:(Some "ε") ~start:false
              ~prods:(Ordset.empty Prod) ~first:(Ordset.singleton Uns 0)
              ~follow:(Ordset.empty Uns)
            Symbol.init ~index:1 ~name:"PSEUDO_END"
              ~prec:None ~alias:(Some "⊥") ~start:false
              ~prods:(Ordset.empty Prod) ~first:(Ordset.singleton Uns 1)
              ~follow:(Ordset.singleton Uns 0)
            Symbol.init ~index:2 ~name:"STAR"
              ~prec:(Some (Array.get 0 precs)) ~alias:(Some "*") ~start:false
              ~prods:(Ordset.empty Prod) ~first:(Ordset.singleton Uns 2)
              ~follow:(Ordset.singleton Uns 6)
            Symbol.init ~index:3 ~name:"SLASH"
              ~prec:(Some (Array.get 0 precs)) ~alias:(Some "/") ~start:false
              ~prods:(Ordset.empty Prod) ~first:(Ordset.singleton Uns 3)
              ~follow:(Ordset.singleton Uns 6)
            Symbol.init ~index:4 ~name:"PLUS"
              ~prec:(Some (Array.get 1 precs)) ~alias:(Some "+") ~start:false
              ~prods:(Ordset.empty Prod) ~first:(Ordset.singleton Uns 4)
              ~follow:(Ordset.singleton Uns 6)
            Symbol.init ~index:5 ~name:"MINUS"
              ~prec:(Some (Array.get 1 precs)) ~alias:(Some "-") ~start:false
              ~prods:(Ordset.empty Prod) ~first:(Ordset.singleton Uns 5)
              ~follow:(Ordset.singleton Uns 6)
            Symbol.init ~index:6 ~name:"INT"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.empty Prod) ~first:(Ordset.singleton Uns 6)
              ~follow:(Ordset.of_list Uns [2; 3; 4; 5; 7])
            Symbol.init ~index:7 ~name:"EOI"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.empty Prod) ~first:(Ordset.singleton Uns 7)
              ~follow:(Ordset.singleton Uns 1)
            Symbol.init ~index:8 ~name:"MulOp"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list Prod [
                Array.get 0 prods
                Array.get 1 prods
              ]) ~first:(Ordset.of_list Uns [2; 3])
              ~follow:(Ordset.singleton Uns 6)
            Symbol.init ~index:9 ~name:"AddOp"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list Prod [
                Array.get 2 prods
                Array.get 3 prods
              ]) ~first:(Ordset.of_list Uns [4; 5])
              ~follow:(Ordset.singleton Uns 6)
            Symbol.init ~index:10 ~name:"Expr"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list Prod [
                Array.get 4 prods
                Array.get 5 prods
                Array.get 6 prods
              ]) ~first:(Ordset.singleton Uns 6)
              ~follow:(Ordset.of_list Uns [2; 3; 4; 5; 7])
            Symbol.init ~index:11 ~name:"Answer"
              ~prec:None ~alias:None ~start:true
              ~prods:(Ordset.singleton Prod (Array.get 7 prods)) ~first:(Ordset.singleton Uns 6)
              ~follow:(Ordset.singleton Uns 1)
            Symbol.init ~index:12 ~name:"Answer'"
              ~prec:None ~alias:None ~start:true
              ~prods:(Ordset.singleton Prod (Array.get 8 prods)) ~first:(Ordset.singleton Uns 6)
              ~follow:(Ordset.singleton Uns 0)
          |]

        Lr0Item = {
            T = {
                type t: t = {
                    prod: Prod.t
                    dot: uns
                  }

                hash_fold {prod; dot} state =
                    state
                      |> Prod.hash_fold prod
                      |> Uns.hash_fold dot

                cmp {prod=p0; dot=d0} {prod=p1; dot=d1} =
                    let open Cmp
                    match Prod.cmp p0 p1 with
                      | Lt -> Lt
                      | Eq -> Uns.cmp d0 d1
                      | Gt -> Gt

                pp {prod; dot} formatter =
                    formatter |> Fmt.fmt "{%f(^Prod.pp^)=(^prod^); %u=(^dot^)}"
              }
            include T
            include Identifiable.Make(T)

            init ~prod ~dot =
                {prod; dot}
          }

        Lr1Item = {
            T = {
                type t: t = {
                    lr0item: Lr0Item.t
                    follow: Ordset.t uns Uns.cmper_witness
                  }

                hash_fold {lr0item; follow} state =
                    state
                      |> Lr0Item.hash_fold lr0item
                      |> Ordset.hash_fold follow

                cmp {lr0item=l0; follow=f0} {lr0item=l1; follow=f1} =
                    let open Cmp
                    match Lr0Item.cmp l0 l1 with
                      | Lt -> Lt
                      | Eq -> Ordset.cmp f0 f1
                      | Gt -> Gt

                pp {lr0item; follow} formatter =
                    formatter
                      |> Fmt.fmt "{%f(^Lr0Item.pp^)=(^lr0item^); %f(^Ordset.pp^)=(^follow^)}"
              }
            include T
            include Identifiable.Make(T)

            init ~lr0item ~follow =
                {lr0item; follow}
          }

        Lr1Itemset = {
            T = {
                type t: t = Ordmap.t Lr0Item.t Lr1Item.t Lr0Item.cmper_witness

                hash_fold = Ordmap.hash_fold Lr1Item.hash_fold
                cmp = Ordmap.cmp Lr1Item.cmp
                pp = Ordmap.pp Lr1Item.pp
              }
            include T
            include Identifiable.Make(T)

            empty = Ordmap.empty Lr0Item

            init = Ordmap.of_alist Lr0Item
          }

        Lr1ItemsetClosure = {
            T = {
                type t: t = {
                    index: uns
                    kernel: Lr1Itemset.t
                    added: Lr1Itemset.t
                  }

                hash_fold {index; _} state =
                    state |> Uns.hash_fold index

                cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                pp {index; kernel; added} formatter =
                    formatter
                      |> Fmt.fmt
                      "{%u=(^index
                      ^); %f(^Lr1Itemset.pp^)=(^kernel
                      ^); %f(^Lr1Itemset.pp^)=(^added
                      ^)}"
              }
            include T
            include Identifiable.Make(T)

            init ~index ~kernel ~added =
                {index; kernel; added}
          }

        Action = {
            T = {
                type t: t =
                  | ShiftPrefix of uns
                  | ShiftAccept of uns
                  | Reduce of uns

                constructor_index = function
                  | ShiftPrefix _ -> 0
                  | ShiftAccept _ -> 1
                  | Reduce _ -> 2

                arg_index = function
                  | ShiftPrefix arg_index
                  | ShiftAccept arg_index
                  | Reduce arg_index -> arg_index

                hash_fold t state =
                    state
                      |> Uns.hash_fold (constructor_index t)
                      |> Uns.hash_fold (arg_index t)

                cmp t0 t1 =
                    let open Cmp
                    match Uns.cmp (constructor_index t0) (constructor_index t1) with
                      | Lt -> Lt
                      | Eq -> Uns.cmp (arg_index t0) (arg_index t1)
                      | Gt -> Gt

                to_string = function
                  | ShiftPrefix state_index -> "ShiftPrefix %u(^state_index^)"
                  | ShiftAccept state_index -> "ShiftAccept %u(^state_index^)"
                  | Reduce prod_index -> "Reduce %u(^prod_index^)"

                pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              }
            include T
            include Identifiable.Make(T)
          }

        State = {
            T = {
                type t: t = {
                    lr1ItemsetClosure: Lr1ItemsetClosure.t
                    actions: Map.t uns Action.t Uns.cmper_witness
                    gotos: Map.t uns uns Uns.cmper_witness
                  }

                hash_fold {lr1ItemsetClosure; _} state =
                    state |> Lr1ItemsetClosure.hash_fold lr1ItemsetClosure

                cmp {lr1ItemsetClosure=c0; _} {lr1ItemsetClosure=c1; _} =
                    Lr1ItemsetClosure.cmp c0 c1

                pp {lr1ItemsetClosure; actions; gotos} formatter =
                    formatter
                      |> Fmt.fmt
                      "{%f(^Lr1ItemsetClosure.pp^)=(^lr1ItemsetClosure
                      ^); %f(^Map.pp Action.pp^)=(^actions
                      ^); %f(^Map.pp Uns.pp^)=(^gotos
                      ^)}"
              }
            include T
            include Identifiable.Make(T)

            init ~lr1ItemsetClosure ~actions ~gotos =
                {lr1ItemsetClosure; actions; gotos}
          }

        states = [|
            (* 0 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:0
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [0]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 7 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [1]
                            lr0item, lr1item
                          )
                      ]
              ~actions:
                Map.of_alist Uns [
                    6, Action.ShiftPrefix 1
                  ]
              ~gotos:
                Map.of_alist Uns [
                    10, 2
                    11, 3
                  ]
            (* 1 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:1
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.empty
              ~actions:
                Map.of_alist Uns [
                    2, Action.Reduce 6
                    3, Action.Reduce 6
                    4, Action.Reduce 6
                    5, Action.Reduce 6
                    7, Action.Reduce 6
                  ]
              ~gotos:
                Map.empty Uns
            (* 2 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:2
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 7 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [1]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                      ]
              ~actions:
                Map.of_alist Uns [
                    2, Action.ShiftPrefix 4
                    3, Action.ShiftPrefix 5
                    4, Action.ShiftPrefix 6
                    5, Action.ShiftPrefix 7
                    7, Action.ShiftAccept 8
                  ]
              ~gotos:
                Map.of_alist Uns [
                    8, 9
                    9, 10
                  ]
            (* 3 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:3
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [0]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.empty
              ~actions:
                Map.of_alist Uns [
                    1, Action.ShiftPrefix 11
                  ]
              ~gotos:
                Map.empty Uns
            (* 4 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:4
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.empty
              ~actions:
                Map.of_alist Uns [
                    6, Action.Reduce 0
                  ]
              ~gotos:
                Map.empty Uns
            (* 5 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:5
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.empty
              ~actions:
                Map.of_alist Uns [
                    6, Action.Reduce 1
                  ]
              ~gotos:
                Map.empty Uns
            (* 6 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:6
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.empty
              ~actions:
                Map.of_alist Uns [
                    6, Action.Reduce 2
                  ]
              ~gotos:
                Map.empty Uns
            (* 7 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:7
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.empty
              ~actions:
                Map.of_alist Uns [
                    6, Action.Reduce 3
                  ]
              ~gotos:
                Map.empty Uns
            (* 8 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:8
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 7 prods) ~dot:2
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [1]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.empty
              ~actions:
                Map.of_alist Uns [
                    1, Action.Reduce 7
                  ]
              ~gotos:
                Map.empty Uns
            (* 9 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:9
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:2
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                      ]
              ~actions:
                Map.of_alist Uns [
                    6, Action.ShiftPrefix 1
                  ]
              ~gotos:
                Map.of_alist Uns [
                    10, 12
                  ]
            (* 10 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:10
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:2
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                      ]
              ~actions:
                Map.of_alist Uns [
                    6, Action.ShiftPrefix 1
                  ]
              ~gotos:
                Map.of_alist Uns [
                    10, 13
                  ]
            (* 11 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:11
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8 prods) ~dot:2
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [0]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.empty
              ~actions:
                Map.of_alist Uns [
                    0, Action.Reduce 8
                  ]
              ~gotos:
                Map.empty Uns
            (* 12 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:12
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:3
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                      ]
              ~actions:
                Map.of_alist Uns [
                    2, Action.Reduce 4
                    3, Action.Reduce 4
                    4, Action.Reduce 4
                    5, Action.Reduce 4
                    7, Action.Reduce 4
                  ]
              ~gotos:
                Map.of_alist Uns [
                    8, 9
                    9, 10
                  ]
            (* 13 *) State.init
              ~lr1ItemsetClosure:
                Lr1ItemsetClosure.init
                  ~index:13
                  ~kernel:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:1
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5 prods) ~dot:3
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [2; 3; 4; 5; 7]
                            lr0item, lr1item
                          )
                      ]
                  ~added:
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3 prods) ~dot:0
                            let lr1item = Lr1Item.init ~lr0item ~follow:
                                Ordset.of_list Uns [6]
                            lr0item, lr1item
                          )
                      ]
              ~actions:
                Map.of_alist Uns [
                    2, Action.ShiftPrefix 4
                    3, Action.ShiftPrefix 5
                    4, Action.Reduce 5
                    5, Action.Reduce 5
                    7, Action.Reduce 5
                  ]
              ~gotos:
                Map.of_alist Uns [
                    8, 9
                    9, 10
                  ]
          |]
      }

    Token = {
        T = {
            type t: t =
              | EPSILON # "ε"
              | PSEUDO_END # "⊥"
              | STAR # "*"
              | SLASH # "/"
              | PLUS # "+"
              | MINUS # "-"
              | INT of Zint.t
              | EOI

            index = function
              | EPSILON -> 0
              | PSEUDO_END -> 1
              | STAR -> 2
              | SLASH -> 3
              | PLUS -> 4
              | MINUS -> 5
              | INT _ -> 6
              | EOI -> 7

            hash_fold t state =
                state |> Uns.hash_fold (index t)

            cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            spec t =
                Array.get (index t) Spec.symbols

            pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          }
        include T
        include Identifiable.Make(T)
      }

    Nonterm = {
        T = {
            type t: t =
              | MulOp of Token.t
              | AddOp of Token.t
              | Expr of Zint.t
              | Answer of Zint.t
              | Answer' of Zint.t

            index = function
              | MulOp _ -> 8
              | AddOp _ -> 9
              | Expr _ -> 10
              | Answer _ -> 11
              | Answer' _ -> 12

            hash_fold t state =
                state |> Uns.hash_fold (index t)

            cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            spec t =
                Array.get (index t) Spec.symbols

            pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          }
        include T
        include Identifiable.Make(T)
      }

    Symbol = {
        T = {
            type t: t =
              | Token of Token.t
              | Nonterm of Nonterm.t

            index = function
              | Token token -> Token.index token
              | Nonterm nonterm -> Nonterm.index nonterm

            hash_fold t state =
                state |> Uns.hash_fold (index t)

            cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            spec = function
              | Token token -> Token.spec token
              | Nonterm nonterm -> Nonterm.spec nonterm

            pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          }
        include T
        include Identifiable.Make(T)
      }

    State = {
        T = {
            type t: t = uns

            hash_fold t state =
                state |> Uns.hash_fold t

            cmp t0 t1 =
                Uns.cmp t0 t1

            spec t =
                Array.get t Spec.states

            pp t formatter =
                formatter |> Uns.pp t
          }
        include T
        include Identifiable.Make(T)

        init state_index =
            state_index
      }

    Stack = {
        Elm = {
            T = {
                type t: t = {
                    symbol: Symbol.t;
                    state: State.t;
                  }

                hash_fold {symbol; state} hash_state =
                    hash_state
                      |> Symbol.hash_fold symbol
                      |> State.hash_fold state

                cmp {symbol=symbol0; state=state0} {symbol=symbol1; state=state1} =
                    let open Cmp
                    match State.cmp state0 state1 with
                      | Lt -> Lt
                      | Eq -> Symbol.cmp symbol0 symbol1
                      | Gt -> Gt

                let pp {symbol; state} formatter =
                    formatter |> Fmt.fmt "{%f(^Symbol.pp^)=(^symbol^); %f(^State.pp^)=(^state^)}"
              }
            include T
            include Identifiable.Make(T)

            init ~symbol ~state =
                {symbol; state}
          }

        type t: t = list Elm.t

        fmt ?(alt=false) ?(width=0) t formatter =
            formatter |> List.fmt ~alt ~width Elm.pp t

        pp t formatter =
            formatter |> fmt t

        Reduction = {
            T = {
                type stack: stack = t
                type t: t = uns
                type callback: callback = stack -> Symbol.t * stack

                hash_fold t state =
                    state |> Uns.hash_fold t

                cmp t0 t1 =
                    Uns.cmp t0 t1

                pp t formatter =
                    formatter |> Uns.pp t
              }
            include T
            include Identifiable.Make(T)

            callbacks = [|
                (* 0 *) function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (MulOp (
                  # ________________________________________________________________________________
                  [:"./Example_b.hmh":10:4+11]STAR[:]
                  # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                  )), tl__hocc__
                  | _ -> not_reached ()
                (* 1 *) function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (MulOp (
                  # ________________________________________________________________________________
                  [:"./Example_b.hmh":11:4+11]SLASH[:]
                  # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                  )), tl__hocc__
                  | _ -> not_reached ()
                (* 2 *) function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (AddOp (
                  # ________________________________________________________________________________
                  [:"./Example_b.hmh":17:4+11]PLUS[:]
                  # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                  )), tl__hocc__
                  | _ -> not_reached ()
                (* 3 *) function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (AddOp (
                  # ________________________________________________________________________________
                  [:"./Example_b.hmh":18:4+11]MINUS[:]
                  # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                  )), tl__hocc__
                  | _ -> not_reached ()
                (* 4 *) function
                  | {symbol=Symbol.Nonterm (Expr e1); _}
                  :: {symbol=Symbol.Nonterm (MulOp op); _}
                  :: {symbol=Symbol.Nonterm (Expr e0); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  # ________________________________________________________________________________
                  [:"./Example_b.hmh":23:8+0]match op with
          | STAR -> Zint.(e0 * e1)
          | SLASH -> Zint.(e0 / e1)
          | _ -> not_reached ()[:]
                  # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                  )), tl__hocc__
                  | _ -> not_reached ()
                (* 5 *) function
                  | {symbol=Symbol.Nonterm (Expr e1); _}
                  :: {symbol=Symbol.Nonterm (AddOp op); _}
                  :: {symbol=Symbol.Nonterm (Expr e0); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  # ________________________________________________________________________________
                  [:"./Example_b.hmh":28:8+0]match op with
          | PLUS -> Zint.(e0 + e1)
          | MINUS -> Zint.(e0 - e1)
          | _ -> not_reached ()[:]
                  # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                  )), tl__hocc__
                  | _ -> not_reached ()
                (* 6 *) function
                  | {symbol=Symbol.Token (INT x); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  # ________________________________________________________________________________
                  [:"./Example_b.hmh":32:4+13]x[:]
                  # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                  )), tl__hocc__
                  | _ -> not_reached ()
                (* 7 *) function
                  | _
                  :: {symbol=Symbol.Nonterm (Expr e); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Answer (
                  # ________________________________________________________________________________
                  [:"./Example_b.hmh":36:4+18]e[:]
                  # ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                  )), tl__hocc__
                  | _ -> not_reached ()
                (* 8 *) fn _stack -> not_reached ()
              |]

            callback t =
                Array.get t callbacks

            init callback_index =
                callback_index
          }

        shift ~symbol ~state t =
            (Elm.init ~symbol ~state) :: t

        # goto: Symbol.t -> t -> t
        goto symbol t =
            match t with
              | [] -> not_reached ()
              | Elm.{state; _} :: _ ->
                let symbol_index = Symbol.index symbol
                let Spec.State.{gotos; _} = Array.get state Spec.states
                let state' = Map.get_hlt symbol_index gotos |> State.init
                shift ~symbol ~state:state' t

        reduce ~reduction t =
            let callback = Reduction.callback reduction
            let symbol, t' = callback t
            goto symbol t'
      }

    Status = {
        T = {
            type t: t =
              | ShiftPrefix of Token.t * State.t
              | ShiftAccept of Token.t * State.t
              | Reduce of Token.t * Stack.Reduction.t
              | Prefix
              | Accept of Nonterm.t
              | Reject of Token.t

            let constructor_index = function
              | ShiftPrefix _ -> 0
              | ShiftAccept _ -> 1
              | Reduce _ -> 2
              | Prefix -> 3
              | Accept _ -> 4
              | Reject _ -> 5

            let hash_fold t state =
                state
                  |> Uns.hash_fold (constructor_index t)
                  |> fn hash_state ->
                    match t with
                      | ShiftPrefix (token, state)
                      | ShiftAccept (token, state) ->
                        hash_state |> State.hash_fold state |> Token.hash_fold token
                      | Reduce (token, reduction) ->
                        hash_state |> Stack.Reduction.hash_fold reduction |> Token.hash_fold token
                      | Prefix -> hash_state
                      | Accept nonterm -> hash_state |> Nonterm.hash_fold nonterm
                      | Reject token -> hash_state |> Token.hash_fold token

            let cmp t0 t1 =
                let open Cmp
                match Uns.cmp (constructor_index t0) (constructor_index t1) with
                  | Lt -> Lt
                  | Eq ->
                    match t0, t1 with
                      | ShiftPrefix (token0, state0), ShiftPrefix (token1, state1)
                      | ShiftAccept (token0, state0), ShiftAccept (token1, state1) ->
                        match State.cmp state0 state1 with
                          | Lt -> Lt
                          | Eq -> Token.cmp token0 token1
                          | Gt -> Gt
                      | Reduce (token0, reduction0), Reduce (token1, reduction1) ->
                        match Stack.Reduction.cmp reduction0 reduction1 with
                          | Lt -> Lt
                          | Eq -> Token.cmp token0 token1
                          | Gt -> Gt
                      | Prefix, Prefix -> Eq
                      | Accept nonterm0, Accept nonterm1 -> Nonterm.cmp nonterm0 nonterm1
                      | Reject token0, Reject token1 -> Token.cmp token0 token1
                      | _, _ -> not_reached ()
                  | Gt -> Gt

            pp t formatter =
                formatter
                  |> fn formatter ->
                    match t with
                      | ShiftPrefix (token, state) ->
                        formatter
                          |> Fmt.fmt "ShiftPrefix (%f(^Token.pp^)(^token^), %f(^State.pp^)(^state
                          ^))"
                      | ShiftAccept (token, state) ->
                        formatter
                          |> Fmt.fmt "ShiftAccept (%f(^Token.pp^)(^token^), %f(^State.pp^)(^state
                          ^))"
                      | Reduce reduction ->
                        formatter
                          |> Fmt.fmt "Reduce (%f(^Token.pp^)(^token^), %f(^Stack.Reduction.pp
                          ^)(^reduction^))"
                      | Prefix -> formatter |> Fmt.fmt "Prefix"
                      | Accept nonterm -> formatter |> Fmt.fmt "Accept %f(^Nonterm.pp^)(^nonterm^)"
                      | Reject token -> formatter |> Fmt.fmt "Reject %f(^Token.pp^)(^token^)"
          }
        include T
        include Identifiable.Make(T)
      }

    type t: t = {
        stack: Stack.t
        status: Status.t
      }

    Start = {
        Answer = {
            boi = {
                stack=[{
                    symbol=Token Token.EPSILON
                    state=State.init 0
                  }]
                status=Prefix
              }
          }
      }

    feed token = function
      | {stack={state; _} :: _; status=Prefix} as t ->
        let token_index = Token.index token
        let Spec.State.{actions; _} = Array.get state Spec.states
        let status = match Map.get token_index actions with
          | Some (Spec.Action.ShiftPrefix state') -> Status.ShiftPrefix (token, state')
          | Some (Spec.Action.ShiftAccept state') -> Status.ShiftAccept (token, state')
          | Some (Spec.Action.Reduce prod_index) ->
            let Spec.Prod.{callback=callback_index; _} = Array.get prod_index Spec.prods
            let reduction = Stack.Reduction.init callback_index
            Status.Reduce (token, reduction)
          | None -> Status.Reject token
        {t with status}
      | _ -> not_reached ()

    step {stack; status} =
        let open Status
        match status with
          | ShiftPrefix (token, state) -> {stack=shift token state stack; status=Prefix}
          | ShiftAccept (token, state) ->
            # Shift, perform the ⊥ reduction, and extract the accepted symbol from the stack.
            let stack = shift token state stack
            let pseudo_end_index = Token.index Token.PSEUDO_END
            let Spec.State.{actions; _} = Array.get state Spec.states
            match Map.get_hlt pseudo_end_index actions with
              | Spec.Action.Reduce prod_index ->
                let Spec.Prod.{callback=callback_index; _} = Array.get prod_index Spec.prods
                let reduction = Stack.Reduction.init callback_index
                let stack = Stack.reduce ~reduction stack
                match stack with
                  | [] -> not_reached ()
                  | {symbol=Token _; _} :: _ -> not_reached ()
                  | {symbol=Nonterm nonterm; _} :: _ -> {stack=[]; status=Accept nonterm}
              | _ -> not_reached ()
          | Reduce (token, reduction) ->
            feed token {stack=Stack.reduce ~reduction stack; status=Prefix}
          | _ -> not_reached ()

    # walk: t -> t
    rec walk ({status; _} as t) =
        let open Status
        match status with
          | ShiftPrefix _
          | ShiftAccept _
          | Reduce _ -> t |> step |> walk
          | Prefix
          | Accept _
          | Reject _ -> t

    next token ({status; _} as t) =
        match status with
          | Status.Prefix -> t |> feed token |> walk
          | _ -> not_reached ()
  }[:"./Example_b.hmh":36:0+23]

# Tokenize `s`, e.g. "2 + 3 * 4", and append an `EOI` token.
tokenize s =
    s |> String.split_rev ~f:(fn cp -> Codepoint.(cp = ' '))
      |> List.rev_filter ~f:(fn s -> not (String.is_empty s))
      |> List.rev_map ~f:fn s ->
        let open Token
        match s with
          | "*" -> STAR
          | "/" -> SLASH
          | "+" -> PLUS
          | "-" -> MINUS
          | _ -> INT (Zint.of_string s)
      |> List.push Token.EOI
      |> List.rev

# Calculate the result of the arithmetic expression expressed in `s`, e.g. "2 + 3 * 4".
calculate s =
    let {status; _} = List.fold_until (tokenize s) ~init:Start.Answer.boi ~f:fn parser tok ->
        let {status; _} as parser' = Start.Answer.next tok parser
        let done = match status with
          | Prefix -> false
          | Accept _
          | Error _ -> true
          | _ -> not_reached ()
        parser', done
    match status with
      | Accept (Answer answer) -> answer
      | Prefix _ -> halt "Partial input"
      | Error _ -> halt "Parse error"
      | _ -> not_reached ()

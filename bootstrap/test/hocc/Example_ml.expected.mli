(* This file was generated by `hocc` based on "Example_ml.hmhi" *)
open! Basis
open! Basis.Rudiments

(* Export the parser API so that alternatives to `calculate` can be implemented. `hocc` expands to a
 * module signature. *)
include sig
    module Spec : sig
        module Algorithm : sig
            type t =
              | Lr1 (** LR(1) algorithm. *)
              | Ielr1 (** IELR(1) algorithm. *)
              | Pgm1 (** PGM(1) algorithm. *)
              | Lalr1 (** LALR(1) algorithm. *)

            include IdentifiableIntf.S with type t := t
          end

        val algorithm: Algorithm.t
          (** Algorithm used to generate parser. *)

        module Assoc : sig
            type t =
              | Left
              | Right

            include IdentifiableIntf.S with type t := t
          end

        module Prec : sig
            type t = {
                index: uns; (* Index in `precs` array. *)
                name: string;
                assoc: Assoc.t option;
                doms: (uns, Uns.cmper_witness) Ordset.t; (* Indices in `precs` array of dominator
                                                          * precedences. *)
              }

            include IdentifiableIntf.S with type t := t
          end

        val precs: Prec.t array
          (** Array of precedences, where each element's `index` field corresponds to the element's
              array index. *)

        module Prod : sig
            type t = {
                index: uns; (* Index in `prods` array. *)
                lhs_index: uns;
                rhs_indexes: uns array;
                prec: Prec.t option;
                callback: uns; (* Index of reduction callback in `Stack.Reduction.callbacks`. *)
              }

            include IdentifiableIntf.S with type t := t
          end

        val prods: Prod.t array
          (** Array of productions, where each element's `index` field corresponds to the element's
              array index. *)

        module Symbol : sig
            type t = {
                index: uns; (* Index in `symbols` array. *)
                name: string;
                prec: Prec.t option;
                alias: string option;
                start: bool;
                prods: (Prod.t, Prod.cmper_witness) Ordset.t; (* empty ≡ token *)
                first: (uns, Uns.cmper_witness) Ordset.t;
                follow: (uns, Uns.cmper_witness) Ordset.t;
              }

            include IdentifiableIntf.S with type t := t
          end

        val symbols: Symbol.t array
          (** Array of symbols, where each element's `index` field corresponds to the element's
              array index. *)

        module Lr0Item : sig
            type t = {
                prod: Prod.t;
                dot: uns;
              }

            include IdentifiableIntf.S with type t := t
          end

        module Lr1Item : sig
            type t = {
                lr0item: Lr0Item.t;
                follow: (uns, Uns.cmper_witness) Ordset.t;
              }

            include IdentifiableIntf.S with type t := t
          end

        module Lr1Itemset : sig
            type t = (Lr0Item.t, Lr1Item.t, Lr0Item.cmper_witness) Ordmap.t

            include IdentifiableIntf.S with type t := t
          end

        module Lr1ItemsetClosure : sig
            type t = {
                index: uns; (* Index of corresponding `State.t` in `states` array. *)
                kernel: Lr1Itemset.t;
                added: Lr1Itemset.t;
              }

            include IdentifiableIntf.S with type t := t
          end

        module Action : sig
            type t =
              | ShiftPrefix of uns (* `states` index. *)
              | ShiftAccept of uns (* `states` index. *)
              | Reduce of uns (* `prods` index. *)

            include IdentifiableIntf.S with type t := t
          end

        module State : sig
            type t = {
                lr1ItemsetClosure: Lr1ItemsetClosure.t;
                actions: (uns, Action.t, Uns.cmper_witness) Map.t;
                gotos: (uns, uns, Uns.cmper_witness) Map.t;
              }

            include IdentifiableIntf.S with type t := t
          end

        val states: State.t array
          (** Array of CFSM states, where each element's `lr1ItemsetClosure.index` field corresponds
              to the element's array index. *)
      end

    module Token : sig
        type t =
          | EPSILON (* "ε" *)
          | PSEUDO_END (* "⊥" *)
          | STAR (* "*" *)
          | SLASH (* "/" *)
          | PLUS (* "+" *)
          | MINUS (* "-" *)
          | INT of Zint.t
          | EOI

        include IdentifiableIntf.S with type t := t

        val spec: t -> Spec.Symbol.t
      end

    module Nonterm : sig
        type t =
          | MulOp of Token.t
          | AddOp of Token.t
          | Expr of Zint.t
          | Answer of Zint.t
          | Answer' of Zint.t

        include IdentifiableIntf.S with type t := t

        val spec: t -> Spec.Symbol.t
      end

    module Symbol : sig
        type t =
          | Token of Token.t
          | Nonterm of Nonterm.t

        include IdentifiableIntf.S with type t := t

        val spec: t -> Spec.Symbol.t
      end

    module State : sig
        type t = uns

        include IdentifiableIntf.S with type t := t

        val spec: t -> Spec.State.t
      end

    module Stack : sig
        module Elm : sig
            type t = {
                symbol: Symbol.t;
                state: State.t;
              }

            include IdentifiableIntf.S with type t := t
          end

        type t = Elm.t list

        val pp: t -> (module Fmt.Formatter) -> (module Fmt.Formatter)
        val fmt: ?alt:bool -> ?width:uns -> t -> (module Fmt.Formatter) -> (module Fmt.Formatter)

        module Reduction : sig
            type stack = t
            type t
            type callback = stack -> Symbol.t * stack

            include IdentifiableIntf.S with type t := t

            val callbacks: callback array
              (** Array of reduction callback functions containing embedded parser code. *)

            val callback: t -> callback
          end

        val shift: symbol:Symbol.t -> state:State.t -> t -> t
          (** Perform a shift. *)

        val reduce: reduction:Reduction.t -> t -> t
          (** Perform a reduction. *)
      end

    module Status : sig
        type t =
          (* `feed`/`step` may produce these variants; `next` fast-forwards over them. *)
          | ShiftPrefix of Token.t * State.t
          | ShiftAccept of Token.t * State.t
          | Reduce of Token.t * Stack.Reduction.t
          (* Common variants. *)
          | Prefix (** Valid parse prefix; more input needed. *)
          | Accept of Nonterm.t (** Successful parse result. *)
          | Reject of Token.t (** Syntax error due to unexpected token. *)

        include IdentifiableIntf.S with type t := t
      end

    type t = {
        stack: Stack.t;
        status: Status.t;
      }

    module Start : sig
        module Answer : sig
            val boi: t
          end
      end

    val feed: Token.t -> t -> t
      (** `feed token t` returns a result with status in {`ShiftPrefix`, `ShiftAccept`, `Reduce`,
          `Reject`}. `t.status` must be `Prefix`. *)

    val step: t -> t
      (** `step t` returns the result of applying one state transition to `t`. `t.status` must be in
          {`ShiftPrefix`, `ShiftAccept`, `Reduce`}. *)

    val next: Token.t -> t -> t
      (** `next token t` calls `feed token t` and fast-forwards via `step` calls to return a result
          with status in {`Prefix`, `Accept`, `Reject`}. `t.status` must be `Prefix`. *)
  end
#7 "./Example_ml.hmhi"

val calculate: string -> Zint.t
  (** Calculate the result of a simple arithmetic expression comprising non-negative integers and
      `+`, `-`, `*`, and `/` operators. Tokens must be separated by one or more spaces. *)

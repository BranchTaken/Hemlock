(* This file was generated by `hocc` based on "Example_ml.hmh" *)
open Basis
open! Basis.Rudiments

(* Specify the parser. `hocc ...` expands to a module implementation, `{ ... }`. *)
include struct
    module Spec = struct
        module Algorithm = struct
            module T = struct
                type t =
                  | Lr1
                  | Ielr1
                  | Pgm1
                  | Lalr1

                let index = function
                  | Lr1 -> 0L
                  | Ielr1 -> 1L
                  | Pgm1 -> 2L
                  | Lalr1 -> 3L

                let hash_fold t state =
                    state |> Uns.hash_fold (index t)

                let cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                let to_string = function
                  | Lr1 -> "Lr1"
                  | Ielr1 -> "Ielr1"
                  | Pgm1 -> "Pgm1"
                  | Lalr1 -> "Lalr1"

                let pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              end
            include T
            include Identifiable.Make(T)
          end

        let algorithm = Algorithm.Lr1

        module Assoc = struct
            module T = struct
                type t =
                  | Left
                  | Right
                  | Nonassoc

                let index = function
                  | Left -> 0L
                  | Right -> 1L
                  | Nonassoc -> 2L

                let hash_fold t state =
                    state |> Uns.hash_fold (index t)

                let cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                let to_string = function
                  | Left -> "Left"
                  | Right -> "Right"
                  | Nonassoc -> "Nonassoc"

                let pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              end
            include T
            include Identifiable.Make(T)
          end

        module PrecSet = struct
            module T = struct
                type t = {
                    index: uns;
                    names: string array;
                    assoc: Assoc.t option;
                    doms: Bitset.t;
                  }

                let index {index; _} =
                    index

                let hash_fold t state =
                    state |> Uns.hash_fold (index t)

                let cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                let pp {index; names; assoc; doms} formatter =
                    formatter
                      |> Fmt.fmt "{index=" |> Uns.pp index
                      |> Fmt.fmt "; names=" |> Array.pp String.pp names
                      |> Fmt.fmt "; assoc=" |> Option.pp Assoc.pp assoc
                      |> Fmt.fmt "; doms=" |> Bitset.pp doms
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~index ~names ~assoc ~doms =
                {index; names; assoc; doms}
          end

        let prec_sets = [|
            PrecSet.init ~index:0L ~names:[|"mul"|] ~assoc:(Some Left) ~doms:(Bitset.empty);
            PrecSet.init ~index:1L ~names:[|"add"|] ~assoc:(Some Left) ~doms:(Bitset.singleton 0L)
          |]

        module Prec = struct
            module T = struct
                type t = {
                    name_index: uns;
                    prec_set_index: uns;
                  }

                let index {prec_set_index; _} =
                    prec_set_index

                let hash_fold t state =
                    state |> Uns.hash_fold (index t)

                let cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                let pp {name_index; prec_set_index} formatter =
                    formatter
                      |> Fmt.fmt "{name_index=" |> Uns.pp name_index
                      |> Fmt.fmt "; prec_set_index=" |> Uns.pp prec_set_index
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~name_index ~prec_set_index =
                {name_index; prec_set_index}
          end

        module Prod = struct
            module T = struct
                type t = {
                    index: uns;
                    lhs_index: uns;
                    rhs_indexes: uns array;
                    prec: Prec.t option;
                    callback: uns;
                  }

                let hash_fold {index; _} state =
                    Uns.hash_fold index state

                let cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                let pp {index; lhs_index; rhs_indexes; prec; callback} formatter =
                    formatter
                      |> Fmt.fmt "{index=" |> Uns.pp index
                      |> Fmt.fmt "; lhs_index=" |> Uns.pp lhs_index
                      |> Fmt.fmt "; rhs_indexes=" |> Array.pp Uns.pp rhs_indexes
                      |> Fmt.fmt "; prec=" |> Option.pp Prec.pp prec
                      |> Fmt.fmt "; callback=" |> Uns.pp callback
                      |> Fmt.fmt "}"
            end
            include T
            include Identifiable.Make(T)

            let init ~index ~lhs_index ~rhs_indexes ~prec ~callback =
                {index; lhs_index; rhs_indexes; prec; callback}
          end

        let prods = [|
            Prod.init ~index:0L ~lhs_index:8L ~rhs_indexes:[|2L|]
              ~prec:None ~callback:0L;
            Prod.init ~index:1L ~lhs_index:8L ~rhs_indexes:[|3L|]
              ~prec:None ~callback:1L;
            Prod.init ~index:2L ~lhs_index:9L ~rhs_indexes:[|4L|]
              ~prec:None ~callback:2L;
            Prod.init ~index:3L ~lhs_index:9L ~rhs_indexes:[|5L|]
              ~prec:None ~callback:3L;
            Prod.init ~index:4L ~lhs_index:10L ~rhs_indexes:[|10L; 8L; 10L|]
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:0L)) ~callback:4L;
            Prod.init ~index:5L ~lhs_index:10L ~rhs_indexes:[|10L; 9L; 10L|]
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:1L)) ~callback:5L;
            Prod.init ~index:6L ~lhs_index:10L ~rhs_indexes:[|6L|]
              ~prec:None ~callback:6L;
            Prod.init ~index:7L ~lhs_index:11L ~rhs_indexes:[|10L; 7L|]
              ~prec:None ~callback:7L;
            Prod.init ~index:8L ~lhs_index:12L ~rhs_indexes:[|11L; 1L|]
              ~prec:None ~callback:8L
          |]

        module Symbol = struct
            module T = struct
                type t = {
                    index: uns;
                    name: string;
                    prec: Prec.t option;
                    alias: string option;
                    start: bool;
                    prods: (Prod.t, Prod.cmper_witness) Ordset.t;
                    first: Bitset.t;
                    follow: Bitset.t;
                  }

                let hash_fold {index; _} state =
                    Uns.hash_fold index state

                let cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                let pp {index; name; prec; alias; start; prods; first; follow} formatter =
                    formatter
                      |> Fmt.fmt "{index=" |> Uns.pp index
                      |> Fmt.fmt "; name=" |> String.pp name
                      |> Fmt.fmt "; prec=" |> Option.pp Prec.pp prec
                      |> Fmt.fmt "; alias=" |> Option.pp String.pp alias
                      |> Fmt.fmt "; start=" |> Bool.pp start
                      |> Fmt.fmt "; prods=" |> Ordset.pp prods
                      |> Fmt.fmt "; first=" |> Bitset.pp first
                      |> Fmt.fmt "; follow=" |> Bitset.pp follow
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~index ~name ~prec ~alias ~start ~prods ~first ~follow =
                {index; name; prec; alias; start; prods; first; follow}

            let is_nonterm {prods; _} =
                not (Ordset.is_empty prods)
          end

        let symbols = [|
            Symbol.init ~index:0L ~name:"EPSILON"
              ~prec:None ~alias:(Some "ε") ~start:false
              ~prods:(Ordset.empty (module Prod))
              ~first:(Bitset.singleton 0L)
              ~follow:Bitset.empty;
            Symbol.init ~index:1L ~name:"PSEUDO_END"
              ~prec:None ~alias:(Some "⊥") ~start:false
              ~prods:(Ordset.empty (module Prod))
              ~first:(Bitset.singleton 1L)
              ~follow:(Bitset.singleton 0L);
            Symbol.init ~index:2L ~name:"STAR"
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:0L))
              ~alias:(Some "*") ~start:false
              ~prods:(Ordset.empty (module Prod))
              ~first:(Bitset.singleton 2L)
              ~follow:(Bitset.singleton 6L);
            Symbol.init ~index:3L ~name:"SLASH"
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:0L))
              ~alias:(Some "/") ~start:false
              ~prods:(Ordset.empty (module Prod))
              ~first:(Bitset.singleton 3L)
              ~follow:(Bitset.singleton 6L);
            Symbol.init ~index:4L ~name:"PLUS"
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:1L))
              ~alias:(Some "+") ~start:false
              ~prods:(Ordset.empty (module Prod))
              ~first:(Bitset.singleton 4L)
              ~follow:(Bitset.singleton 6L);
            Symbol.init ~index:5L ~name:"MINUS"
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:1L))
              ~alias:(Some "-") ~start:false
              ~prods:(Ordset.empty (module Prod))
              ~first:(Bitset.singleton 5L)
              ~follow:(Bitset.singleton 6L);
            Symbol.init ~index:6L ~name:"INT"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.empty (module Prod))
              ~first:(Bitset.singleton 6L)
              ~follow:(Bitset.of_nat (Nat.of_string "0xbcn"));
            Symbol.init ~index:7L ~name:"EOI"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.empty (module Prod))
              ~first:(Bitset.singleton 7L)
              ~follow:(Bitset.singleton 1L);
            Symbol.init ~index:8L ~name:"MulOp"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list (module Prod) [
                Array.get 0L prods;
                Array.get 1L prods;
              ])
              ~first:(Bitset.of_nat (Nat.of_string "0xcn"))
              ~follow:(Bitset.singleton 6L);
            Symbol.init ~index:9L ~name:"AddOp"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list (module Prod) [
                Array.get 2L prods;
                Array.get 3L prods;
              ])
              ~first:(Bitset.of_nat (Nat.of_string "0x30n"))
              ~follow:(Bitset.singleton 6L);
            Symbol.init ~index:10L ~name:"Expr"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list (module Prod) [
                Array.get 4L prods;
                Array.get 5L prods;
                Array.get 6L prods;
              ])
              ~first:(Bitset.singleton 6L)
              ~follow:(Bitset.of_nat (Nat.of_string "0xbcn"));
            Symbol.init ~index:11L ~name:"Answer"
              ~prec:None ~alias:None ~start:true
              ~prods:(Ordset.singleton (module Prod) (Array.get 7L prods))
              ~first:(Bitset.singleton 6L)
              ~follow:(Bitset.singleton 1L);
            Symbol.init ~index:12L ~name:"Answer'"
              ~prec:None ~alias:None ~start:true
              ~prods:(Ordset.singleton (module Prod) (Array.get 8L prods))
              ~first:(Bitset.singleton 6L)
              ~follow:(Bitset.singleton 0L)
          |]

        module Lr0Item = struct
            module T = struct
                type t = {
                    prod: Prod.t;
                    dot: uns;
                  }

                let hash_fold {prod; dot} state =
                    state
                      |> Prod.hash_fold prod
                      |> Uns.hash_fold dot

                let cmp {prod=p0; dot=d0} {prod=p1; dot=d1} =
                    let open Cmp in
                    match Prod.cmp p0 p1 with
                      | Lt -> Lt
                      | Eq -> Uns.cmp d0 d1
                      | Gt -> Gt

                let pp {prod; dot} formatter =
                    formatter
                      |> Fmt.fmt "{prod=" |> Prod.pp prod
                      |> Fmt.fmt "; dot=" |> Uns.pp dot
                      |> Fmt.fmt "}"
            end
            include T
            include Identifiable.Make(T)

            let init ~prod ~dot =
                {prod; dot}
          end

        module Lr1Item = struct
            module T = struct
                type t = {
                    lr0item: Lr0Item.t;
                    follow: Bitset.t;
                  }

                let hash_fold {lr0item; follow} state =
                    state
                      |> Lr0Item.hash_fold lr0item
                      |> Bitset.hash_fold follow

                let cmp {lr0item=l0; follow=f0} {lr0item=l1; follow=f1} =
                    let open Cmp in
                    match Lr0Item.cmp l0 l1 with
                      | Lt -> Lt
                      | Eq -> Bitset.cmp f0 f1
                      | Gt -> Gt

                let pp {lr0item; follow} formatter =
                    formatter
                      |> Fmt.fmt "{lr0item=" |> Lr0Item.pp lr0item
                      |> Fmt.fmt "; follow=" |> Bitset.pp follow
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~lr0item ~follow =
                {lr0item; follow}

            (* The concatenation of the RHS symbols to the right of the dot and the follow set
             * comprise an ordered sequence of symbols to be expected. Merge-fold the symbols' first
             * sets (excluding "ε"), until a preceding symbol's first set does not contain "ε".
             * Similarly, if all symbols contain "ε", merge the follow set (excluding "ε"). Merge
             * "ε" if all symbols' first sets and the follow set contain "ε". *)
            let first symbols {lr0item; follow} =
                let epsilon = Array.get 0L symbols in
                assert String.(Symbol.(epsilon.name) = "EPSILON");
                let append_symbol_set first merge_epsilon symbol_set = begin
                    let symbol_set_sans_epsilon = Bitset.remove epsilon.index symbol_set in
                    let first' = Bitset.union symbol_set_sans_epsilon first in
                    let contains_epsilon = Bitset.mem epsilon.index symbol_set in
                    let merge_epsilon' = match contains_epsilon with
                      | false -> false
                      | true -> merge_epsilon
                    in
                    first', merge_epsilon'
                  end in
                let rhs_indexes = lr0item.prod.rhs_indexes in
                let rhs_slice = Array.Slice.init ~range:(lr0item.dot =:< Array.length rhs_indexes)
                  rhs_indexes in
                (* Merge-fold RHS symbols' first sets. *)
                let first, merge_epsilon = Array.Slice.fold_until
                  ~init:(Bitset.empty, true)
                  ~f:(fun (first, merge_epsilon) symbol_index ->
                    let symbol = Array.get symbol_index symbols in
                    let first', merge_epsilon' = append_symbol_set first merge_epsilon
                      symbol.first in
                    (first', merge_epsilon'), not merge_epsilon'
                  ) rhs_slice
                in
                (* Append the follow set only if all RHS symbols to the right of the dot contain
                 * "ε". *)
                match merge_epsilon with
                  | false -> first
                  | true -> begin
                    let first', merge_epsilon' = append_symbol_set first merge_epsilon follow in
                    match merge_epsilon' with
                      | false -> first'
                      | true -> Bitset.insert epsilon.index first'
                    end
          end

        module Lr1Itemset = struct
            module T = struct
                type t = (Lr0Item.t, Lr1Item.t, Lr0Item.cmper_witness) Ordmap.t

                let hash_fold t =
                    Ordmap.hash_fold Lr1Item.hash_fold t

                let cmp t0 t1 =
                    Ordmap.cmp Lr1Item.cmp t0 t1

                let pp = Ordmap.pp Lr1Item.pp
              end
            include T
            include Identifiable.Make(T)

            let empty = Ordmap.empty (module Lr0Item)

            let init = Ordmap.of_alist (module Lr0Item)

            let mem Lr1Item.{lr0item; follow} t =
                match Ordmap.get lr0item t with
                  | None -> false
                  | Some Lr1Item.{follow=t_follow; _} -> Bitset.subset t_follow follow

            let insert (Lr1Item.{lr0item; follow} as lr1item) t =
                Ordmap.amend lr0item ~f:(fun lr1item_opt ->
                    match lr1item_opt with
                      | None -> Some lr1item
                      | Some Lr1Item.{follow=t_follow; _} -> begin
                        let follow = Bitset.union follow t_follow in
                        Some (Lr1Item.init ~lr0item ~follow)
                    end
                  ) t
          end

        module Lr1ItemsetClosure = struct
            module T = struct
                type t = {
                    index: uns;
                    kernel: Lr1Itemset.t;
                    added: Lr1Itemset.t lazy_t;
                  }

                let hash_fold {index; _} state =
                    state |> Uns.hash_fold index

                let cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                let pp {index; kernel; _} formatter =
                    formatter
                      |> Fmt.fmt "{index=" |> Uns.pp index
                      |> Fmt.fmt "; kernel=" |> Lr1Itemset.pp kernel
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let added_impl symbols kernel =
                let rec f symbols lr1itemset added = begin
                    match Ordmap.choose lr1itemset with
                      | None -> added
                      | Some (_lr0item, Lr1Item.{lr0item={prod={rhs_indexes; _} as prod; dot}
                      as lr0item; follow}) -> begin
                        let lr1itemset' = Ordmap.remove lr0item lr1itemset in
                        match Uns.(dot < Array.length rhs_indexes) with
                          | false -> begin
                            (* X ::= a· *)
                            f symbols lr1itemset' added
                          end
                          | true -> begin
                            let rhs_symbol_index = Array.get dot rhs_indexes in
                            let rhs_symbol = Array.get rhs_symbol_index symbols in
                            match Symbol.is_nonterm rhs_symbol with
                              | false -> begin
                                (* X ::= a·b *)
                                f symbols lr1itemset' added
                              end
                              | true -> begin
                                (* X ::= a·Ab *)
                                let lhs = rhs_symbol in
                                let follow' = Lr1Item.first symbols
                                  (Lr1Item.init ~lr0item:(Lr0Item.init ~prod ~dot:(succ dot))
                                  ~follow) in
                                let lr1itemset', added' = Ordset.fold ~init:(lr1itemset', added)
                                  ~f:(fun (lr1itemset, added) prod ->
                                    let lr0item = Lr0Item.init ~prod ~dot:0L in
                                    let lr1item = Lr1Item.init ~lr0item ~follow:follow' in
                                    match Lr1Itemset.mem lr1item added with
                                      | true -> lr1itemset, added
                                      | false -> begin
                                        let lr1itemset' = Lr1Itemset.insert lr1item lr1itemset in
                                        let added' = Lr1Itemset.insert lr1item added in
                                        lr1itemset', added'
                                      end
                                  ) lhs.prods in
                                f symbols lr1itemset' added'
                              end
                          end
                      end
                  end in
                f symbols kernel Lr1Itemset.empty

            let added {added; _} =
                Lazy.force added

            let init ~index ~kernel =
                {index; kernel; added=lazy (added_impl symbols kernel)}
          end

        module Action = struct
            module T = struct
                type t =
                  | ShiftPrefix of uns
                  | ShiftAccept of uns
                  | Reduce of uns

                let constructor_index = function
                  | ShiftPrefix _ -> 0L
                  | ShiftAccept _ -> 1L
                  | Reduce _ -> 2L

                let arg_index = function
                  | ShiftPrefix arg_index
                  | ShiftAccept arg_index
                  | Reduce arg_index -> arg_index

                let hash_fold t state =
                    state
                      |> Uns.hash_fold (constructor_index t)
                      |> Uns.hash_fold (arg_index t)

                let cmp t0 t1 =
                    let open Cmp in
                    match Uns.cmp (constructor_index t0) (constructor_index t1) with
                      | Lt -> Lt
                      | Eq -> Uns.cmp (arg_index t0) (arg_index t1)
                      | Gt -> Gt

                let to_string = function
                  | ShiftPrefix state_index -> begin
                    String.Fmt.empty
                    |> Fmt.fmt "ShiftPrefix " |> Uns.pp state_index
                    |> Fmt.to_string
                  end
                  | ShiftAccept state_index -> begin
                    String.Fmt.empty
                    |> Fmt.fmt "ShiftAccept " |> Uns.pp state_index
                    |> Fmt.to_string
                  end
                  | Reduce prod_index -> begin
                    String.Fmt.empty
                    |> Fmt.fmt "Reduce " |> Uns.pp prod_index
                    |> Fmt.to_string
                  end

                let pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              end
            include T
            include Identifiable.Make(T)
          end

        module State = struct
            module T = struct
                type t = {
                    lr1ItemsetClosure: Lr1ItemsetClosure.t;
                    actions: (uns, Action.t, Uns.cmper_witness) Map.t;
                    gotos: (uns, uns, Uns.cmper_witness) Map.t;
                  }

                let hash_fold {lr1ItemsetClosure; _} state =
                    state |> Lr1ItemsetClosure.hash_fold lr1ItemsetClosure

                let cmp {lr1ItemsetClosure=c0; _} {lr1ItemsetClosure=c1; _} =
                    Lr1ItemsetClosure.cmp c0 c1

                let pp {lr1ItemsetClosure; actions; gotos} formatter =
                    formatter
                      |> Fmt.fmt "{lr1ItemsetClosure=" |> Lr1ItemsetClosure.pp lr1ItemsetClosure
                      |> Fmt.fmt "; actions=" |> Map.pp Action.pp actions
                      |> Fmt.fmt "; gotos=" |> Map.pp Uns.pp gotos
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~lr1ItemsetClosure ~actions ~gotos =
                {lr1ItemsetClosure; actions; gotos}
          end

        let states = [|
            (* 0 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:0L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 0L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.ShiftPrefix 1L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (10L, 2L);
                    (11L, 3L);
                  ]
              );
            (* 1 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:1L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (2L, Action.Reduce 6L);
                    (3L, Action.Reduce 6L);
                    (4L, Action.Reduce 6L);
                    (5L, Action.Reduce 6L);
                    (7L, Action.Reduce 6L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 2 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:2L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 7L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 1L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (2L, Action.ShiftPrefix 4L);
                    (3L, Action.ShiftPrefix 5L);
                    (4L, Action.ShiftPrefix 6L);
                    (5L, Action.ShiftPrefix 7L);
                    (7L, Action.ShiftAccept 8L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (8L, 9L);
                    (9L, 10L);
                  ]
              );
            (* 3 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:3L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 0L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (1L, Action.ShiftPrefix 11L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 4 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:4L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 6L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.Reduce 0L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 5 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:5L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 6L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.Reduce 1L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 6 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:6L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 6L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.Reduce 2L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 7 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:7L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 6L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.Reduce 3L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 8 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:8L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 7L prods) ~dot:2L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 1L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (1L, Action.Reduce 7L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 9 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:9L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:2L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.ShiftPrefix 1L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (10L, 12L);
                  ]
              );
            (* 10 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:10L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:2L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.ShiftPrefix 1L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (10L, 13L);
                  ]
              );
            (* 11 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:11L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8L prods) ~dot:2L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.singleton 0L
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (0L, Action.Reduce 8L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 12 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:12L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:3L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (2L, Action.Reduce 4L);
                    (3L, Action.Reduce 4L);
                    (4L, Action.Reduce 4L);
                    (5L, Action.Reduce 4L);
                    (7L, Action.Reduce 4L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (8L, 9L);
                    (9L, 10L);
                  ]
              );
            (* 13 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:13L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:3L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Bitset.of_nat (Nat.of_string "0xbcn")
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (2L, Action.ShiftPrefix 4L);
                    (3L, Action.ShiftPrefix 5L);
                    (4L, Action.Reduce 5L);
                    (5L, Action.Reduce 5L);
                    (7L, Action.Reduce 5L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (8L, 9L);
                    (9L, 10L);
                  ]
              );
          |]
      end

    module Token = struct
        module T = struct
            type t =
              | EPSILON (* "ε" *)
              | PSEUDO_END (* "⊥" *)
              | STAR (* "*" *)
              | SLASH (* "/" *)
              | PLUS (* "+" *)
              | MINUS (* "-" *)
              | INT of Zint.t
              | EOI

            let index = function
              | EPSILON -> 0L
              | PSEUDO_END -> 1L
              | STAR -> 2L
              | SLASH -> 3L
              | PLUS -> 4L
              | MINUS -> 5L
              | INT _ -> 6L
              | EOI -> 7L

            let hash_fold t state =
                state |> Uns.hash_fold (index t)

            let cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            let spec t =
                Array.get (index t) Spec.symbols

            let pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          end
        include T
        include Identifiable.Make(T)
      end

    module Nonterm = struct
        module T = struct
            type t =
              | MulOp of Token.t
              | AddOp of Token.t
              | Expr of Zint.t
              | Answer of Zint.t
              | Answer' of Zint.t

            let index = function
              | MulOp _ -> 8L
              | AddOp _ -> 9L
              | Expr _ -> 10L
              | Answer _ -> 11L
              | Answer' _ -> 12L

            let hash_fold t state =
                state |> Uns.hash_fold (index t)

            let cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            let spec t =
                Array.get (index t) Spec.symbols

            let pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          end
        include T
        include Identifiable.Make(T)
      end

    module Symbol = struct
        module T = struct
            type t =
              | Token of Token.t
              | Nonterm of Nonterm.t

            let index = function
              | Token token -> Token.index token
              | Nonterm nonterm -> Nonterm.index nonterm

            let hash_fold t state =
                state |> Uns.hash_fold (index t)

            let cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            let spec = function
              | Token token -> Token.spec token
              | Nonterm nonterm -> Nonterm.spec nonterm

            let pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          end
        include T
        include Identifiable.Make(T)
      end

    module State = struct
        module T = struct
            type t = uns

            let hash_fold t state =
                state |> Uns.hash_fold t

            let cmp t0 t1 =
                Uns.cmp t0 t1

            let spec t =
                Array.get t Spec.states

            let pp t formatter =
                formatter |> Uns.pp t
          end
        include T
        include Identifiable.Make(T)

        let init state_index =
            state_index
      end

    module Stack = struct
        module Elm = struct
            module T = struct
                type t = {
                    symbol: Symbol.t;
                    state: State.t;
                  }

                let hash_fold {symbol; state} hash_state =
                    hash_state
                      |> Symbol.hash_fold symbol
                      |> State.hash_fold state

                let cmp {symbol=symbol0; state=state0} {symbol=symbol1; state=state1} =
                    let open Cmp in
                    match State.cmp state0 state1 with
                      | Lt -> Lt
                      | Eq -> Symbol.cmp symbol0 symbol1
                      | Gt -> Gt

                let pp {symbol; state} formatter =
                    formatter
                      |> Fmt.fmt "{symbol=" |> Symbol.pp symbol
                      |> Fmt.fmt "; state=" |> State.pp state
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~symbol ~state =
                {symbol; state}
          end

        type t = Elm.t list

        let fmt ?(alt=false) ?(width=0L) t formatter =
            formatter |> List.fmt ~alt ~width Elm.pp t

        let pp t formatter =
            formatter |> fmt t

        module Reduction = struct
            module T = struct
                type stack = t
                type t = uns
                type callback = stack -> Symbol.t * stack

                let hash_fold t state =
                    state |> Uns.hash_fold t

                let cmp t0 t1 =
                    Uns.cmp t0 t1

                let pp t formatter =
                    formatter |> Uns.pp t
              end
            include T
            include Identifiable.Make(T)

            let callbacks = [|
                (* 0 *) (function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (MulOp (
                  (*______________________________________________________________________________*)
#10 "./Example_ml.hmh"
STAR
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 1 *) (function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (MulOp (
                  (*______________________________________________________________________________*)
#11 "./Example_ml.hmh"
SLASH
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 2 *) (function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (AddOp (
                  (*______________________________________________________________________________*)
#17 "./Example_ml.hmh"
PLUS
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 3 *) (function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (AddOp (
                  (*______________________________________________________________________________*)
#18 "./Example_ml.hmh"
MINUS
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 4 *) (function
                  | Elm.{symbol=Symbol.Nonterm (Expr e1); _}
                  :: Elm.{symbol=Symbol.Nonterm (MulOp op); _}
                  :: Elm.{symbol=Symbol.Nonterm (Expr e0); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  (*______________________________________________________________________________*)
#23 "./Example_ml.hmh"
match op with
          | STAR -> Zint.(e0 * e1)
          | SLASH -> Zint.(e0 / e1)
          | _ -> not_reached ()
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 5 *) (function
                  | Elm.{symbol=Symbol.Nonterm (Expr e1); _}
                  :: Elm.{symbol=Symbol.Nonterm (AddOp op); _}
                  :: Elm.{symbol=Symbol.Nonterm (Expr e0); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  (*______________________________________________________________________________*)
#28 "./Example_ml.hmh"
match op with
          | PLUS -> Zint.(e0 + e1)
          | MINUS -> Zint.(e0 - e1)
          | _ -> not_reached ()
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 6 *) (function
                  | Elm.{symbol=Symbol.Token (INT x); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  (*______________________________________________________________________________*)
#32 "./Example_ml.hmh"
x
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 7 *) (function
                  | _
                  :: Elm.{symbol=Symbol.Nonterm (Expr e); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Answer (
                  (*______________________________________________________________________________*)
#36 "./Example_ml.hmh"
e
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 8 *) (fun _stack -> not_reached ())
              |]

            let callback t =
                Array.get t callbacks

            let init callback_index =
                callback_index
          end

        let shift ~symbol ~state t =
            (Elm.init ~symbol ~state) :: t

        (* val goto: Symbol.t -> t -> t *)
        let goto symbol t =
            match t with
              | [] -> not_reached ()
              | Elm.{state; _} :: _ ->
                let symbol_index = Symbol.index symbol in
                let Spec.State.{gotos; _} = Array.get state Spec.states in
                let state' = Map.get_hlt symbol_index gotos |> State.init in
                shift ~symbol ~state:state' t

        let reduce ~reduction t =
            let callback = Reduction.callback reduction in
            let symbol, t' = callback t in
            goto symbol t'
      end

    module Status = struct
        module T = struct
            type t =
              | ShiftPrefix of Token.t * State.t
              | ShiftAccept of Token.t * State.t
              | Reduce of Token.t * Stack.Reduction.t
              | Prefix
              | Accept of Nonterm.t
              | Reject of Token.t

            let constructor_index = function
              | ShiftPrefix _ -> 0L
              | ShiftAccept _ -> 1L
              | Reduce _ -> 2L
              | Prefix -> 3L
              | Accept _ -> 4L
              | Reject _ -> 5L

            let hash_fold t state =
                state
                  |> Uns.hash_fold (constructor_index t)
                  |> (fun hash_state ->
                    match t with
                      | ShiftPrefix (token, state)
                      | ShiftAccept (token, state) ->
                        hash_state |> State.hash_fold state |> Token.hash_fold token
                      | Reduce (token, reduction) ->
                        hash_state |> Stack.Reduction.hash_fold reduction |> Token.hash_fold token
                      | Prefix -> hash_state
                      | Accept nonterm -> hash_state |> Nonterm.hash_fold nonterm
                      | Reject token -> hash_state |> Token.hash_fold token
                  )

            let cmp t0 t1 =
                let open Cmp in
                match Uns.cmp (constructor_index t0) (constructor_index t1) with
                  | Lt -> Lt
                  | Eq -> begin
                    match t0, t1 with
                      | ShiftPrefix (token0, state0), ShiftPrefix (token1, state1)
                      | ShiftAccept (token0, state0), ShiftAccept (token1, state1) -> begin
                        match State.cmp state0 state1 with
                          | Lt -> Lt
                          | Eq -> Token.cmp token0 token1
                          | Gt -> Gt
                      end
                      | Reduce (token0, reduction0), Reduce (token1, reduction1)
                      -> begin
                        match Stack.Reduction.cmp reduction0 reduction1 with
                          | Lt -> Lt
                          | Eq -> Token.cmp token0 token1
                          | Gt -> Gt
                      end
                      | Prefix, Prefix -> Eq
                      | Accept nonterm0, Accept nonterm1 -> Nonterm.cmp nonterm0 nonterm1
                      | Reject token0, Reject token1 -> Token.cmp token0 token1
                      | _, _ -> not_reached ()
                  end
                  | Gt -> Gt

            let pp t formatter =
                formatter
                  |> (fun formatter ->
                    match t with
                      | ShiftPrefix (token, state) -> begin
                        formatter
                          |> Fmt.fmt "ShiftPrefix (" |> Token.pp token
                          |> Fmt.fmt ", " |> State.pp state
                          |> Fmt.fmt ")"
                      end
                      | ShiftAccept (token, state) -> begin
                        formatter
                          |> Fmt.fmt "ShiftAccept (" |> Token.pp token
                          |> Fmt.fmt ", " |> State.pp state
                          |> Fmt.fmt ")"
                      end
                      | Reduce (token, reduction) -> begin
                        formatter
                          |> Fmt.fmt "Reduce (" |> Token.pp token
                          |> Fmt.fmt ", " |> Stack.Reduction.pp reduction
                          |> Fmt.fmt ")"
                      end
                      | Prefix -> formatter |> Fmt.fmt "Prefix"
                      | Accept nonterm -> formatter |> Fmt.fmt "Accept " |> Nonterm.pp nonterm
                      | Reject token -> formatter |> Fmt.fmt "Reject " |> Token.pp token
                  )
          end
        include T
        include Identifiable.Make(T)
      end

    type t = {
        stack: Stack.t;
        status: Status.t;
      }

    module Start = struct
        module Answer = struct
            let boi = {
                stack=[{
                    symbol=Token Token.EPSILON;
                    state=State.init 0L;
                  }];
                status=Prefix;
              }
          end
      end

    let feed token = function
      | {stack={state; _} :: _; status=Prefix} as t -> begin
        let token_index = Token.index token in
        let Spec.State.{actions; _} = Array.get state Spec.states in
        let status = match Map.get token_index actions with
          | Some (Spec.Action.ShiftPrefix state') -> Status.ShiftPrefix (token, state')
          | Some (Spec.Action.ShiftAccept state') -> Status.ShiftAccept (token, state')
          | Some (Spec.Action.Reduce prod_index) -> begin
            let Spec.Prod.{callback=callback_index; _} = Array.get prod_index Spec.prods in
            let reduction = Stack.Reduction.init callback_index in
            Status.Reduce (token, reduction)
          end
          | None -> Status.Reject token
        in
        {t with status}
      end
      | _ -> not_reached ()

    let step {stack; status} =
        let open Status in
        match status with
          | ShiftPrefix (token, state) ->
            {stack=Stack.shift ~symbol:(Token token) ~state stack; status=Prefix}
          | ShiftAccept (token, state) -> begin
            (* Shift, perform the ⊥ reduction, and extract the accepted symbol from the stack. *)
            let stack = Stack.shift ~symbol:(Token token) ~state stack in
            let pseudo_end_index = Token.index Token.PSEUDO_END in
            let Spec.State.{actions; _} = Array.get state Spec.states in
            match Map.get_hlt pseudo_end_index actions with
              | Spec.Action.Reduce prod_index -> begin
                let Spec.Prod.{callback=callback_index; _} = Array.get prod_index Spec.prods in
                let reduction = Stack.Reduction.init callback_index in
                let stack = Stack.reduce ~reduction stack in
                match stack with
                  | [] -> not_reached ()
                  | {symbol=Token _; _} :: _ -> not_reached ()
                  | {symbol=Nonterm nonterm; _} :: _ -> {stack=[]; status=Accept nonterm}
              end
              | _ -> not_reached ()
          end
          | Reduce (token, reduction) -> begin
            feed token {stack=Stack.reduce ~reduction stack; status=Prefix}
          end
          | _ -> not_reached ()

    (* val walk: t -> t *)
    let rec walk ({status; _} as t) =
        let open Status in
        match status with
          | ShiftPrefix _
          | ShiftAccept _
          | Reduce _ -> t |> step |> walk
          | Prefix
          | Accept _
          | Reject _ -> t

    let next token ({status; _} as t) =
        match status with
          | Status.Prefix -> t |> feed token |> walk
          | _ -> not_reached ()
  end
#37 "./Example_ml.hmh"

(* Tokenize `s`, e.g. "2 + 3 * 4", and append an `EOI` token. *)
let tokenize s =
    s |> String.split_rev ~f:(fun cp -> Codepoint.(cp = (of_char ' ')))
      |> List.rev_filter ~f:(fun s -> not (String.is_empty s))
      |> List.rev_map ~f:(fun s ->
        let open Token in
        match s with
          | "*" -> STAR
          | "/" -> SLASH
          | "+" -> PLUS
          | "-" -> MINUS
          | _ -> INT (Zint.of_string s)
      )
      |> List.push Token.EOI
      |> List.rev

(* Calculate the result of the arithmetic expression expressed in `s`, e.g. "2 + 3 * 4". *)
let calculate s =
    let {status; _} = List.fold_until (tokenize s) ~init:Start.Answer.boi ~f:(fun parser tok ->
        let {status; _} as parser' = next tok parser in
        let is_done = match status with
          | Prefix -> false
          | Accept _
          | Reject _ -> true
          | _ -> not_reached ()
          in
        parser', is_done
      ) in
    match status with
      | Accept (Answer answer) -> answer
      | Prefix -> halt "Partial input"
      | Reject _ -> halt "Parse error"
      | _ -> not_reached ()

let main () =
    File.Fmt.stdout
      |> Zint.pp (calculate "2 + 3 * 4")
      |> ignore

let _ = main ()

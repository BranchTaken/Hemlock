(* This file was generated by `hocc` based on "Example_ml.hmh" *)
open Basis
open! Basis.Rudiments

(* Specify the parser. `hocc ...` expands to a module implementation, `{ ... }`. *)
include struct
    module Spec = struct
        module Algorithm = struct
            module T = struct
                type t =
                  | Lr1
                  | Ielr1
                  | Pgm1
                  | Lalr1

                let index = function
                  | Lr1 -> 0L
                  | Ielr1 -> 1L
                  | Pgm1 -> 2L
                  | Lalr1 -> 3L

                let hash_fold t state =
                    state |> Uns.hash_fold (index t)

                let cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                let to_string = function
                  | Lr1 -> "Lr1"
                  | Ielr1 -> "Ielr1"
                  | Pgm1 -> "Pgm1"
                  | Lalr1 -> "Lalr1"

                let pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              end
            include T
            include Identifiable.Make(T)
          end

        let algorithm = Algorithm.Lr1

        module Assoc = struct
            module T = struct
                type t =
                  | Left
                  | Right

                let index = function
                  | Left -> 0L
                  | Right -> 1L

                let hash_fold t state =
                    state |> Uns.hash_fold (index t)

                let cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                let to_string = function
                  | Left -> "Left"
                  | Right -> "Right"

                let pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              end
            include T
            include Identifiable.Make(T)
          end

        module PrecSet = struct
            module T = struct
                type t = {
                    index: uns;
                    names: string array;
                    assoc: Assoc.t option;
                    doms: (uns, Uns.cmper_witness) Ordset.t;
                  }

                let index {index; _} =
                    index

                let hash_fold t state =
                    state |> Uns.hash_fold (index t)

                let cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                let pp {index; names; assoc; doms} formatter =
                    formatter
                      |> Fmt.fmt "{index=" |> Uns.pp index
                      |> Fmt.fmt "; names=" |> Array.pp String.pp names
                      |> Fmt.fmt "; assoc=" |> Option.pp Assoc.pp assoc
                      |> Fmt.fmt "; doms=" |> Ordset.pp doms
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~index ~names ~assoc ~doms =
                {index; names; assoc; doms}
          end

        let prec_sets = [|
            PrecSet.init ~index:0L ~names:[|"mul"|] ~assoc:(Some Left) ~doms:(Ordset.empty (module Uns));
            PrecSet.init ~index:1L ~names:[|"add"|] ~assoc:(Some Left) ~doms:(Ordset.singleton (module Uns) 0L)
          |]

        module Prec = struct
            module T = struct
                type t = {
                    name_index: uns;
                    prec_set_index: uns;
                  }

                let index {prec_set_index; _} =
                    prec_set_index

                let hash_fold t state =
                    state |> Uns.hash_fold (index t)

                let cmp t0 t1 =
                    Uns.cmp (index t0) (index t1)

                let pp {name_index; prec_set_index} formatter =
                    formatter
                      |> Fmt.fmt "{name_index=" |> Uns.pp name_index
                      |> Fmt.fmt "; prec_set_index=" |> Uns.pp prec_set_index
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~name_index ~prec_set_index =
                {name_index; prec_set_index}
          end

        module Prod = struct
            module T = struct
                type t = {
                    index: uns;
                    lhs_index: uns;
                    rhs_indexes: uns array;
                    prec: Prec.t option;
                    callback: uns;
                  }

                let hash_fold {index; _} state =
                    Uns.hash_fold index state

                let cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                let pp {index; lhs_index; rhs_indexes; prec; callback} formatter =
                    formatter
                      |> Fmt.fmt "{index=" |> Uns.pp index
                      |> Fmt.fmt "; lhs_index=" |> Uns.pp lhs_index
                      |> Fmt.fmt "; rhs_indexes=" |> Array.pp Uns.pp rhs_indexes
                      |> Fmt.fmt "; prec=" |> Option.pp Prec.pp prec
                      |> Fmt.fmt "; callback=" |> Uns.pp callback
                      |> Fmt.fmt "}"
            end
            include T
            include Identifiable.Make(T)

            let init ~index ~lhs_index ~rhs_indexes ~prec ~callback =
                {index; lhs_index; rhs_indexes; prec; callback}
          end

        let prods = [|
            Prod.init ~index:0L ~lhs_index:8L ~rhs_indexes:[|2L|]
              ~prec:None ~callback:0L;
            Prod.init ~index:1L ~lhs_index:8L ~rhs_indexes:[|3L|]
              ~prec:None ~callback:1L;
            Prod.init ~index:2L ~lhs_index:9L ~rhs_indexes:[|4L|]
              ~prec:None ~callback:2L;
            Prod.init ~index:3L ~lhs_index:9L ~rhs_indexes:[|5L|]
              ~prec:None ~callback:3L;
            Prod.init ~index:4L ~lhs_index:10L ~rhs_indexes:[|10L; 8L; 10L|]
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:0L)) ~callback:4L;
            Prod.init ~index:5L ~lhs_index:10L ~rhs_indexes:[|10L; 9L; 10L|]
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:1L)) ~callback:5L;
            Prod.init ~index:6L ~lhs_index:10L ~rhs_indexes:[|6L|]
              ~prec:None ~callback:6L;
            Prod.init ~index:7L ~lhs_index:11L ~rhs_indexes:[|10L; 7L|]
              ~prec:None ~callback:7L;
            Prod.init ~index:8L ~lhs_index:12L ~rhs_indexes:[|11L; 1L|]
              ~prec:None ~callback:8L
          |]

        module Symbol = struct
            module T = struct
                type t = {
                    index: uns;
                    name: string;
                    prec: Prec.t option;
                    alias: string option;
                    start: bool;
                    prods: (Prod.t, Prod.cmper_witness) Ordset.t;
                    first: (uns, Uns.cmper_witness) Ordset.t;
                    follow: (uns, Uns.cmper_witness) Ordset.t;
                  }

                let hash_fold {index; _} state =
                    Uns.hash_fold index state

                let cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                let pp {index; name; prec; alias; start; prods; first; follow} formatter =
                    formatter
                      |> Fmt.fmt "{index=" |> Uns.pp index
                      |> Fmt.fmt "; name=" |> String.pp name
                      |> Fmt.fmt "; prec=" |> Option.pp Prec.pp prec
                      |> Fmt.fmt "; alias=" |> Option.pp String.pp alias
                      |> Fmt.fmt "; start=" |> Bool.pp start
                      |> Fmt.fmt "; prods=" |> Ordset.pp prods
                      |> Fmt.fmt "; first=" |> Ordset.pp first
                      |> Fmt.fmt "; follow=" |> Ordset.pp follow
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~index ~name ~prec ~alias ~start ~prods ~first ~follow =
                {index; name; prec; alias; start; prods; first; follow}
          end

        let symbols = [|
            Symbol.init ~index:0L ~name:"EPSILON"
              ~prec:None ~alias:(Some "ε") ~start:false
              ~prods:(Ordset.empty (module Prod)) ~first:(Ordset.singleton (module Uns) 0L)
              ~follow:(Ordset.empty (module Uns));
            Symbol.init ~index:1L ~name:"PSEUDO_END"
              ~prec:None ~alias:(Some "⊥") ~start:false
              ~prods:(Ordset.empty (module Prod)) ~first:(Ordset.singleton (module Uns) 1L)
              ~follow:(Ordset.singleton (module Uns) 0L);
            Symbol.init ~index:2L ~name:"STAR"
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:0L)) ~alias:(Some "*") ~start:false
              ~prods:(Ordset.empty (module Prod)) ~first:(Ordset.singleton (module Uns) 2L)
              ~follow:(Ordset.singleton (module Uns) 6L);
            Symbol.init ~index:3L ~name:"SLASH"
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:0L)) ~alias:(Some "/") ~start:false
              ~prods:(Ordset.empty (module Prod)) ~first:(Ordset.singleton (module Uns) 3L)
              ~follow:(Ordset.singleton (module Uns) 6L);
            Symbol.init ~index:4L ~name:"PLUS"
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:1L)) ~alias:(Some "+") ~start:false
              ~prods:(Ordset.empty (module Prod)) ~first:(Ordset.singleton (module Uns) 4L)
              ~follow:(Ordset.singleton (module Uns) 6L);
            Symbol.init ~index:5L ~name:"MINUS"
              ~prec:(Some (Prec.init ~name_index:0L ~prec_set_index:1L)) ~alias:(Some "-") ~start:false
              ~prods:(Ordset.empty (module Prod)) ~first:(Ordset.singleton (module Uns) 5L)
              ~follow:(Ordset.singleton (module Uns) 6L);
            Symbol.init ~index:6L ~name:"INT"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.empty (module Prod)) ~first:(Ordset.singleton (module Uns) 6L)
              ~follow:(Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]);
            Symbol.init ~index:7L ~name:"EOI"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.empty (module Prod)) ~first:(Ordset.singleton (module Uns) 7L)
              ~follow:(Ordset.singleton (module Uns) 1L);
            Symbol.init ~index:8L ~name:"MulOp"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list (module Prod) [
                Array.get 0L prods;
                Array.get 1L prods;
              ]) ~first:(Ordset.of_list (module Uns) [2L; 3L])
              ~follow:(Ordset.singleton (module Uns) 6L);
            Symbol.init ~index:9L ~name:"AddOp"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list (module Prod) [
                Array.get 2L prods;
                Array.get 3L prods;
              ]) ~first:(Ordset.of_list (module Uns) [4L; 5L])
              ~follow:(Ordset.singleton (module Uns) 6L);
            Symbol.init ~index:10L ~name:"Expr"
              ~prec:None ~alias:None ~start:false
              ~prods:(Ordset.of_list (module Prod) [
                Array.get 4L prods;
                Array.get 5L prods;
                Array.get 6L prods;
              ]) ~first:(Ordset.singleton (module Uns) 6L)
              ~follow:(Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]);
            Symbol.init ~index:11L ~name:"Answer"
              ~prec:None ~alias:None ~start:true
              ~prods:(Ordset.singleton (module Prod) (Array.get 7L prods)) ~first:(Ordset.singleton (module Uns) 6L)
              ~follow:(Ordset.singleton (module Uns) 1L);
            Symbol.init ~index:12L ~name:"Answer'"
              ~prec:None ~alias:None ~start:true
              ~prods:(Ordset.singleton (module Prod) (Array.get 8L prods)) ~first:(Ordset.singleton (module Uns) 6L)
              ~follow:(Ordset.singleton (module Uns) 0L)
          |]

        module Lr0Item = struct
            module T = struct
                type t = {
                    prod: Prod.t;
                    dot: uns;
                  }

                let hash_fold {prod; dot} state =
                    state
                      |> Prod.hash_fold prod
                      |> Uns.hash_fold dot

                let cmp {prod=p0; dot=d0} {prod=p1; dot=d1} =
                    let open Cmp in
                    match Prod.cmp p0 p1 with
                      | Lt -> Lt
                      | Eq -> Uns.cmp d0 d1
                      | Gt -> Gt

                let pp {prod; dot} formatter =
                    formatter
                      |> Fmt.fmt "{prod=" |> Prod.pp prod
                      |> Fmt.fmt "; dot=" |> Uns.pp dot
                      |> Fmt.fmt "}"
            end
            include T
            include Identifiable.Make(T)

            let init ~prod ~dot =
                {prod; dot}
          end

        module Lr1Item = struct
            module T = struct
                type t = {
                    lr0item: Lr0Item.t;
                    follow: (uns, Uns.cmper_witness) Ordset.t;
                  }

                let hash_fold {lr0item; follow} state =
                    state
                      |> Lr0Item.hash_fold lr0item
                      |> Ordset.hash_fold follow

                let cmp {lr0item=l0; follow=f0} {lr0item=l1; follow=f1} =
                    let open Cmp in
                    match Lr0Item.cmp l0 l1 with
                      | Lt -> Lt
                      | Eq -> Ordset.cmp f0 f1
                      | Gt -> Gt

                let pp {lr0item; follow} formatter =
                    formatter
                      |> Fmt.fmt "{lr0item=" |> Lr0Item.pp lr0item
                      |> Fmt.fmt "; follow=" |> Ordset.pp follow
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~lr0item ~follow =
                {lr0item; follow}
          end

        module Lr1Itemset = struct
            module T = struct
                type t = (Lr0Item.t, Lr1Item.t, Lr0Item.cmper_witness) Ordmap.t

                let hash_fold t =
                    Ordmap.hash_fold Lr1Item.hash_fold t

                let cmp t0 t1 =
                    Ordmap.cmp Lr1Item.cmp t0 t1

                let pp = Ordmap.pp Lr1Item.pp
              end
            include T
            include Identifiable.Make(T)

            let empty = Ordmap.empty (module Lr0Item)

            let init = Ordmap.of_alist (module Lr0Item)
          end

        module Lr1ItemsetClosure = struct
            module T = struct
                type t = {
                    index: uns;
                    kernel: Lr1Itemset.t;
                    added: Lr1Itemset.t;
                  }

                let hash_fold {index; _} state =
                    state |> Uns.hash_fold index

                let cmp {index=i0; _} {index=i1; _} =
                    Uns.cmp i0 i1

                let pp {index; kernel; added} formatter =
                    formatter
                      |> Fmt.fmt "{index=" |> Uns.pp index
                      |> Fmt.fmt "; kernel=" |> Lr1Itemset.pp kernel
                      |> Fmt.fmt "; added=" |> Lr1Itemset.pp added
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~index ~kernel ~added =
                {index; kernel; added}
          end

        module Action = struct
            module T = struct
                type t =
                  | ShiftPrefix of uns
                  | ShiftAccept of uns
                  | Reduce of uns

                let constructor_index = function
                  | ShiftPrefix _ -> 0L
                  | ShiftAccept _ -> 1L
                  | Reduce _ -> 2L

                let arg_index = function
                  | ShiftPrefix arg_index
                  | ShiftAccept arg_index
                  | Reduce arg_index -> arg_index

                let hash_fold t state =
                    state
                      |> Uns.hash_fold (constructor_index t)
                      |> Uns.hash_fold (arg_index t)

                let cmp t0 t1 =
                    let open Cmp in
                    match Uns.cmp (constructor_index t0) (constructor_index t1) with
                      | Lt -> Lt
                      | Eq -> Uns.cmp (arg_index t0) (arg_index t1)
                      | Gt -> Gt

                let to_string = function
                  | ShiftPrefix state_index -> begin
                    String.Fmt.empty
                    |> Fmt.fmt "ShiftPrefix " |> Uns.pp state_index
                    |> Fmt.to_string
                  end
                  | ShiftAccept state_index -> begin
                    String.Fmt.empty
                    |> Fmt.fmt "ShiftAccept " |> Uns.pp state_index
                    |> Fmt.to_string
                  end
                  | Reduce prod_index -> begin
                    String.Fmt.empty
                    |> Fmt.fmt "Reduce " |> Uns.pp prod_index
                    |> Fmt.to_string
                  end

                let pp t formatter =
                    formatter |> Fmt.fmt (to_string t)
              end
            include T
            include Identifiable.Make(T)
          end

        module State = struct
            module T = struct
                type t = {
                    lr1ItemsetClosure: Lr1ItemsetClosure.t;
                    actions: (uns, Action.t, Uns.cmper_witness) Map.t;
                    gotos: (uns, uns, Uns.cmper_witness) Map.t;
                  }

                let hash_fold {lr1ItemsetClosure; _} state =
                    state |> Lr1ItemsetClosure.hash_fold lr1ItemsetClosure

                let cmp {lr1ItemsetClosure=c0; _} {lr1ItemsetClosure=c1; _} =
                    Lr1ItemsetClosure.cmp c0 c1

                let pp {lr1ItemsetClosure; actions; gotos} formatter =
                    formatter
                      |> Fmt.fmt "{lr1ItemsetClosure=" |> Lr1ItemsetClosure.pp lr1ItemsetClosure
                      |> Fmt.fmt "; actions=" |> Map.pp Action.pp actions
                      |> Fmt.fmt "; gotos=" |> Map.pp Uns.pp gotos
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~lr1ItemsetClosure ~actions ~gotos =
                {lr1ItemsetClosure; actions; gotos}
          end

        let states = [|
            (* 0 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:0L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [0L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 7L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [1L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.ShiftPrefix 1L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (10L, 2L);
                    (11L, 3L);
                  ]
              );
            (* 1 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:1L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.empty
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (2L, Action.Reduce 6L);
                    (3L, Action.Reduce 6L);
                    (4L, Action.Reduce 6L);
                    (5L, Action.Reduce 6L);
                    (7L, Action.Reduce 6L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 2 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:2L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 7L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [1L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (2L, Action.ShiftPrefix 4L);
                    (3L, Action.ShiftPrefix 5L);
                    (4L, Action.ShiftPrefix 6L);
                    (5L, Action.ShiftPrefix 7L);
                    (7L, Action.ShiftAccept 8L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (8L, 9L);
                    (9L, 10L);
                  ]
              );
            (* 3 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:3L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [0L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.empty
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (1L, Action.ShiftPrefix 11L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 4 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:4L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.empty
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.Reduce 0L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 5 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:5L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.empty
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.Reduce 1L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 6 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:6L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.empty
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.Reduce 2L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 7 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:7L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.empty
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.Reduce 3L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 8 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:8L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 7L prods) ~dot:2L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [1L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.empty
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (1L, Action.Reduce 7L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 9 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:9L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:2L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.ShiftPrefix 1L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (10L, 12L);
                  ]
              );
            (* 10 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:10L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:2L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 6L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (6L, Action.ShiftPrefix 1L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (10L, 13L);
                  ]
              );
            (* 11 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:11L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 8L prods) ~dot:2L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [0L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.empty
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (0L, Action.Reduce 8L);
                  ]
              )
              ~gotos:(
                Map.empty (module Uns)
              );
            (* 12 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:12L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:3L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (2L, Action.Reduce 4L);
                    (3L, Action.Reduce 4L);
                    (4L, Action.Reduce 4L);
                    (5L, Action.Reduce 4L);
                    (7L, Action.Reduce 4L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (8L, 9L);
                    (9L, 10L);
                  ]
              );
            (* 13 *) State.init
              ~lr1ItemsetClosure:(
                Lr1ItemsetClosure.init
                  ~index:13L
                  ~kernel:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 4L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:1L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 5L prods) ~dot:3L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [2L; 3L; 4L; 5L; 7L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
                  ~added:(
                    Lr1Itemset.init [
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 0L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 1L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 2L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                        (
                            let lr0item = Lr0Item.init ~prod:(Array.get 3L prods) ~dot:0L in
                            let lr1item = Lr1Item.init ~lr0item ~follow:(
                                Ordset.of_list (module Uns) [6L]
                              ) in
                            lr0item, lr1item
                          );
                      ]
                  )
              )
              ~actions:(
                Map.of_alist (module Uns) [
                    (2L, Action.ShiftPrefix 4L);
                    (3L, Action.ShiftPrefix 5L);
                    (4L, Action.Reduce 5L);
                    (5L, Action.Reduce 5L);
                    (7L, Action.Reduce 5L);
                  ]
              )
              ~gotos:(
                Map.of_alist (module Uns) [
                    (8L, 9L);
                    (9L, 10L);
                  ]
              );
          |]
      end

    module Token = struct
        module T = struct
            type t =
              | EPSILON (* "ε" *)
              | PSEUDO_END (* "⊥" *)
              | STAR (* "*" *)
              | SLASH (* "/" *)
              | PLUS (* "+" *)
              | MINUS (* "-" *)
              | INT of Zint.t
              | EOI

            let index = function
              | EPSILON -> 0L
              | PSEUDO_END -> 1L
              | STAR -> 2L
              | SLASH -> 3L
              | PLUS -> 4L
              | MINUS -> 5L
              | INT _ -> 6L
              | EOI -> 7L

            let hash_fold t state =
                state |> Uns.hash_fold (index t)

            let cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            let spec t =
                Array.get (index t) Spec.symbols

            let pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          end
        include T
        include Identifiable.Make(T)
      end

    module Nonterm = struct
        module T = struct
            type t =
              | MulOp of Token.t
              | AddOp of Token.t
              | Expr of Zint.t
              | Answer of Zint.t
              | Answer' of Zint.t

            let index = function
              | MulOp _ -> 8L
              | AddOp _ -> 9L
              | Expr _ -> 10L
              | Answer _ -> 11L
              | Answer' _ -> 12L

            let hash_fold t state =
                state |> Uns.hash_fold (index t)

            let cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            let spec t =
                Array.get (index t) Spec.symbols

            let pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          end
        include T
        include Identifiable.Make(T)
      end

    module Symbol = struct
        module T = struct
            type t =
              | Token of Token.t
              | Nonterm of Nonterm.t

            let index = function
              | Token token -> Token.index token
              | Nonterm nonterm -> Nonterm.index nonterm

            let hash_fold t state =
                state |> Uns.hash_fold (index t)

            let cmp t0 t1 =
                Uns.cmp (index t0) (index t1)

            let spec = function
              | Token token -> Token.spec token
              | Nonterm nonterm -> Nonterm.spec nonterm

            let pp t formatter =
                formatter
                  |> Spec.Symbol.pp (spec t)
          end
        include T
        include Identifiable.Make(T)
      end

    module State = struct
        module T = struct
            type t = uns

            let hash_fold t state =
                state |> Uns.hash_fold t

            let cmp t0 t1 =
                Uns.cmp t0 t1

            let spec t =
                Array.get t Spec.states

            let pp t formatter =
                formatter |> Uns.pp t
          end
        include T
        include Identifiable.Make(T)

        let init state_index =
            state_index
      end

    module Stack = struct
        module Elm = struct
            module T = struct
                type t = {
                    symbol: Symbol.t;
                    state: State.t;
                  }

                let hash_fold {symbol; state} hash_state =
                    hash_state
                      |> Symbol.hash_fold symbol
                      |> State.hash_fold state

                let cmp {symbol=symbol0; state=state0} {symbol=symbol1; state=state1} =
                    let open Cmp in
                    match State.cmp state0 state1 with
                      | Lt -> Lt
                      | Eq -> Symbol.cmp symbol0 symbol1
                      | Gt -> Gt

                let pp {symbol; state} formatter =
                    formatter
                      |> Fmt.fmt "{symbol=" |> Symbol.pp symbol
                      |> Fmt.fmt "; state=" |> State.pp state
                      |> Fmt.fmt "}"
              end
            include T
            include Identifiable.Make(T)

            let init ~symbol ~state =
                {symbol; state}
          end

        type t = Elm.t list

        let fmt ?(alt=false) ?(width=0L) t formatter =
            formatter |> List.fmt ~alt ~width Elm.pp t

        let pp t formatter =
            formatter |> fmt t

        module Reduction = struct
            module T = struct
                type stack = t
                type t = uns
                type callback = stack -> Symbol.t * stack

                let hash_fold t state =
                    state |> Uns.hash_fold t

                let cmp t0 t1 =
                    Uns.cmp t0 t1

                let pp t formatter =
                    formatter |> Uns.pp t
              end
            include T
            include Identifiable.Make(T)

            let callbacks = [|
                (* 0 *) (function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (MulOp (
                  (*______________________________________________________________________________*)
#10 "./Example_ml.hmh"
STAR
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 1 *) (function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (MulOp (
                  (*______________________________________________________________________________*)
#11 "./Example_ml.hmh"
SLASH
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 2 *) (function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (AddOp (
                  (*______________________________________________________________________________*)
#17 "./Example_ml.hmh"
PLUS
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 3 *) (function
                  | _
                  :: tl__hocc__ -> Symbol.Nonterm (AddOp (
                  (*______________________________________________________________________________*)
#18 "./Example_ml.hmh"
MINUS
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 4 *) (function
                  | Elm.{symbol=Symbol.Nonterm (Expr e1); _}
                  :: Elm.{symbol=Symbol.Nonterm (MulOp op); _}
                  :: Elm.{symbol=Symbol.Nonterm (Expr e0); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  (*______________________________________________________________________________*)
#23 "./Example_ml.hmh"
match op with
          | STAR -> Zint.(e0 * e1)
          | SLASH -> Zint.(e0 / e1)
          | _ -> not_reached ()
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 5 *) (function
                  | Elm.{symbol=Symbol.Nonterm (Expr e1); _}
                  :: Elm.{symbol=Symbol.Nonterm (AddOp op); _}
                  :: Elm.{symbol=Symbol.Nonterm (Expr e0); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  (*______________________________________________________________________________*)
#28 "./Example_ml.hmh"
match op with
          | PLUS -> Zint.(e0 + e1)
          | MINUS -> Zint.(e0 - e1)
          | _ -> not_reached ()
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 6 *) (function
                  | Elm.{symbol=Symbol.Token (INT x); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Expr (
                  (*______________________________________________________________________________*)
#32 "./Example_ml.hmh"
x
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 7 *) (function
                  | _
                  :: Elm.{symbol=Symbol.Nonterm (Expr e); _}
                  :: tl__hocc__ -> Symbol.Nonterm (Answer (
                  (*______________________________________________________________________________*)
#36 "./Example_ml.hmh"
e
                  (*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*)
                  )), tl__hocc__
                  | _ -> not_reached ()
                );
                (* 8 *) (fun _stack -> not_reached ())
              |]

            let callback t =
                Array.get t callbacks

            let init callback_index =
                callback_index
          end

        let shift ~symbol ~state t =
            (Elm.init ~symbol ~state) :: t

        (* val goto: Symbol.t -> t -> t *)
        let goto symbol t =
            match t with
              | [] -> not_reached ()
              | Elm.{state; _} :: _ ->
                let symbol_index = Symbol.index symbol in
                let Spec.State.{gotos; _} = Array.get state Spec.states in
                let state' = Map.get_hlt symbol_index gotos |> State.init in
                shift ~symbol ~state:state' t

        let reduce ~reduction t =
            let callback = Reduction.callback reduction in
            let symbol, t' = callback t in
            goto symbol t'
      end

    module Status = struct
        module T = struct
            type t =
              | ShiftPrefix of Token.t * State.t
              | ShiftAccept of Token.t * State.t
              | Reduce of Token.t * Stack.Reduction.t
              | Prefix
              | Accept of Nonterm.t
              | Reject of Token.t

            let constructor_index = function
              | ShiftPrefix _ -> 0L
              | ShiftAccept _ -> 1L
              | Reduce _ -> 2L
              | Prefix -> 3L
              | Accept _ -> 4L
              | Reject _ -> 5L

            let hash_fold t state =
                state
                  |> Uns.hash_fold (constructor_index t)
                  |> (fun hash_state ->
                    match t with
                      | ShiftPrefix (token, state)
                      | ShiftAccept (token, state) ->
                        hash_state |> State.hash_fold state |> Token.hash_fold token
                      | Reduce (token, reduction) ->
                        hash_state |> Stack.Reduction.hash_fold reduction |> Token.hash_fold token
                      | Prefix -> hash_state
                      | Accept nonterm -> hash_state |> Nonterm.hash_fold nonterm
                      | Reject token -> hash_state |> Token.hash_fold token
                  )

            let cmp t0 t1 =
                let open Cmp in
                match Uns.cmp (constructor_index t0) (constructor_index t1) with
                  | Lt -> Lt
                  | Eq -> begin
                    match t0, t1 with
                      | ShiftPrefix (token0, state0), ShiftPrefix (token1, state1)
                      | ShiftAccept (token0, state0), ShiftAccept (token1, state1) -> begin
                        match State.cmp state0 state1 with
                          | Lt -> Lt
                          | Eq -> Token.cmp token0 token1
                          | Gt -> Gt
                      end
                      | Reduce (token0, reduction0), Reduce (token1, reduction1)
                      -> begin
                        match Stack.Reduction.cmp reduction0 reduction1 with
                          | Lt -> Lt
                          | Eq -> Token.cmp token0 token1
                          | Gt -> Gt
                      end
                      | Prefix, Prefix -> Eq
                      | Accept nonterm0, Accept nonterm1 -> Nonterm.cmp nonterm0 nonterm1
                      | Reject token0, Reject token1 -> Token.cmp token0 token1
                      | _, _ -> not_reached ()
                  end
                  | Gt -> Gt

            let pp t formatter =
                formatter
                  |> (fun formatter ->
                    match t with
                      | ShiftPrefix (token, state) -> begin
                        formatter
                          |> Fmt.fmt "ShiftPrefix (" |> Token.pp token
                          |> Fmt.fmt ", " |> State.pp state
                          |> Fmt.fmt ")"
                      end
                      | ShiftAccept (token, state) -> begin
                        formatter
                          |> Fmt.fmt "ShiftAccept (" |> Token.pp token
                          |> Fmt.fmt ", " |> State.pp state
                          |> Fmt.fmt ")"
                      end
                      | Reduce (token, reduction) -> begin
                        formatter
                          |> Fmt.fmt "Reduce (" |> Token.pp token
                          |> Fmt.fmt ", " |> Stack.Reduction.pp reduction
                          |> Fmt.fmt ")"
                      end
                      | Prefix -> formatter |> Fmt.fmt "Prefix"
                      | Accept nonterm -> formatter |> Fmt.fmt "Accept " |> Nonterm.pp nonterm
                      | Reject token -> formatter |> Fmt.fmt "Reject " |> Token.pp token
                  )
          end
        include T
        include Identifiable.Make(T)
      end

    type t = {
        stack: Stack.t;
        status: Status.t;
      }

    module Start = struct
        module Answer = struct
            let boi = {
                stack=[{
                    symbol=Token Token.EPSILON;
                    state=State.init 0L;
                  }];
                status=Prefix;
              }
          end
      end

    let feed token = function
      | {stack={state; _} :: _; status=Prefix} as t -> begin
        let token_index = Token.index token in
        let Spec.State.{actions; _} = Array.get state Spec.states in
        let status = match Map.get token_index actions with
          | Some (Spec.Action.ShiftPrefix state') -> Status.ShiftPrefix (token, state')
          | Some (Spec.Action.ShiftAccept state') -> Status.ShiftAccept (token, state')
          | Some (Spec.Action.Reduce prod_index) -> begin
            let Spec.Prod.{callback=callback_index; _} = Array.get prod_index Spec.prods in
            let reduction = Stack.Reduction.init callback_index in
            Status.Reduce (token, reduction)
          end
          | None -> Status.Reject token
        in
        {t with status}
      end
      | _ -> not_reached ()

    let step {stack; status} =
        let open Status in
        match status with
          | ShiftPrefix (token, state) ->
            {stack=Stack.shift ~symbol:(Token token) ~state stack; status=Prefix}
          | ShiftAccept (token, state) -> begin
            (* Shift, perform the ⊥ reduction, and extract the accepted symbol from the stack. *)
            let stack = Stack.shift ~symbol:(Token token) ~state stack in
            let pseudo_end_index = Token.index Token.PSEUDO_END in
            let Spec.State.{actions; _} = Array.get state Spec.states in
            match Map.get_hlt pseudo_end_index actions with
              | Spec.Action.Reduce prod_index -> begin
                let Spec.Prod.{callback=callback_index; _} = Array.get prod_index Spec.prods in
                let reduction = Stack.Reduction.init callback_index in
                let stack = Stack.reduce ~reduction stack in
                match stack with
                  | [] -> not_reached ()
                  | {symbol=Token _; _} :: _ -> not_reached ()
                  | {symbol=Nonterm nonterm; _} :: _ -> {stack=[]; status=Accept nonterm}
              end
              | _ -> not_reached ()
          end
          | Reduce (token, reduction) -> begin
            feed token {stack=Stack.reduce ~reduction stack; status=Prefix}
          end
          | _ -> not_reached ()

    (* val walk: t -> t *)
    let rec walk ({status; _} as t) =
        let open Status in
        match status with
          | ShiftPrefix _
          | ShiftAccept _
          | Reduce _ -> t |> step |> walk
          | Prefix
          | Accept _
          | Reject _ -> t

    let next token ({status; _} as t) =
        match status with
          | Status.Prefix -> t |> feed token |> walk
          | _ -> not_reached ()
  end
#37 "./Example_ml.hmh"

(* Tokenize `s`, e.g. "2 + 3 * 4", and append an `EOI` token. *)
let tokenize s =
    s |> String.split_rev ~f:(fun cp -> Codepoint.(cp = (of_char ' ')))
      |> List.rev_filter ~f:(fun s -> not (String.is_empty s))
      |> List.rev_map ~f:(fun s ->
        let open Token in
        match s with
          | "*" -> STAR
          | "/" -> SLASH
          | "+" -> PLUS
          | "-" -> MINUS
          | _ -> INT (Zint.of_string s)
      )
      |> List.push Token.EOI
      |> List.rev

(* Calculate the result of the arithmetic expression expressed in `s`, e.g. "2 + 3 * 4". *)
let calculate s =
    let {status; _} = List.fold_until (tokenize s) ~init:Start.Answer.boi ~f:(fun parser tok ->
        let {status; _} as parser' = next tok parser in
        let is_done = match status with
          | Prefix -> false
          | Accept _
          | Reject _ -> true
          | _ -> not_reached ()
          in
        parser', is_done
      ) in
    match status with
      | Accept (Answer answer) -> answer
      | Prefix -> halt "Partial input"
      | Reject _ -> halt "Parse error"
      | _ -> not_reached ()

let main () =
    File.Fmt.stdout
      |> Zint.pp (calculate "2 + 3 * 4")
      |> ignore

let _ = main ()

(* To bootstrap the `hocc` parser, run one of the following commands:
 *
 * - Compilable (trivial update):
 *   dune exec -- hocc -v -a ielr1 -ml -s Parse
 * - Not compilable (use external `hocc`):
 *   hocc -v -a ielr1 -ml -s Parse
 *)
open Basis
open! Basis.Rudiments

module Error = struct
    module T = struct
        type t = {
            source: Hmc.Source.Slice.t;
            msg: string;
          }

        let cmp t0 t1 =
            Hmc.Source.Slice.cmp t0.source t1.source

        let pp {source; msg} formatter =
            formatter
              |> Fmt.fmt "{source=" |> Hmc.Source.Slice.pp source
              |> Fmt.fmt "; msg=" |> String.pp msg
              |> Fmt.fmt "}"

        let fmt ?(alt=false) ({source; msg} as t) formatter =
            match alt with
              | false -> pp t formatter
              | true -> begin
                formatter
                  |> Fmt.fmt "hocc: At "
                  |> Hmc.Source.Slice.pp source
                  |> Fmt.fmt ": "
                  |> Fmt.fmt msg
                  |> Fmt.fmt "\n"
              end
      end
    include T
    include Cmpable.Make(T)

    let init_token token msg =
        {source=Scan.Token.source token; msg}

    let init_mal mal =
        let open Hmc.Scan.Token.Rendition.Malformation in
        {source=source mal; msg=description mal}

    let init_scanner scanner msg =
        let cursor = Scan.cursor scanner in
        let source = Hmc.Source.Slice.of_cursors ~base:cursor ~past:cursor in
        {source; msg}
  end

type token_hocc =
  | HOCC of {token: Scan.Token.t}
type token_nonterm =
  | NONTERM of {token: Scan.Token.t}
type token_epsilon =
  | EPSILON of {token: Scan.Token.t}
type token_start =
  | START of {token: Scan.Token.t}
type token_token =
  | TOKEN of {token: Scan.Token.t}
type token_neutral =
  | NEUTRAL of {token: Scan.Token.t}
type token_left =
  | LEFT of {token: Scan.Token.t}
type token_right =
  | RIGHT of {token: Scan.Token.t}
type token_prec =
  | PREC of {token: Scan.Token.t}
type token_uident =
  | UIDENT of {token: Scan.Token.t}
type token_cident =
  | CIDENT of {token: Scan.Token.t}
type token_uscore =
  | USCORE of {token: Scan.Token.t}
type token_istring =
  | ISTRING of {token: Scan.Token.t}
type token_colon_colon_eq =
  | COLON_COLON_EQ of {token: Scan.Token.t}
type token_of =
  | OF of {token: Scan.Token.t}
type token_colon =
  | COLON of {token: Scan.Token.t}
type token_dot =
  | DOT of {token: Scan.Token.t}
type token_arrow =
  | ARROW of {token: Scan.Token.t}
type token_bar =
  | BAR of {token: Scan.Token.t}
type token_lt =
  | LT of {token: Scan.Token.t}
type token_eq =
  | EQ of {token: Scan.Token.t}
type token_comma =
  | COMMA of {token: Scan.Token.t}
type token_semi =
  | SEMI of {token: Scan.Token.t}
type token_as =
  | AS of {token: Scan.Token.t}
type token_line_delim =
  | LINE_DELIM of {token: Scan.Token.t}
type token_indent =
  | INDENT of {token: Scan.Token.t}
type token_dedent =
  | DEDENT of {token: Scan.Token.t}
type token_lparen =
  | LPAREN of {token: Scan.Token.t}
type token_rparen =
  | RPAREN of {token: Scan.Token.t}
type token_lcapture =
  | LCAPTURE of {token: Scan.Token.t}
type token_rcapture =
  | RCAPTURE of {token: Scan.Token.t}
type token_lbrack =
  | LBRACK of {token: Scan.Token.t}
type token_rbrack =
  | RBRACK of {token: Scan.Token.t}
type token_larray =
  | LARRAY of {token: Scan.Token.t}
type token_rarray =
  | RARRAY of {token: Scan.Token.t}
type token_lcurly =
  | LCURLY of {token: Scan.Token.t}
type token_rcurly =
  | RCURLY of {token: Scan.Token.t}
type token_other_token =
  | OTHER_TOKEN of {token: Scan.Token.t}
type token_eoi =
  | EOI of {token: Scan.Token.t}

type nonterm_uident =
  | Uident of {token: Scan.Token.t}
  and nonterm_precs_tl =
  | PrecsTlUident of {uident: Scan.Token.t; precs_tl: nonterm_precs_tl}
  | PrecsTlEpsilon
  and nonterm_precs =
  | Precs of {uident: Scan.Token.t; precs_tl: nonterm_precs_tl}
  and nonterm_prec_rels =
  | PrecRelsPrecs of {precs: nonterm_precs}
  | PrecRelsEpsilon
  and nonterm_prec_type =
  | PrecTypeNeutral
  | PrecTypeLeft
  | PrecTypeRight
  and nonterm_prec =
  | Prec of {prec_type: nonterm_prec_type; uident: Scan.Token.t; prec_rels: nonterm_prec_rels}
  and nonterm_symbol_type_qualifier =
  | SymbolTypeQualifier of {cident: token_cident;
  symbol_type_qualifier_tl: nonterm_symbol_type_qualifier}
  | SymbolTypeQualifierEpsilon
  and nonterm_symbol_type =
  | SymbolType of {symbol_type_qualifier: nonterm_symbol_type_qualifier; symbol_type: Scan.Token.t}
  and nonterm_symbol_type0 =
  | SymbolType0SymbolType of {symbol_type: nonterm_symbol_type}
  | SymbolType0Epsilon
  and nonterm_prec_ref =
  | PrecRefUident of {uident: Scan.Token.t}
  | PrecRefEpsilon
  and nonterm_token_alias =
  | TokenAlias of {alias: token_istring}
  | TokenAliasEpsilon
  and nonterm_token =
  | Token of {cident: token_cident; token_alias: nonterm_token_alias;
  symbol_type0: nonterm_symbol_type0; prec_ref: nonterm_prec_ref}
  and nonterm_sep =
  | SepLineDelim of {line_delim: token_line_delim}
  | SepSemi of {semi: token_semi}
  | SepBar of {bar: token_bar}
  and nonterm_codes_tl =
  | CodesTlSepCode of {sep: nonterm_sep; code: nonterm_code; codes_tl: nonterm_codes_tl}
  | CodesTlEpsilon
  and nonterm_codes =
  | Codes of {code: nonterm_code; codes_tl: nonterm_codes_tl}
  and nonterm_codes0 =
  | Codes0Codes of {codes: nonterm_codes}
  | Codes0Epsilon
  and nonterm_delimited =
  | DelimitedBlock of {indent: token_indent; codes: nonterm_codes; dedent: token_dedent}
  | DelimitedParen of {lparen: token_lparen; codes0: nonterm_codes0; rparen: token_rparen}
  | DelimitedCapture of {lcapture: token_lcapture; codes0: nonterm_codes0; rcapture: token_rcapture}
  | DelimitedList of {lbrack: token_lbrack; codes0: nonterm_codes0; rbrack: token_rbrack}
  | DelimitedArray of {larray: token_larray; codes0: nonterm_codes0; rarray: token_rarray}
  | DelimitedModule of {lcurly: token_lcurly; codes0: nonterm_codes0; rcurly: token_rcurly}
  and nonterm_code_token =
  | CodeToken of {token: Scan.Token.t}
  and nonterm_code_tl =
  | CodeTlDelimited of {delimited: nonterm_delimited; code_tl: nonterm_code_tl}
  | CodeTlCodeToken of {code_token: nonterm_code_token; code_tl: nonterm_code_tl}
  | CodeTlEpsilon
  and nonterm_code =
  | CodeDelimited of {delimited: nonterm_delimited; code_tl: nonterm_code_tl}
  | CodeCodeToken of {code_token: nonterm_code_token; code_tl: nonterm_code_tl}
  and nonterm_pattern_field =
  | PatternFieldBinding of {binding: nonterm_uident}
  | PatternFieldPattern of {pattern: nonterm_pattern}
  and nonterm_pattern_fields =
  | PatternFieldsOne of {field: nonterm_pattern_field}
  | PatternFieldsMulti of {field: nonterm_pattern_field; fields: nonterm_pattern_fields}
  and nonterm_semi_suffix =
  | SemiSuffix
  and nonterm_module_path =
  | ModulePath
  and nonterm_pattern =
  | PatternUscore
  | PatternBinding of {binding: nonterm_uident}
  | PatternPattern of {pattern: nonterm_pattern}
  | PatternComma of {pattern_a: nonterm_pattern; pattern_b: nonterm_pattern}
  | PatternFields of {fields: nonterm_pattern_fields}
  and nonterm_prod_param_symbol =
  | ProdParamSymbolCident of {cident: token_cident}
  | ProdParamSymbolAlias of {alias: token_istring}
  and nonterm_prod_param =
  | ProdParamBinding of {binding: nonterm_uident; prod_param_symbol: nonterm_prod_param_symbol}
  | ProdParamPattern of {lparen: token_lparen; pattern: nonterm_pattern; rparen: token_rparen;
  prod_param_symbol: nonterm_prod_param_symbol}
  | ProdParamFields of {lcurly: token_lcurly; fields: nonterm_pattern_fields; rcurly: token_rcurly;
  prod_param_symbol: nonterm_prod_param_symbol}
  | ProdParam of {prod_param_symbol: nonterm_prod_param_symbol}
  and nonterm_prod_params_tl =
  | ProdParamsTlProdParam of {prod_param: nonterm_prod_param;
  prod_params_tl: nonterm_prod_params_tl}
  | ProdParamsTlPrecRef of {prec_ref: nonterm_prec_ref}
  and nonterm_prod_params =
  | ProdParamsProdParam of {prod_param: nonterm_prod_param; prod_params_tl: nonterm_prod_params_tl}
  and nonterm_prod_pattern =
  | ProdPatternParams of {prod_params: nonterm_prod_params}
  | ProdPatternEpsilon of {epsilon: token_epsilon; prec_ref: nonterm_prec_ref}
  and nonterm_prod =
  | Prod of {prod_pattern: nonterm_prod_pattern}
  and nonterm_prods_tl =
  | ProdsTlProd of {prod: nonterm_prod; prods_tl: nonterm_prods_tl}
  | ProdsTlEpsilon
  and nonterm_prods =
  | ProdsProd of {prod: nonterm_prod; prods_tl: nonterm_prods_tl}
  and nonterm_reduction =
  | Reduction of {prods: nonterm_prods; code: nonterm_code}
  and nonterm_reductions_tl =
  | ReductionsTlReduction of {reduction: nonterm_reduction; reductions_tl: nonterm_reductions_tl}
  | ReductionsTlEpsilon
  and nonterm_reductions =
  | ReductionsReduction of {reduction: nonterm_reduction; reductions_tl: nonterm_reductions_tl}
  and nonterm_nonterm_type =
  | NontermTypeNonterm
  | NontermTypeStart
  and nonterm_nonterm =
  | NontermProds of {nonterm_type: nonterm_nonterm_type; cident: token_cident;
  prec_ref: nonterm_prec_ref; prods: nonterm_prods}
  | NontermReductions of {nonterm_type: nonterm_nonterm_type; cident: token_cident;
  symbol_type: nonterm_symbol_type; prec_ref: nonterm_prec_ref; reductions: nonterm_reductions}
  and nonterm_stmt =
  | StmtPrec of {prec: nonterm_prec}
  | StmtToken of {token: nonterm_token}
  | StmtNonterm of {nonterm: nonterm_nonterm}
  and nonterm_stmts_tl =
  | StmtsTl of {stmt: nonterm_stmt; stmts_tl: nonterm_stmts_tl}
  | StmtsTlEpsilon
  and nonterm_stmts =
  | Stmts of {stmt: nonterm_stmt; stmts_tl: nonterm_stmts_tl}
  and nonterm_hocc =
  | Hocc of {hocc_: token_hocc; indent: token_indent; stmts: nonterm_stmts; dedent: token_dedent}
  and nonterm_matter_token =
  | MatterToken of {token: Scan.Token.t}
  and nonterm_matter =
  | Matter of {token: Scan.Token.t; matter: nonterm_matter}
  | MatterEpsilon
  and nonterm_hmh =
  | Hmh of {prelude: nonterm_matter; hocc_: nonterm_hocc; postlude: nonterm_matter; eoi: token_eoi}
  and nonterm_hmhi =
  | Hmhi of {prelude: nonterm_matter; hocc_: token_hocc; postlude: nonterm_matter; eoi: token_eoi}

include hocc
    neutral pCodeTl

    (* hocc-specific keywords *)
    token HOCC "hocc" of token_hocc
    token NONTERM "nonterm" of token_nonterm
    token EPSILON_ "epsilon" of token_epsilon
    token START "start" of token_start
    token TOKEN "token" of token_token
    token NEUTRAL "neutral" of token_neutral
    token LEFT "left" of token_left
    token RIGHT "right" of token_right
    token PREC "prec" of token_prec

    (* Identifiers *)
    token UIDENT of token_uident # Uncapitalized
    right pCIDENT
    token CIDENT of token_cident prec pCIDENT # Capitalized
    token USCORE "_" of token_uscore

    (* Token alias *)
    token ISTRING of token_istring

    (* Punctuation/separators *)
    token COLON_COLON_EQ "::=" of token_colon_colon_eq
    token OF "of" of token_of
    token COLON ":" of token_colon
    left pDOT
    token DOT "." of token_dot prec pDOT
    token ARROW "->" of token_arrow
    neutral pBAR < pCodeTl
    token BAR "|" of token_bar prec pBAR
    token LT "<" of token_lt
    token EQ "=" of token_eq
    left pCOMMA < pCIDENT
    token COMMA "," of token_comma prec pCOMMA
    right pSEMI < pCodeTl
    token SEMI ";" of token_semi prec pSEMI
    neutral pAS < pCOMMA
    token AS "as" of token_as prec pAS
    token LINE_DELIM of token_line_delim

    (* Left-right paired delimiters *)
    token INDENT of token_indent
    token DEDENT of token_dedent
    token LPAREN "(" of token_lparen
    token RPAREN ")" of token_rparen
    token LCAPTURE "(|" of token_lcapture
    token RCAPTURE "|)" of token_rcapture
    token LBRACK "[" of token_lbrack
    token RBRACK "]" of token_rbrack
    token LARRAY "[|" of token_larray
    token RARRAY "|]" of token_rarray
    token LCURLY "{" of token_lcurly
    token RCURLY "}" of token_rcurly

    (* Miscellaneous Hemlock token in embedded code *)
    token OTHER_TOKEN of token_other_token

    (* End of input, used to terminate start symbols *)
    token EOI of token_eoi

    nonterm Uident of nonterm_uident ::=
      | (HOCC {token}):"hocc"
      | (NONTERM {token}):"nonterm"
      | (EPSILON {token}):"epsilon"
      | (START {token}):"start"
      | (TOKEN {token}):"token"
      | (NEUTRAL {token}):"neutral"
      | (LEFT {token}):"left"
      | (RIGHT {token}):"right"
      | (PREC {token}):"prec"
      | (UIDENT {token}):UIDENT
      -> Uident {token}

    nonterm PrecsTl of nonterm_precs_tl ::=
      | "," (Uident {token}):Uident precs_tl:PrecsTl -> PrecsTlUident {uident=token; precs_tl}
      | epsilon -> PrecsTlEpsilon

    nonterm Precs of nonterm_precs ::=
      | (Uident {token}):Uident precs_tl:PrecsTl -> Precs {uident=token; precs_tl}

    nonterm PrecRels of nonterm_prec_rels ::=
      | "<" precs:Precs -> PrecRelsPrecs {precs}
      | epsilon -> PrecRelsEpsilon

    nonterm PrecType of nonterm_prec_type ::=
      | "neutral" -> PrecTypeNeutral
      | "left" -> PrecTypeLeft
      | "right" -> PrecTypeRight

    nonterm Prec of nonterm_prec ::=
      | prec_type:PrecType (Uident {token}):Uident prec_rels:PrecRels ->
        Prec {prec_type; uident=token; prec_rels}

    nonterm SymbolTypeQualifier of nonterm_symbol_type_qualifier ::=
      | cident:CIDENT "." symbol_type_qualifier_tl:SymbolTypeQualifier ->
        SymbolTypeQualifier {cident; symbol_type_qualifier_tl}
      | epsilon -> SymbolTypeQualifierEpsilon

    nonterm SymbolType of nonterm_symbol_type ::=
      | "of" symbol_type_qualifier:SymbolTypeQualifier (Uident {token}):Uident ->
        SymbolType {symbol_type_qualifier; symbol_type=token}

    nonterm SymbolType0 of nonterm_symbol_type0 ::=
      | symbol_type:SymbolType -> SymbolType0SymbolType {symbol_type}
      | epsilon -> SymbolType0Epsilon

    nonterm PrecRef of nonterm_prec_ref ::=
      | "prec" (Uident {token}):Uident -> PrecRefUident {uident=token}
      | epsilon -> PrecRefEpsilon

    nonterm TokenAlias of nonterm_token_alias ::=
      | alias:ISTRING -> TokenAlias {alias}
      | epsilon -> TokenAliasEpsilon

    nonterm Token of nonterm_token ::=
      | "token" cident:CIDENT token_alias:TokenAlias symbol_type0:SymbolType0 prec_ref:PrecRef ->
        Token {cident; token_alias; symbol_type0; prec_ref}

    nonterm Sep of nonterm_sep ::=
      | line_delim:LINE_DELIM -> SepLineDelim {line_delim}
      | semi:";" -> SepSemi {semi}
      | bar:"|" -> SepBar {bar}

    nonterm CodesTl of nonterm_codes_tl ::=
      | sep:Sep code:Code codes_tl:CodesTl -> CodesTlSepCode {sep; code; codes_tl}
      | epsilon -> CodesTlEpsilon

    nonterm Codes of nonterm_codes ::=
      | code:Code codes_tl:CodesTl -> Codes {code; codes_tl}

    nonterm Codes0 of nonterm_codes0 ::=
      | codes:Codes -> Codes0Codes {codes}
      | epsilon -> Codes0Epsilon

    nonterm Delimited of nonterm_delimited ::=
      | indent:INDENT codes:Codes dedent:DEDENT -> DelimitedBlock {indent; codes; dedent}
      | lparen:"(" codes0:Codes0 rparen:")" -> DelimitedParen {lparen; codes0; rparen}
      | lcapture:"(|" codes0:Codes0 rcapture:"|)" -> DelimitedCapture {lcapture; codes0; rcapture}
      | lbrack:"[" codes0:Codes0 rbrack:"]" -> DelimitedList {lbrack; codes0; rbrack}
      | larray:"[|" codes0:Codes0 rarray:"|]" -> DelimitedArray {larray; codes0; rarray}
      | lcurly:"{" codes0:Codes0 rcurly:"}" -> DelimitedModule {lcurly; codes0; rcurly}

    nonterm CodeToken of nonterm_code_token ::=
      | (OTHER_TOKEN {token}):OTHER_TOKEN
      | (Uident {token}):Uident
      | (CIDENT {token}):CIDENT
      | (USCORE {token}):"_"
      | (ISTRING {token}):ISTRING
      | (COLON_COLON_EQ {token}):"::="
      | (AS {token}):"as"
      | (OF {token}):"of"
      | (COLON {token}):":"
      | (DOT {token}):"."
      | (ARROW {token}):"->"
      | (BAR {token}):"|"
      | (LT {token}):"<"
      | (EQ {token}):"="
      | (COMMA {token}):","
      | (SEMI {token}):";"
      -> CodeToken {token}

    nonterm CodeTl of nonterm_code_tl ::=
      | delimited:Delimited code_tl:CodeTl -> CodeTlDelimited {delimited; code_tl}
      | code_token:CodeToken code_tl:CodeTl -> CodeTlCodeToken {code_token; code_tl}
      | epsilon prec pCodeTl -> CodeTlEpsilon

    nonterm Code of nonterm_code ::=
      | delimited:Delimited code_tl:CodeTl -> CodeDelimited {delimited; code_tl}
      | code_token:CodeToken code_tl:CodeTl -> CodeCodeToken {code_token; code_tl}

    nonterm PatternField of nonterm_pattern_field ::=
      | binding:Uident -> PatternFieldBinding {binding}
      | Uident "=" pattern:Pattern -> PatternFieldPattern {pattern}

    nonterm PatternFields of nonterm_pattern_fields prec pSEMI ::=
      | field:PatternField
      | field:PatternField ";" "_"
      -> PatternFieldsOne {field}
      | field:PatternField ";" fields:PatternFields
      -> PatternFieldsMulti {field; fields}

    nonterm SemiSuffix of nonterm_semi_suffix ::=
      | ";"
      | epsilon
      -> SemiSuffix

    nonterm ModulePath of nonterm_module_path ::=
      | CIDENT
      | ModulePath "." ModulePath prec pDOT
      -> ModulePath

    nonterm Pattern of nonterm_pattern ::=
      | "_"
      -> PatternUscore
      | binding:Uident
      | Pattern "as" binding:Uident prec pAS
      -> PatternBinding {binding}
      | "(" pattern:Pattern ")"
      | CIDENT pattern:Pattern prec pCIDENT
      | ModulePath "." "(" pattern:Pattern ")"
      -> PatternPattern {pattern}
      | pattern_a:Pattern "," pattern_b:Pattern prec pCOMMA
      -> PatternComma {pattern_a; pattern_b}
      | "{" fields:PatternFields SemiSuffix "}"
      | ModulePath "." "{" fields:PatternFields SemiSuffix "}"
      -> PatternFields {fields}

    nonterm ProdParamSymbol of nonterm_prod_param_symbol ::=
      | cident:CIDENT -> ProdParamSymbolCident {cident}
      | alias:ISTRING -> ProdParamSymbolAlias {alias}

    nonterm ProdParam of nonterm_prod_param ::=
      | binding:Uident ":" prod_param_symbol:ProdParamSymbol
      -> ProdParamBinding {binding; prod_param_symbol}
      | lparen:"(" pattern:Pattern rparen:")" ":" prod_param_symbol:ProdParamSymbol
      | ModulePath "." lparen:"(" pattern:Pattern rparen:")" ":" prod_param_symbol:ProdParamSymbol
      -> ProdParamPattern {lparen; pattern; rparen; prod_param_symbol}
      | lcurly:"{" fields:PatternFields SemiSuffix rcurly:"}" ":" prod_param_symbol:ProdParamSymbol
      | ModulePath "." lcurly:"{" fields:PatternFields SemiSuffix rcurly:"}" ":"
      prod_param_symbol:ProdParamSymbol
      -> ProdParamFields {lcurly; fields; rcurly; prod_param_symbol}
      | "_" ":" prod_param_symbol:ProdParamSymbol
      | prod_param_symbol:ProdParamSymbol
      -> ProdParam {prod_param_symbol}

    nonterm ProdParamsTl of nonterm_prod_params_tl ::=
      | prod_param:ProdParam prod_params_tl:ProdParamsTl ->
        ProdParamsTlProdParam {prod_param; prod_params_tl}
      | prec_ref:PrecRef -> ProdParamsTlPrecRef {prec_ref}

    nonterm ProdParams of nonterm_prod_params ::=
      | prod_param:ProdParam prod_params_tl:ProdParamsTl ->
        ProdParamsProdParam {prod_param; prod_params_tl}

    nonterm ProdPattern of nonterm_prod_pattern ::=
      | prod_params:ProdParams -> ProdPatternParams {prod_params}
      | epsilon:"epsilon" prec_ref:PrecRef -> ProdPatternEpsilon {epsilon; prec_ref}

    nonterm Prod of nonterm_prod ::=
      | prod_pattern:ProdPattern -> Prod {prod_pattern}

    nonterm ProdsTl of nonterm_prods_tl ::=
      | "|" prod:Prod prods_tl:ProdsTl -> ProdsTlProd {prod; prods_tl}
      | epsilon -> ProdsTlEpsilon

    nonterm Prods of nonterm_prods ::=
      | "|" prod:Prod prods_tl:ProdsTl
      | prod:Prod prods_tl:ProdsTl -> ProdsProd {prod; prods_tl}

    nonterm Reduction of nonterm_reduction ::=
      | prods:Prods "->" code:Code -> Reduction {prods; code}

    nonterm ReductionsTl of nonterm_reductions_tl ::=
      | "|" reduction:Reduction reductions_tl:ReductionsTl ->
        ReductionsTlReduction {reduction; reductions_tl}
      | epsilon -> ReductionsTlEpsilon

    nonterm Reductions of nonterm_reductions ::=
      | reduction:Reduction reductions_tl:ReductionsTl ->
        ReductionsReduction {reduction; reductions_tl}

    nonterm NontermType of nonterm_nonterm_type ::=
      | "nonterm" -> NontermTypeNonterm
      | "start" -> NontermTypeStart

    nonterm Nonterm of nonterm_nonterm ::=
      | nonterm_type:NontermType cident:CIDENT prec_ref:PrecRef "::=" prods:Prods ->
        NontermProds {nonterm_type; cident; prec_ref; prods}
      | nonterm_type:NontermType cident:CIDENT symbol_type:SymbolType prec_ref:PrecRef "::="
      reductions:Reductions ->
        NontermReductions {nonterm_type; cident; symbol_type; prec_ref; reductions}

    nonterm Stmt of nonterm_stmt ::=
      | prec:Prec -> StmtPrec {prec}
      | token:Token -> StmtToken {token}
      | nonterm:Nonterm -> StmtNonterm {nonterm}

    nonterm StmtsTl of nonterm_stmts_tl ::=
      | LINE_DELIM stmt:Stmt stmts_tl:StmtsTl -> StmtsTl {stmt; stmts_tl}
      | epsilon -> StmtsTlEpsilon

    nonterm Stmts of nonterm_stmts ::=
      | stmt:Stmt stmts_tl:StmtsTl -> Stmts {stmt; stmts_tl}

    nonterm Hocc of nonterm_hocc ::=
      | hocc_:"hocc" indent:INDENT stmts:Stmts dedent:DEDENT -> Hocc {hocc_; indent; stmts; dedent}

    nonterm MatterToken of nonterm_matter_token ::=
      | sep:Sep
      ->
        let token = match sep with
          | SepLineDelim {line_delim=LINE_DELIM {token}}
          | SepSemi {semi=SEMI {token}}
          | SepBar {bar=BAR {token}}
          -> token
          in
        MatterToken {token}
      | (NONTERM {token}):"nonterm"
      | (EPSILON {token}):"epsilon"
      | (START {token}):"start"
      | (TOKEN {token}):"token"
      | (NEUTRAL {token}):"neutral"
      | (LEFT {token}):"left"
      | (RIGHT {token}):"right"
      | (PREC {token}):"prec"
      | (OTHER_TOKEN {token}):OTHER_TOKEN
      | (UIDENT {token}):UIDENT
      | (CIDENT {token}):CIDENT
      | (USCORE {token}):"_"
      | (ISTRING {token}):ISTRING
      | (COLON_COLON_EQ {token}):"::="
      | (AS {token}):"as"
      | (OF {token}):"of"
      | (COLON {token}):":"
      | (DOT {token}):"."
      | (ARROW {token}):"->"
      | (LT {token}):"<"
      | (EQ {token}):"="
      | (COMMA {token}):","
      | (INDENT {token}):INDENT
      | (DEDENT {token}):DEDENT
      | (LPAREN {token}):"("
      | (RPAREN {token}):")"
      | (LCAPTURE {token}):"(|"
      | (RCAPTURE {token}):"|)"
      | (LBRACK {token}):"["
      | (RBRACK {token}):"]"
      | (LARRAY {token}):"[|"
      | (RARRAY {token}):"|]"
      | (LCURLY {token}):"{"
      | (RCURLY {token}):"}"
      -> MatterToken {token}

    nonterm Matter of nonterm_matter ::=
      | (MatterToken {token}):MatterToken matter:Matter -> Matter {token; matter}
      | epsilon -> MatterEpsilon

    start Hmh of nonterm_hmh ::=
      | prelude:Matter hocc_:Hocc postlude:Matter eoi:EOI -> Hmh {prelude; hocc_; postlude; eoi}

    start Hmhi of nonterm_hmhi ::=
      | prelude:Matter hocc_:"hocc" postlude:Matter eoi:EOI -> Hmhi {prelude; hocc_; postlude; eoi}

let rec scan scanner =
    let scanner, scan_token = Scan.next scanner in
    match Scan.Token.malformations scan_token with
      | [] -> begin
        let token_opt = match scan_token with
          | Scan.Token.HmcToken tok -> begin
            match tok with
              | Tok_whitespace _
              | Tok_hash_comment _
              | Tok_paren_comment _ -> None (* Swallow. *)
              | Tok_uident _ -> Some (Token.UIDENT (UIDENT {token=scan_token}))
              | Tok_cident _ -> Some (Token.CIDENT (CIDENT {token=scan_token}))
              | Tok_uscore _ -> Some (Token.USCORE (USCORE {token=scan_token}))
              | Tok_istring _ -> Some (Token.ISTRING (ISTRING {token=scan_token}))
              | Tok_as _ -> Some (Token.AS (AS {token=scan_token}))
              | Tok_of _ -> Some (Token.OF (OF {token=scan_token}))
              | Tok_colon _ -> Some (Token.COLON (COLON {token=scan_token}))
              | Tok_dot _ -> Some (Token.DOT (DOT {token=scan_token}))
              | Tok_arrow _ -> Some (Token.ARROW (ARROW {token=scan_token}))
              | Tok_bar _ -> Some (Token.BAR (BAR {token=scan_token}))
              | Tok_lt _ -> Some (Token.LT (LT {token=scan_token}))
              | Tok_eq _ -> Some (Token.EQ (EQ {token=scan_token}))
              | Tok_comma _ -> Some (Token.COMMA (COMMA {token=scan_token}))
              | Tok_semi _ -> Some (Token.SEMI (SEMI {token=scan_token}))
              | Tok_line_delim _ -> Some (Token.LINE_DELIM (LINE_DELIM {token=scan_token}))
              | Tok_indent _ -> Some (Token.INDENT (INDENT {token=scan_token}))
              | Tok_dedent _ -> Some (Token.DEDENT (DEDENT {token=scan_token}))
              | Tok_lparen _ -> Some (Token.LPAREN (LPAREN {token=scan_token}))
              | Tok_rparen _ -> Some (Token.RPAREN (RPAREN {token=scan_token}))
              | Tok_lcapture _ -> Some (Token.LCAPTURE (LCAPTURE {token=scan_token}))
              | Tok_rcapture _ -> Some (Token.RCAPTURE (RCAPTURE {token=scan_token}))
              | Tok_lbrack _ -> Some (Token.LBRACK (LBRACK {token=scan_token}))
              | Tok_rbrack _ -> Some (Token.RBRACK (RBRACK {token=scan_token}))
              | Tok_larray _ -> Some (Token.LARRAY (LARRAY {token=scan_token}))
              | Tok_rarray _ -> Some (Token.RARRAY (RARRAY {token=scan_token}))
              | Tok_lcurly _ -> Some (Token.LCURLY (LCURLY {token=scan_token}))
              | Tok_rcurly _ -> Some (Token.RCURLY (RCURLY {token=scan_token}))
              | Tok_end_of_input _ -> Some (Token.EOI (EOI {token=scan_token}))
              | _ -> Some (Token.OTHER_TOKEN (OTHER_TOKEN {token=scan_token}))
          end
          | Tok_hocc _ -> Some (Token.HOCC (HOCC {token=scan_token}))
          | Tok_token _ -> Some (Token.TOKEN (TOKEN {token=scan_token}))
          | Tok_nonterm _ -> Some (Token.NONTERM (NONTERM {token=scan_token}))
          | Tok_start _ -> Some (Token.START (START {token=scan_token}))
          | Tok_epsilon _ -> Some (Token.EPSILON_ (EPSILON {token=scan_token}))
          | Tok_neutral _ -> Some (Token.NEUTRAL (NEUTRAL {token=scan_token}))
          | Tok_left _ -> Some (Token.LEFT (LEFT {token=scan_token}))
          | Tok_right _ -> Some (Token.RIGHT (RIGHT {token=scan_token}))
          | Tok_prec _ -> Some (Token.PREC (PREC {token=scan_token}))
          | Tok_colon_colon_eq _ -> Some (Token.COLON_COLON_EQ (COLON_COLON_EQ {token=scan_token}))
          in
        match token_opt with
          | Some token -> scanner, scan_token, token, []
          | None -> scan scanner
      end
      | mals -> scanner, scan_token, Token.OTHER_TOKEN (OTHER_TOKEN {token=scan_token}), mals

let hmhi scanner =
    let rec inner scanner errs parser = begin
        let scanner, scan_token, token, mals = scan scanner in
        let errs = match mals with
          | [] -> errs
          | _ -> List.fold ~init:errs ~f:(fun errs mal -> Error.init_mal mal :: errs) mals
          in
        let {status; _} as parser = next token parser in
        match status, errs with
          | Prefix, _ -> inner scanner errs parser
          | Accept (Hmhi hmhi), [] -> scanner, Ok hmhi
          | Accept (Hmhi _), _ -> scanner, Error errs
          | Reject _, _ ->
            let errs = Error.init_token scan_token "Unexpected token" :: errs in
            scanner, Error errs
          | _ -> not_reached ()
      end in
    let parser = Start.Hmhi.boi in
    inner scanner [] parser

let hmh scanner =
    let rec inner scanner errs parser = begin
        let scanner, scan_token, token, mals = scan scanner in
        let errs = match mals with
          | [] -> errs
          | _ -> List.fold ~init:errs ~f:(fun errs mal -> Error.init_mal mal :: errs) mals
          in
        let {status; _} as parser = next token parser in
        match status, errs with
          | Prefix, _ -> inner scanner errs parser
          | Accept (Hmh hmh), [] -> scanner, Ok hmh
          | Accept (Hmh _), _ -> scanner, Error errs
          | Reject _, _ -> begin
            let errs = Error.init_token scan_token "Unexpected token" :: errs in
            scanner, Error errs
          end
          | _ -> not_reached ()
      end in
    let parser = Start.Hmh.boi in
    inner scanner [] parser

(**************************************************************************************************)
(* fmt_* functions. *)

let rec pp_token_hocc (HOCC {token}) formatter =
    formatter
      |> Fmt.fmt "HOCC {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_nonterm (NONTERM {token}) formatter =
    formatter
      |> Fmt.fmt "NONTERM {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_epsilon (EPSILON {token}) formatter =
    formatter
      |> Fmt.fmt "EPSILON {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_start (START {token}) formatter =
    formatter
      |> Fmt.fmt "START {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_token (TOKEN {token}) formatter =
    formatter
      |> Fmt.fmt "TOKEN {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_neutral (NEUTRAL {token}) formatter =
    formatter
      |> Fmt.fmt "NEUTRAL {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_left (LEFT {token}) formatter =
    formatter
      |> Fmt.fmt "LEFT {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_right (RIGHT {token}) formatter =
    formatter
      |> Fmt.fmt "RIGHT {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_prec (PREC {token}) formatter =
    formatter
      |> Fmt.fmt "PREC {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_uident (UIDENT {token}) formatter =
    formatter
      |> Fmt.fmt "UIDENT {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_cident (CIDENT {token}) formatter =
    formatter
      |> Fmt.fmt "CIDENT {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_uscore (USCORE {token}) formatter =
    formatter
      |> Fmt.fmt "USCORE {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_istring (ISTRING {token}) formatter =
    formatter
      |> Fmt.fmt "ISTRING {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_colon_colon_eq (COLON_COLON_EQ {token}) formatter =
    formatter
      |> Fmt.fmt "COLON_COLON_EQ {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_of (OF {token}) formatter =
    formatter
      |> Fmt.fmt "OF {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_colon (COLON {token}) formatter =
    formatter
      |> Fmt.fmt "COLON {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_dot (DOT {token}) formatter =
    formatter
      |> Fmt.fmt "DOT {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_arrow (ARROW {token}) formatter =
    formatter
      |> Fmt.fmt "ARROW {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_bar (BAR {token}) formatter =
    formatter
      |> Fmt.fmt "BAR {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_lt (LT {token}) formatter =
    formatter
      |> Fmt.fmt "LT {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_eq (EQ {token}) formatter =
    formatter
      |> Fmt.fmt "EQ {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_comma (COMMA {token}) formatter =
    formatter
      |> Fmt.fmt "COMMA {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_semi (SEMI {token}) formatter =
    formatter
      |> Fmt.fmt "SEMI {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_as (AS {token}) formatter =
    formatter
      |> Fmt.fmt "AS {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_line_delim (LINE_DELIM {token}) formatter =
    formatter
      |> Fmt.fmt "LINE_DELIM {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_indent (INDENT {token}) formatter =
    formatter
      |> Fmt.fmt "INDENT {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_dedent (DEDENT {token}) formatter =
    formatter
      |> Fmt.fmt "DEDENT {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_lparen (LPAREN {token}) formatter =
    formatter
      |> Fmt.fmt "LPAREN {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_rparen (RPAREN {token}) formatter =
    formatter
      |> Fmt.fmt "RPAREN {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_lcapture (LCAPTURE {token}) formatter =
    formatter
      |> Fmt.fmt "LCAPTURE {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_rcapture (RCAPTURE {token}) formatter =
    formatter
      |> Fmt.fmt "RCAPTURE {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_lbrack (LBRACK {token}) formatter =
    formatter
      |> Fmt.fmt "LBRACK {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_rbrack (RBRACK {token}) formatter =
    formatter
      |> Fmt.fmt "RBRACK {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_larray (LARRAY {token}) formatter =
    formatter
      |> Fmt.fmt "LARRAY {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_rarray (RARRAY {token}) formatter =
    formatter
      |> Fmt.fmt "RARRAY {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_lcurly (LCURLY {token}) formatter =
    formatter
      |> Fmt.fmt "LCURLY {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_rcurly (RCURLY {token}) formatter =
    formatter
      |> Fmt.fmt "RCURLY {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_other_token (OTHER_TOKEN {token}) formatter =
    formatter
      |> Fmt.fmt "OTHER_TOKEN {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and pp_token_eoi (EOI {token}) formatter =
    formatter
      |> Fmt.fmt "EOI {"
      |> Scan.Token.pp token
      |> Fmt.fmt "}"

  and fmt_lcurly ~alt ~width formatter =
    match alt with
      | false -> formatter |> Fmt.fmt "{"
      | true ->
        formatter
          |> Fmt.fmt "{\n"
          |> Fmt.fmt ~pad:" " ~just:Fmt.Left ~width:(width + 4L) ""

  and fmt_semi ~alt ~width formatter =
    match alt with
      | false -> formatter |> Fmt.fmt "; "
      | true ->
        formatter
          |> Fmt.fmt "\n"
          |> Fmt.fmt ~pad:" " ~just:Fmt.Left ~width:(width + 4L) ""

  and fmt_rcurly ~alt ~width formatter =
    match alt with
      | false -> formatter |> Fmt.fmt "}"
      | true ->
        formatter
          |> Fmt.fmt "\n"
          |> Fmt.fmt ~pad:" " ~just:Fmt.Left ~width:(width + 2L) ""
          |> Fmt.fmt "}"

  and fmt_uident ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) uident formatter =
    match uident with
      | Uident {token} ->
        formatter |> Fmt.fmt "Uident "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "token=" |> Scan.Token.pp token
          |> fmt_rcurly ~alt ~width
  and pp_uident uident formatter =
    fmt_uident uident formatter

  and fmt_precs_tl ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) precs_tl formatter =
    let width' = width + 4L in
    match precs_tl with
      | PrecsTlUident {uident; precs_tl} ->
        formatter |> Fmt.fmt "PrecsTlUident "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "uident=" |> Scan.Token.pp uident
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "precs_tl=" |> fmt_precs_tl ~alt ~width:width' precs_tl
          |> fmt_rcurly ~alt ~width
      | PrecsTlEpsilon ->
        formatter |> Fmt.fmt "PrecsTlEpsilon"
  and pp_precs_tl precs_tl formatter =
    fmt_precs_tl precs_tl formatter

  and fmt_precs ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) precs formatter =
    let width' = width + 4L in
    match precs with
      | Precs {uident; precs_tl} ->
        formatter |> Fmt.fmt "Precs "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "uident=" |> Scan.Token.pp uident
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "precs_tl=" |> fmt_precs_tl ~alt ~width:width' precs_tl
          |> fmt_rcurly ~alt ~width
  and pp_precs precs formatter =
    fmt_precs precs formatter

  and fmt_prec_rels ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prec_rels formatter =
    let width' = width + 4L in
    match prec_rels with
      | PrecRelsPrecs {precs} ->
        formatter |> Fmt.fmt "PrecRelsPrecs "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "precs=" |> fmt_precs ~alt ~width:width' precs
          |> fmt_rcurly ~alt ~width
      | PrecRelsEpsilon ->
        formatter |> Fmt.fmt "PrecRelsEpsilon"
  and pp_prec_rels prec_rels formatter =
    fmt_prec_rels prec_rels formatter

  and pp_prec_type prec_type formatter =
    match prec_type with
      | PrecTypeNeutral -> formatter |> Fmt.fmt "PrecTypeNeutral"
      | PrecTypeLeft -> formatter |> Fmt.fmt "PrecTypeLeft"
      | PrecTypeRight -> formatter |> Fmt.fmt "PrecTypeRight"

  and fmt_prec ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prec formatter =
    let width' = width + 4L in
    match prec with
      | Prec {prec_type; uident; prec_rels} ->
        formatter |> Fmt.fmt "Prec "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prec_type=" |> pp_prec_type prec_type
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "uident=" |> Scan.Token.pp uident
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prec_rels=" |> fmt_prec_rels ~alt ~width:width' prec_rels
          |> fmt_rcurly ~alt ~width
  and pp_prec prec formatter =
    fmt_prec prec formatter

  and fmt_symbol_type_qualifier ?(alt=Fmt.alt_default) ?(width=Fmt.width_default)
  symbol_type_qualifier formatter =
    let width' = width + 4L in
    match symbol_type_qualifier with
      | SymbolTypeQualifier {cident; symbol_type_qualifier_tl} ->
        formatter |> Fmt.fmt "SymbolTypeQualifier "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "cident=" |> pp_token_cident cident
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "symbol_type_qualifier_tl="
          |> fmt_symbol_type_qualifier ~alt ~width:width' symbol_type_qualifier_tl
          |> fmt_rcurly ~alt ~width
      | SymbolTypeQualifierEpsilon ->
        formatter |> Fmt.fmt "SymbolTypeQualifierEpsilon"

  and fmt_symbol_type ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) symbol_type
  formatter =
    let width' = width + 4L in
    match symbol_type with
      | SymbolType {symbol_type_qualifier; symbol_type} ->
        formatter |> Fmt.fmt "SymbolType "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "symbol_type_qualifier="
          |> fmt_symbol_type_qualifier ~alt ~width:width' symbol_type_qualifier
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "symbol_type=" |> Scan.Token.pp symbol_type
          |> fmt_rcurly ~alt ~width
  and pp_symbol_type symbol_type formatter =
    fmt_symbol_type symbol_type formatter

  and fmt_symbol_type0 ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) symbol_type0
  formatter =
    let width' = width + 4L in
    match symbol_type0 with
      | SymbolType0SymbolType {symbol_type} ->
        formatter |> Fmt.fmt "SymbolType0SymbolType "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "symbol_type=" |> fmt_symbol_type ~alt ~width:width' symbol_type
          |> fmt_rcurly ~alt ~width
      | SymbolType0Epsilon ->
        formatter |> Fmt.fmt "SymbolType0Epsilon"
  and pp_symbol_type0 symbol_type0 formatter =
    fmt_symbol_type0 symbol_type0 formatter

  and fmt_prec_ref ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prec_ref formatter =
    match prec_ref with
      | PrecRefUident {uident} ->
        formatter |> Fmt.fmt "PrecRefUident "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "uident=" |> Scan.Token.pp uident
          |> fmt_rcurly ~alt ~width
      | PrecRefEpsilon ->
        formatter |> Fmt.fmt "PrecRefEpsilon"
  and pp_prec_ref prec_ref formatter =
    fmt_prec_ref prec_ref formatter

  and fmt_token_alias ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) token_alias formatter =
    match token_alias with
      | TokenAlias {alias} ->
        formatter |> Fmt.fmt "Token "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "alias=" |> pp_token_istring alias
          |> fmt_rcurly ~alt ~width
      | TokenAliasEpsilon ->
        formatter |> Fmt.fmt "TokenAliasEpsilon"
  and pp_token_alias token_alias formatter =
    fmt_token_alias token_alias formatter

  and fmt_token ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) token formatter =
    let width' = width + 4L in
    match token with
      | Token {cident; token_alias; symbol_type0; prec_ref} ->
        formatter |> Fmt.fmt "Token "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "cident=" |> pp_token_cident cident
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "token_alias=" |> fmt_token_alias ~alt ~width:width' token_alias
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "symbol_type0=" |> fmt_symbol_type0 ~alt ~width:width' symbol_type0
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prec_ref=" |> fmt_prec_ref ~alt ~width:width' prec_ref
          |> fmt_rcurly ~alt ~width
  and pp_token token formatter =
    fmt_token token formatter

  and fmt_sep ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) sep formatter =
    match sep with
      | SepLineDelim {line_delim} ->
        formatter |> Fmt.fmt "SepLineDelim "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "line_delim=" |> pp_token_line_delim line_delim
          |> fmt_rcurly ~alt ~width
      | SepSemi {semi} ->
        formatter |> Fmt.fmt "SepSemi "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "semi=" |> pp_token_semi semi
          |> fmt_rcurly ~alt ~width
      | SepBar {bar} ->
        formatter |> Fmt.fmt "SepBar "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "bar=" |> pp_token_bar bar
          |> fmt_rcurly ~alt ~width
  and pp_sep sep formatter =
    fmt_sep sep formatter

  and fmt_codes_tl ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) codes_tl formatter =
    let width' = width + 4L in
    match codes_tl with
      | CodesTlSepCode {sep; code; codes_tl} ->
        formatter |> Fmt.fmt "CodesTlSepCode "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "sep=" |> fmt_sep ~alt ~width:width' sep
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "code=" |> fmt_code ~alt ~width:width' code
          |> fmt_rcurly ~alt ~width
          |> Fmt.fmt "codes_tl=" |> fmt_codes_tl ~alt ~width:width' codes_tl
          |> fmt_rcurly ~alt ~width
      | CodesTlEpsilon -> formatter |> Fmt.fmt "CodesTlEpsilon"
  and pp_codes_tl codes_tl formatter =
    fmt_codes codes_tl formatter

  and fmt_codes ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) codes formatter =
    let width' = width + 4L in
    match codes with
      | Codes {code; codes_tl} ->
        formatter |> Fmt.fmt "Codes "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "code=" |> fmt_code ~alt ~width:width' code
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "codes_tl=" |> fmt_codes_tl ~alt ~width:width' codes_tl
          |> fmt_rcurly ~alt ~width
  and pp_codes codes formatter =
    fmt_codes codes formatter

  and fmt_codes0 ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) codes0 formatter =
    let width' = width + 4L in
    match codes0 with
      | Codes0Codes {codes} ->
        formatter |> Fmt.fmt "Codes0Codes "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "codes=" |> fmt_codes ~alt ~width:width' codes
          |> fmt_rcurly ~alt ~width
      | Codes0Epsilon ->
        formatter |> Fmt.fmt "Codes0Epsilon"
  and pp_codes0 codes formatter =
    fmt_codes codes formatter

  and fmt_delimited ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) delimited formatter =
    let width' = width + 4L in
    match delimited with
      | DelimitedBlock {indent; codes; dedent} ->
        formatter |> Fmt.fmt "DelimitedBlock "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "indent=" |> pp_token_indent indent
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "codes=" |> fmt_codes ~alt ~width:width' codes
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "dedent=" |> pp_token_dedent dedent
          |> fmt_rcurly ~alt ~width
      | DelimitedParen {lparen; codes0; rparen} ->
        formatter |> Fmt.fmt "DelimitedParen "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "lparen=" |> pp_token_lparen lparen
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "codes0=" |> fmt_codes0 ~alt ~width:width' codes0
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "rparen=" |> pp_token_rparen rparen
          |> fmt_rcurly ~alt ~width
      | DelimitedCapture {lcapture; codes0; rcapture} ->
        formatter |> Fmt.fmt "DelimitedCapture "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "lcapture=" |> pp_token_lcapture lcapture
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "codes0=" |> fmt_codes0 ~alt ~width:width' codes0
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "rcapture=" |> pp_token_rcapture rcapture
          |> fmt_rcurly ~alt ~width
      | DelimitedList {lbrack; codes0; rbrack} ->
        formatter |> Fmt.fmt "DelimitedList "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "lbrack=" |> pp_token_lbrack lbrack
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "codes0=" |> fmt_codes0 ~alt ~width:width' codes0
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "rbrack=" |> pp_token_rbrack rbrack
          |> fmt_rcurly ~alt ~width
      | DelimitedArray {larray; codes0; rarray} ->
        formatter |> Fmt.fmt "DelimitedArray "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "larray=" |> pp_token_larray larray
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "codes0=" |> fmt_codes0 ~alt ~width:width' codes0
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "rarray=" |> pp_token_rarray rarray
          |> fmt_rcurly ~alt ~width
      | DelimitedModule {lcurly; codes0; rcurly} ->
        formatter |> Fmt.fmt "DelimitedModule "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "lcurly=" |> pp_token_lcurly lcurly
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "codes0=" |> fmt_codes0 ~alt ~width:width' codes0
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "rcurly=" |> pp_token_rcurly rcurly
          |> fmt_rcurly ~alt ~width
  and pp_delimited delimited formatter =
    fmt_delimited delimited formatter

  and pp_code_token code_token formatter =
    match code_token with
      | CodeToken {token} -> formatter |> Scan.Token.pp token

  and fmt_code_tl ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) code_tl formatter =
    let width' = width + 4L in
    match code_tl with
      | CodeTlDelimited {delimited; code_tl} ->
        formatter |> Fmt.fmt "CodeTlDelimited "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "delimited=" |> fmt_delimited ~alt ~width:width' delimited
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "code_tl=" |> fmt_code_tl ~alt ~width:width' code_tl
          |> fmt_rcurly ~alt ~width
      | CodeTlCodeToken {code_token; code_tl} ->
        formatter |> Fmt.fmt "CodeTlCodeToken "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "code_token=" |> pp_code_token code_token
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "code_tl=" |> fmt_code_tl ~alt ~width:width' code_tl
          |> fmt_rcurly ~alt ~width
      | CodeTlEpsilon ->
        formatter |> Fmt.fmt "CodeTlEpsilon"
  and pp_code_tl code_tl formatter =
    fmt_code code_tl formatter

  and fmt_code ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) code formatter =
    let width' = width + 4L in
    match code with
      | CodeDelimited {delimited; code_tl} ->
        formatter |> Fmt.fmt "CodeDelimited "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "delimited=" |> fmt_delimited ~alt ~width:width' delimited
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "code_tl=" |> fmt_code_tl ~alt ~width:width' code_tl
          |> fmt_rcurly ~alt ~width
      | CodeCodeToken {code_token; code_tl} ->
        formatter |> Fmt.fmt "CodeCodeToken "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "code_token=" |> pp_code_token code_token
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "code_tl=" |> fmt_code_tl ~alt ~width:width' code_tl
          |> fmt_rcurly ~alt ~width
  and pp_code code formatter =
    fmt_code code formatter

  and fmt_pattern_field ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) pattern_field formatter =
    let width' = width + 4L in
    match pattern_field with
      | PatternFieldBinding {binding} ->
        formatter |> Fmt.fmt "PatternFieldBinding "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "binding=" |> fmt_uident ~alt ~width:width' binding
          |> fmt_rcurly ~alt ~width
      | PatternFieldPattern {pattern} ->
        formatter |> Fmt.fmt "PatternFieldPattern "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "pattern=" |> fmt_pattern ~alt ~width:width' pattern
          |> fmt_rcurly ~alt ~width
  and pp_pattern_field pattern_field formatter =
    fmt_pattern_field pattern_field formatter

  and fmt_pattern_fields ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) pattern_fields
  formatter =
    let width' = width + 4L in
    match pattern_fields with
      | PatternFieldsOne {field} ->
        formatter |> Fmt.fmt "PatternFieldsOne "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "field=" |> fmt_pattern_field ~alt ~width:width' field
          |> fmt_rcurly ~alt ~width
      | PatternFieldsMulti {field; fields} ->
        formatter |> Fmt.fmt "PatternFieldsMulti "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "field=" |> fmt_pattern_field ~alt ~width:width' field
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "fields=" |> fmt_pattern_fields ~alt ~width:width' fields
          |> fmt_rcurly ~alt ~width
  and pp_pattern_fields pattern_fields formatter =
    fmt_pattern_fields pattern_fields formatter

  and pp_semi_suffix semi_suffix formatter =
    match semi_suffix with
      | SemiSuffix -> formatter |> Fmt.fmt "SemiSuffix"

  and pp_module_path module_path formatter =
    match module_path with
      | ModulePath -> formatter |> Fmt.fmt "ModulePath"

  and fmt_pattern ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) pattern formatter =
    let width' = width + 4L in
    match pattern with
      | PatternUscore ->
        formatter |> Fmt.fmt "PatternUscore"
      | PatternBinding {binding} ->
        formatter |> Fmt.fmt "PatternBinding "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "binding=" |> fmt_uident ~alt ~width:width' binding
          |> fmt_rcurly ~alt ~width
      | PatternPattern {pattern} ->
        formatter |> Fmt.fmt "PatternPattern "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "pattern=" |> fmt_pattern ~alt ~width:width' pattern
          |> fmt_rcurly ~alt ~width
      | PatternComma {pattern_a; pattern_b} ->
        formatter |> Fmt.fmt "PatternComma "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "pattern_a=" |> fmt_pattern ~alt ~width:width' pattern_a
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "pattern_b=" |> fmt_pattern ~alt ~width:width' pattern_b
          |> fmt_rcurly ~alt ~width
      | PatternFields {fields} ->
        formatter |> Fmt.fmt "PatternFields "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "fields=" |> fmt_pattern_fields ~alt ~width:width' fields
          |> fmt_rcurly ~alt ~width
  and pp_pattern pattern formatter =
    fmt_pattern pattern formatter

  and fmt_prod_param_symbol ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prod_param_symbol
    formatter =
    match prod_param_symbol with
      | ProdParamSymbolCident {cident} ->
        formatter |> Fmt.fmt "ProdParamSymbolCident "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "cident=" |> pp_token_cident cident
          |> fmt_rcurly ~alt ~width
      | ProdParamSymbolAlias {alias} ->
        formatter |> Fmt.fmt "ProdParamSymbolAlias "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "alias=" |> pp_token_istring alias
          |> fmt_rcurly ~alt ~width
  and pp_prod_param_symbol prod_param_symbol formatter =
    fmt_prod_param_symbol prod_param_symbol formatter

  and fmt_prod_param ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prod_param formatter =
    let width' = width + 4L in
    match prod_param with
      | ProdParamBinding {binding; prod_param_symbol} ->
        formatter |> Fmt.fmt "ProdParamBinding "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "binding=" |> fmt_uident ~alt ~width:width' binding
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prod_param_symbol="
          |> fmt_prod_param_symbol ~alt ~width:width' prod_param_symbol
          |> fmt_rcurly ~alt ~width
      | ProdParamPattern {lparen; pattern; rparen; prod_param_symbol} ->
        formatter |> Fmt.fmt "ProdParamPattern "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "lparen=" |> pp_token_lparen lparen
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "pattern=" |> fmt_pattern ~alt ~width:width' pattern
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "rparen=" |> pp_token_rparen rparen
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prod_param_symbol="
          |> fmt_prod_param_symbol ~alt ~width:width' prod_param_symbol
          |> fmt_rcurly ~alt ~width
      | ProdParamFields {lcurly; fields; rcurly; prod_param_symbol} ->
        formatter |> Fmt.fmt "ProdParamFields "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "lcurly=" |> pp_token_lcurly lcurly
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "fields=" |> fmt_pattern_fields ~alt ~width:width' fields
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "rcurly=" |> pp_token_rcurly rcurly
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prod_param_symbol="
          |> fmt_prod_param_symbol ~alt ~width:width' prod_param_symbol
          |> fmt_rcurly ~alt ~width
      | ProdParam {prod_param_symbol} ->
        formatter |> Fmt.fmt "ProdParam "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prod_param_symbol="
          |> fmt_prod_param_symbol ~alt ~width:width' prod_param_symbol
          |> fmt_rcurly ~alt ~width
  and pp_prod_param prod_param formatter =
    fmt_prod_param prod_param formatter

  and fmt_prod_params_tl ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prod_params_tl
  formatter =
    let width' = width + 4L in
    match prod_params_tl with
      | ProdParamsTlProdParam {prod_param; prod_params_tl} ->
        formatter |> Fmt.fmt "ProdParamsTlProdParam "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prod_param=" |> fmt_prod_param ~alt ~width:width' prod_param
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prod_params_tl=" |> fmt_prod_params_tl ~alt ~width:width' prod_params_tl
          |> fmt_rcurly ~alt ~width
      | ProdParamsTlPrecRef {prec_ref} ->
        formatter |> Fmt.fmt "ProdParamsTlPrecRef "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prec_ref=" |> fmt_prec_ref ~alt ~width:width' prec_ref
          |> fmt_rcurly ~alt ~width
  and pp_prod_params_tl prod_params_tl formatter =
    fmt_prod_params_tl prod_params_tl formatter

  and fmt_prod_params ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prod_params formatter =
    let width' = width + 4L in
    match prod_params with
      | ProdParamsProdParam {prod_param; prod_params_tl} ->
        formatter |> Fmt.fmt "ProdParamsProdParam "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prod_param=" |> fmt_prod_param ~alt ~width:width' prod_param
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prod_params_tl=" |> fmt_prod_params_tl ~alt ~width:width' prod_params_tl
          |> fmt_rcurly ~alt ~width
  and pp_prod_params prod_params formatter =
    fmt_prod_params prod_params formatter

  and fmt_prod_pattern ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prod_pattern formatter =
    let width' = width + 4L in
    match prod_pattern with
      | ProdPatternParams {prod_params} ->
        formatter |> Fmt.fmt "ProdPatternParams "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prod_params=" |> fmt_prod_params ~alt ~width:width' prod_params
          |> fmt_rcurly ~alt ~width
      | ProdPatternEpsilon {epsilon; prec_ref} ->
        formatter |> Fmt.fmt "ProdPatternEpsilon "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "epsilon=" |> pp_token_epsilon epsilon
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prec_ref=" |> fmt_prec_ref ~alt ~width:width' prec_ref
          |> fmt_rcurly ~alt ~width
  and pp_prod_pattern prod_pattern formatter =
    fmt_prod_pattern prod_pattern formatter

  and fmt_prod ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prod formatter =
    let width' = width + 4L in
    match prod with
      | Prod {prod_pattern} ->
        formatter |> Fmt.fmt "Prod "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prod_pattern=" |> fmt_prod_pattern ~alt ~width:width' prod_pattern
          |> fmt_rcurly ~alt ~width
  and pp_prod prod formatter =
    fmt_prod prod formatter

  and fmt_prods_tl ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prods_tl formatter =
    let width' = width + 4L in
    match prods_tl with
      | ProdsTlProd {prod; prods_tl} ->
        formatter |> Fmt.fmt "ProdsTlProd "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prod=" |> fmt_prod ~alt ~width:width' prod
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prods_tl=" |> fmt_prods_tl ~alt ~width:width' prods_tl
          |> fmt_rcurly ~alt ~width
      | ProdsTlEpsilon ->
        formatter |> Fmt.fmt "ProdsTlEpsilon"
  and pp_prods_tl prods_tl formatter =
    fmt_prods_tl prods_tl formatter

  and fmt_prods ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) prods formatter =
    let width' = width + 4L in
    match prods with
      | ProdsProd {prod; prods_tl} ->
        formatter |> Fmt.fmt "ProdsProd "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prod=" |> fmt_prod ~alt ~width:width' prod
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prods_tl=" |> fmt_prods_tl ~alt ~width:width' prods_tl
          |> fmt_rcurly ~alt ~width
  and pp_prods prods formatter =
    fmt_prods prods formatter

  and fmt_reduction ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) reduction formatter =
    let width' = width + 4L in
    match reduction with
      | Reduction {prods; code} ->
        formatter |> Fmt.fmt "Reduction "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prods=" |> fmt_prods ~alt ~width:width' prods
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "code=" |> pp_code code
          |> fmt_rcurly ~alt ~width
  and pp_reduction reduction formatter =
    fmt_reduction reduction formatter

  and fmt_reductions_tl ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) reductions_tl formatter =
    let width' = width + 4L in
    match reductions_tl with
      | ReductionsTlReduction {reduction; reductions_tl} ->
        formatter |> Fmt.fmt "ReductionsTlReduction "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "reduction=" |> fmt_reduction ~alt ~width:width' reduction
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "reductions_tl=" |> fmt_reductions_tl ~alt ~width:width' reductions_tl
          |> fmt_rcurly ~alt ~width
      | ReductionsTlEpsilon ->
        formatter |> Fmt.fmt "ReductionsTlEpsilon"
  and pp_reductions_tl reductions_tl formatter =
    fmt_reductions_tl reductions_tl formatter

  and fmt_reductions ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) reductions formatter =
    let width' = width + 4L in
    match reductions with
      | ReductionsReduction {reduction; reductions_tl} ->
        formatter |> Fmt.fmt "ReductionsReduction "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "reduction=" |> fmt_reduction ~alt ~width:width' reduction
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "reductions_tl=" |> fmt_reductions_tl ~alt ~width:width' reductions_tl
          |> fmt_rcurly ~alt ~width
  and pp_reductions reductions formatter =
    fmt_reductions reductions formatter

  and pp_nonterm_type nonterm_type formatter =
    match nonterm_type with
      | NontermTypeNonterm -> formatter |> Fmt.fmt "NontermTypeNonterm"
      | NontermTypeStart -> formatter |> Fmt.fmt "NontermTypeStart"

  and fmt_nonterm ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) nonterm formatter =
    let width' = width + 4L in
    match nonterm with
      | NontermProds {nonterm_type; cident; prec_ref; prods} ->
        formatter |> Fmt.fmt "NontermProds "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "nonterm_type=" |> pp_nonterm_type nonterm_type
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "cident=" |> pp_token_cident cident
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prec_ref=" |> fmt_prec_ref ~alt ~width:width' prec_ref
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prods=" |> fmt_prods ~alt ~width:width' prods
          |> fmt_rcurly ~alt ~width
      | NontermReductions {nonterm_type; cident; symbol_type; prec_ref; reductions} ->
        formatter |> Fmt.fmt "NontermReductions "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "nonterm_type=" |> pp_nonterm_type nonterm_type
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "cident=" |> pp_token_cident cident
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "symbol_type=" |> fmt_symbol_type ~alt ~width:width' symbol_type
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "prec_ref=" |> fmt_prec_ref ~alt ~width:width' prec_ref
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "reductions=" |> fmt_reductions ~alt ~width:width' reductions
          |> fmt_rcurly ~alt ~width
  and pp_nonterm nonterm formatter =
    fmt_nonterm nonterm formatter

  and fmt_stmt ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) stmt formatter =
    let width' = width + 4L in
    match stmt with
      | StmtPrec {prec} ->
        formatter |> Fmt.fmt "StmtPrec "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prec=" |> fmt_prec ~alt ~width:width' prec
          |> fmt_rcurly ~alt ~width
      | StmtToken {token} ->
        formatter |> Fmt.fmt "StmtToken "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "token=" |> fmt_token ~alt ~width:width' token
          |> fmt_rcurly ~alt ~width
      | StmtNonterm {nonterm} ->
        formatter |> Fmt.fmt "StmtNonterm "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "nonterm=" |> fmt_nonterm ~alt ~width:width' nonterm
          |> fmt_rcurly ~alt ~width
  and pp_stmt stmt formatter =
    fmt_stmt stmt formatter

  and fmt_stmts_tl ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) stmts_tl formatter =
    let width' = width + 4L in
    match stmts_tl with
      | StmtsTl {stmt; stmts_tl} ->
        formatter |> Fmt.fmt "StmtsTl "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "stmt=" |> fmt_stmt ~alt ~width:width' stmt
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "stmts_tl=" |> fmt_stmts_tl ~alt ~width:width' stmts_tl
          |> fmt_rcurly ~alt ~width
      | StmtsTlEpsilon ->
        formatter |> Fmt.fmt "StmtsTlEpsilon"
  and pp_stmts_tl stmts_tl formatter =
    fmt_stmts_tl stmts_tl formatter

  and fmt_stmts ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) stmts formatter =
    let width' = width + 4L in
    match stmts with
      | Stmts {stmt; stmts_tl} ->
        formatter |> Fmt.fmt "Stmts "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "stmt=" |> fmt_stmt ~alt ~width:width' stmt
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "stmts_tl=" |> fmt_stmts_tl ~alt ~width:width' stmts_tl
          |> fmt_rcurly ~alt ~width
  and pp_stmts stmts formatter =
    fmt_stmts stmts formatter

  and fmt_hocc ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) hocc_ formatter =
    let width' = width + 4L in
    match hocc_ with
      | Hocc {hocc_; indent; stmts; dedent} ->
        formatter |> Fmt.fmt "Hocc "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "hocc_=" |> pp_token_hocc hocc_
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "indent=" |> pp_token_indent indent
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "stmts=" |> fmt_stmts ~alt ~width:width' stmts
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "dedent=" |> pp_token_dedent dedent
          |> fmt_rcurly ~alt ~width
  and pp_hocc hocc_ formatter =
    fmt_hocc hocc_ formatter

  and fmt_matter ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) matter formatter =
    let width' = width + 4L in
    match matter with
      | Matter {token; matter} ->
        formatter |> Fmt.fmt "Matter "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "token=" |> Scan.Token.pp token
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "matter=" |> fmt_matter ~alt ~width:width' matter
          |> fmt_rcurly ~alt ~width
      | MatterEpsilon ->
        formatter |> Fmt.fmt "MatterEpsilon"
  and pp_matter matter formatter =
    fmt_matter matter formatter

  and fmt_hmh ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) hmh formatter =
    let width' = width + 4L in
    match hmh with
      | Hmh {prelude; hocc_; postlude; eoi} ->
        formatter |> Fmt.fmt "Hmh "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prelude=" |> pp_matter prelude
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "hocc_=" |> fmt_hocc ~alt ~width:width' hocc_
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "postlude=" |> pp_matter postlude
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "eoi=" |> pp_token_eoi eoi
          |> fmt_rcurly ~alt ~width
  and pp_hmh hmh formatter =
    fmt_hmh hmh formatter

  and fmt_hmhi ?(alt=Fmt.alt_default) ?(width=Fmt.width_default) hmhi formatter =
    match hmhi with
      | Hmhi {prelude; hocc_; postlude; eoi} ->
        formatter |> Fmt.fmt "Hmhi "
          |> fmt_lcurly ~alt ~width
          |> Fmt.fmt "prelude=" |> pp_matter prelude
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "hocc_=" |> pp_token_hocc hocc_
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "postlude=" |> pp_matter postlude
          |> fmt_semi ~alt ~width
          |> Fmt.fmt "eoi=" |> pp_token_eoi eoi
          |> fmt_rcurly ~alt ~width
  and pp_hmhi hmhi formatter =
    fmt_hmhi hmhi formatter

(**************************************************************************************************)
(* source_of_* functions. *)

(* Not to be confused with joining forces. *)
let join_sources source0_opt source1_opt =
    match source0_opt, source1_opt with
      | None, None -> None
      | Some _, None -> source0_opt
      | None, Some _ -> source1_opt
      | Some source0, Some source1 -> begin
        let open Hmc.Source in
        let base0, past0 = Slice.cursors source0 in
        let base1, past1 = Slice.cursors source1 in
        let open Cmp in
        let base = match Cursor.cmp base0 base1 with
          | Lt
          | Eq -> base0
          | Gt -> base1
        in
        let past = match Cursor.cmp past0 past1 with
          | Lt
          | Eq -> past1
          | Gt -> past0
        in
        Some (Slice.of_cursors ~base ~past)
      end

(* Not to be confused with a token force. *)
let token_source token =
    Some (Scan.Token.source token)

let source_of_token_epsilon = function
  | EPSILON {token} -> token_source token

let source_of_token_uident = function
  | UIDENT {token} -> token_source token

let source_of_token_cident = function
  | CIDENT {token} -> token_source token

let source_of_token_istring = function
  | ISTRING {token} -> token_source token

let source_of_token_lparen = function
  | LPAREN {token} -> token_source token

let source_of_token_rparen = function
  | RPAREN {token} -> token_source token

let source_of_token_lcurly = function
  | LCURLY {token} -> token_source token

let source_of_token_rcurly = function
  | RCURLY {token} -> token_source token

let rec source_of_binding = function
  | Uident {token} -> token_source token
  and source_of_prod_param_symbol = function
  | ProdParamSymbolCident {cident} -> source_of_token_cident cident
  | ProdParamSymbolAlias {alias} -> source_of_token_istring alias
  and source_of_prec_ref = function
  | PrecRefUident {uident} -> token_source uident
  | PrecRefEpsilon -> None
  and source_of_prod_param_binding_pattern = function
  | ProdParamBinding {binding; _} -> source_of_binding binding
  | ProdParamPattern {lparen; rparen; _} ->
    source_of_token_lparen lparen
      |> join_sources (source_of_token_rparen rparen)
  | ProdParamFields {lcurly; rcurly; _} ->
    source_of_token_lcurly lcurly
      |> join_sources (source_of_token_rcurly rcurly)
  | ProdParam _ -> None
  and source_of_prod_param t =
    match t with
      | ProdParamBinding {prod_param_symbol; _}
      | ProdParamPattern {prod_param_symbol; _}
      | ProdParamFields {prod_param_symbol; _}
      | ProdParam {prod_param_symbol} ->
        source_of_prod_param_binding_pattern t
          |> join_sources (source_of_prod_param_symbol prod_param_symbol)
  and source_of_prod_params_tl = function
  | ProdParamsTlProdParam {prod_param; prod_params_tl} ->
    source_of_prod_param prod_param
      |> join_sources (source_of_prod_params_tl prod_params_tl)
  | ProdParamsTlPrecRef {prec_ref} -> source_of_prec_ref prec_ref
  and source_of_prod_params = function
  | ProdParamsProdParam {prod_param; prod_params_tl} ->
    source_of_prod_param prod_param
      |> join_sources (source_of_prod_params_tl prod_params_tl)
  and source_of_prod_pattern = function
  | ProdPatternParams {prod_params} -> source_of_prod_params prod_params
  | ProdPatternEpsilon {epsilon; prec_ref} ->
    source_of_token_epsilon epsilon
      |> join_sources (source_of_prec_ref prec_ref)

(**************************************************************************************************)
(* Miscellaneous helper functions. *)

let min_comment_indentation_of_hocc_block = function
  | Hocc {indent=INDENT {token=indent}; _} ->
    Scan.Token.source indent
      |> Hmc.Source.Slice.base
      |> Hmc.Source.Cursor.pos
      |> Text.Pos.col

let base_of_code code =
    let of_token token =
        let source = Scan.Token.source token in
        Hmc.Source.Slice.base source
      in
    let rec of_delimited = function
      | DelimitedBlock {indent=INDENT {token}; _}
      | DelimitedParen {lparen=LPAREN {token}; _}
      | DelimitedCapture {lcapture=LCAPTURE {token}; _}
      | DelimitedList {lbrack=LBRACK {token}; _}
      | DelimitedArray {larray=LARRAY {token}; _}
      | DelimitedModule {lcurly=LCURLY {token}; _} -> of_token token
      and of_code_token = function
      | CodeToken {token} -> of_token token
      and of_code = function
      | CodeDelimited {delimited; _} -> of_delimited delimited
      | CodeCodeToken {code_token; _} -> of_code_token code_token
      in
    of_code code

let last_token_of_code code =
    let rec of_codes_tl = function
      | CodesTlSepCode {code; codes_tl; _} -> begin
        of_codes_tl codes_tl
          |> Option.some_or_thunk ~f:(fun () -> Some (of_code code))
      end
      | CodesTlEpsilon -> None
      and of_codes = function
      | Codes {code; codes_tl} -> begin
        of_codes_tl codes_tl
          |> Option.value_or_thunk ~f:(fun () -> of_code code)
      end
      and of_delimited = function
      | DelimitedBlock {codes; dedent=DEDENT {token=dedent}; _} -> begin
        of_codes codes
          |> Option.some_or_thunk ~f:(fun () -> Some dedent)
          |> Option.value_hlt
      end
      | DelimitedParen {rparen=RPAREN {token}; _}
      | DelimitedCapture {rcapture=RCAPTURE {token}; _}
      | DelimitedList {rbrack=RBRACK {token}; _}
      | DelimitedArray {rarray=RARRAY {token}; _}
      | DelimitedModule {rcurly=RCURLY {token}; _} -> token
      and of_code_token = function
      | CodeToken {token} -> token
      and of_code_tl = function
      | CodeTlDelimited {delimited; code_tl} ->
        of_code_tl code_tl |> Option.some_or_thunk ~f:(fun () -> Some (of_delimited delimited))
      | CodeTlCodeToken {code_token; code_tl} ->
        of_code_tl code_tl |> Option.some_or_thunk ~f:(fun () -> Some (of_code_token code_token))
      | CodeTlEpsilon -> None
      and of_code = function
      | CodeDelimited {delimited; code_tl} ->
        of_code_tl code_tl |> Option.some_or_thunk ~f:(fun () -> Some (of_delimited delimited))
      | CodeCodeToken {code_token; code_tl} ->
        of_code_tl code_tl |> Option.some_or_thunk ~f:(fun () -> Some (of_code_token code_token))
      in
    of_code code
      |> Option.value_hlt

let past_of_code code =
    let of_token token =
        let source = Scan.Token.source token in
        Hmc.Source.Slice.past source
      in
    last_token_of_code code |> of_token

let source_of_code code =
    let base = base_of_code code in
    let past = past_of_code code in
    Hmc.Source.Slice.of_cursors ~base ~past

let indentation_of_code hocc_block code =
    let min_comment_indentation = min_comment_indentation_of_hocc_block hocc_block in
    match code with
      | CodeDelimited _ -> min_comment_indentation + 4L
      | CodeCodeToken _ -> min_comment_indentation

(* Find the base cursor for the postlude that preserves comments/whitespace that fall outside the
 * `hocc` block. *)
let postlude_base_of_hocc (Hocc {stmts=Stmts {stmt; stmts_tl}; _}) =
    let rec of_precs_tl = function
      | PrecsTlUident {uident; precs_tl} ->
        Some (
          of_precs_tl precs_tl
          |> Option.value_or_thunk ~f:(fun () -> uident)
          )
      | PrecsTlEpsilon -> None
      and of_precs = function
      | Precs {uident; precs_tl} -> begin
        of_precs_tl precs_tl
          |> Option.value_or_thunk ~f:(fun () -> uident)
      end
      and of_prec_rels = function
      | PrecRelsPrecs {precs} -> Some (of_precs precs)
      | PrecRelsEpsilon -> None
      and of_symbol_type = function
      | SymbolType {symbol_type; _} -> symbol_type
      and of_symbol_type0 = function
      | SymbolType0SymbolType {symbol_type} -> Some (of_symbol_type symbol_type)
      | SymbolType0Epsilon -> None
      and of_prec_ref = function
      | PrecRefUident {uident} -> Some uident
      | PrecRefEpsilon -> None
      and of_token_alias = function
      | TokenAlias {alias=ISTRING {token=alias}} -> Some alias
      | TokenAliasEpsilon -> None
      and of_prod_param_symbol = function
      | ProdParamSymbolCident {cident=CIDENT {token=cident}} -> cident
      | ProdParamSymbolAlias {alias=ISTRING {token=alias}} -> alias
      and of_prod_param = function
      | ProdParamBinding {prod_param_symbol; _}
      | ProdParamPattern {prod_param_symbol; _}
      | ProdParamFields {prod_param_symbol; _}
      | ProdParam {prod_param_symbol} -> of_prod_param_symbol prod_param_symbol
      and of_prod_params_tl = function
      | ProdParamsTlProdParam {prod_param; prod_params_tl} -> begin
        of_prod_params_tl prod_params_tl
          |> Option.some_or_thunk ~f:(fun () -> Some (of_prod_param prod_param))
      end
      | ProdParamsTlPrecRef {prec_ref} -> of_prec_ref prec_ref
      and of_prod_params = function
      | ProdParamsProdParam {prod_param; prod_params_tl} -> begin
        of_prod_params_tl prod_params_tl
          |> Option.value_or_thunk ~f:(fun () -> of_prod_param prod_param)
      end
      and of_prod_pattern = function
      | ProdPatternParams {prod_params} -> of_prod_params prod_params
      | ProdPatternEpsilon {epsilon=EPSILON {token=epsilon}; prec_ref} ->
        of_prec_ref prec_ref
          |> Option.value_or_thunk ~f:(fun () -> epsilon)
      and of_prod = function
      | Prod {prod_pattern} -> of_prod_pattern prod_pattern
      and of_prods_tl = function
      | ProdsTlProd {prod; prods_tl} -> begin
        of_prods_tl prods_tl
          |> Option.some_or_thunk ~f:(fun () -> Some (of_prod prod))
      end
      | ProdsTlEpsilon -> None
      and of_prods = function
      | ProdsProd {prod; prods_tl} -> begin
        of_prods_tl prods_tl
          |> Option.value_or_thunk ~f:(fun () -> of_prod prod)
      end
      and of_reduction = function
      | Reduction {code; _} -> last_token_of_code code
      and of_reductions_tl = function
      | ReductionsTlReduction {reduction; reductions_tl} -> begin
        of_reductions_tl reductions_tl
          |> Option.some_or_thunk ~f:(fun () -> Some (of_reduction reduction))
      end
      | ReductionsTlEpsilon -> None
      and of_reductions = function
      | ReductionsReduction {reduction; reductions_tl} -> begin
        of_reductions_tl reductions_tl
          |> Option.value_or_thunk ~f:(fun () -> of_reduction reduction)
      end
      and of_nonterm = function
      | NontermProds {prods; _} -> of_prods prods
      | NontermReductions {reductions; _} -> of_reductions reductions
      and of_stmt = function
      | StmtPrec {prec=Prec {uident; prec_rels; _}} -> begin
        of_prec_rels prec_rels
          |> Option.value_or_thunk ~f:(fun () -> uident)
      end
      | StmtToken {token=Token {cident=CIDENT {token=cident}; token_alias; symbol_type0;
      prec_ref; _}} -> begin
        of_prec_ref prec_ref
          |> Option.some_or_thunk ~f:(fun () -> of_symbol_type0 symbol_type0)
          |> Option.some_or_thunk ~f:(fun () -> of_token_alias token_alias)
          |> Option.value_or_thunk ~f:(fun () -> cident)
      end
      | StmtNonterm {nonterm} -> of_nonterm nonterm
      and of_stmts_tl = function
      | StmtsTl {stmt; stmts_tl} -> begin
        (of_stmts_tl stmts_tl)
          |> Option.some_or_thunk ~f:(fun () -> Some (of_stmt stmt))
      end
      | StmtsTlEpsilon -> None
      in
    of_stmts_tl stmts_tl
      |> Option.value_or_thunk ~f:(fun () -> of_stmt stmt)
      |> Scan.Token.source
      |> Hmc.Source.Slice.past
